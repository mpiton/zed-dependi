{"files":[{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","backend.rs"],"content":"use std::sync::{Arc, RwLock};\n\nuse dashmap::DashMap;\nuse reqwest::Client as HttpClient;\nuse tower_lsp::jsonrpc::Result;\nuse tower_lsp::lsp_types::*;\nuse tower_lsp::{Client, LanguageServer};\n\nuse crate::cache::{HybridCache, ReadCache, WriteCache};\nuse crate::config::Config;\nuse crate::document::DocumentState;\nuse crate::file_types::FileType;\nuse crate::parsers::Parser;\nuse crate::parsers::cargo::CargoParser;\nuse crate::parsers::csharp::CsharpParser;\nuse crate::parsers::dart::DartParser;\nuse crate::parsers::go::GoParser;\nuse crate::parsers::npm::NpmParser;\nuse crate::parsers::php::PhpParser;\nuse crate::parsers::python::PythonParser;\nuse crate::parsers::ruby::RubyParser;\nuse crate::providers::code_actions::create_code_actions;\nuse crate::providers::completion::{format_release_age, get_completions};\nuse crate::providers::diagnostics::create_diagnostics;\nuse crate::providers::inlay_hints::create_inlay_hint;\nuse crate::registries::crates_io::CratesIoRegistry;\nuse crate::registries::go_proxy::GoProxyRegistry;\nuse crate::registries::http_client::create_shared_client;\nuse crate::registries::npm::NpmRegistry;\nuse crate::registries::nuget::NuGetRegistry;\nuse crate::registries::packagist::PackagistRegistry;\nuse crate::registries::pub_dev::PubDevRegistry;\nuse crate::registries::pypi::PyPiRegistry;\nuse crate::registries::rubygems::RubyGemsRegistry;\nuse crate::registries::{Registry, VersionInfo, VulnerabilitySeverity};\nuse crate::reports::{VulnerabilityReportEntry, VulnerabilitySummary, generate_markdown_report};\nuse crate::vulnerabilities::VulnerabilityQuery;\nuse crate::vulnerabilities::cache::VulnerabilityCache;\nuse crate::vulnerabilities::osv::OsvClient;\n\npub struct DependiBackend {\n    client: Client,\n    /// Configuration\n    config: RwLock<Config>,\n    /// Cache for documents and their parsed state\n    documents: DashMap<Url, DocumentState>,\n    /// Cache for version information (keyed by \"registry:package\")\n    version_cache: Arc<HybridCache>,\n    /// Parsers\n    cargo_parser: CargoParser,\n    npm_parser: NpmParser,\n    python_parser: PythonParser,\n    go_parser: GoParser,\n    php_parser: PhpParser,\n    dart_parser: DartParser,\n    csharp_parser: CsharpParser,\n    ruby_parser: RubyParser,\n    /// Registry clients\n    crates_io: Arc<CratesIoRegistry>,\n    npm_registry: Arc<NpmRegistry>,\n    pypi: Arc<PyPiRegistry>,\n    go_proxy: Arc<GoProxyRegistry>,\n    packagist: Arc<PackagistRegistry>,\n    pub_dev: Arc<PubDevRegistry>,\n    nuget: Arc<NuGetRegistry>,\n    rubygems: Arc<RubyGemsRegistry>,\n    /// Vulnerability scanning\n    osv_client: Arc<OsvClient>,\n    vuln_cache: Arc<VulnerabilityCache>,\n}\n\nimpl DependiBackend {\n    /// Create a new DependiBackend with default configuration, parsers, registry clients,\n    /// caches, and an OSV client.\n    ///\n    /// The provided `client` is used for LSP communication. A shared HTTP client is created\n    /// internally and used to construct registry clients bound to that HTTP client.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // Obtain an LSP `Client` from the runtime environment and pass it in:\n    /// // let client = /* LSP client */ ;\n    /// // let backend = DependiBackend::new(client);\n    /// ```\n    pub fn new(client: Client) -> Self {\n        Self::with_http_client(client, None)\n    }\n\n    pub fn with_http_client(client: Client, http_client: Option<Arc<HttpClient>>) -> Self {\n        let http_client = http_client.unwrap_or_else(|| {\n            create_shared_client().expect(\"Failed to create shared HTTP client\")\n        });\n\n        Self {\n            client,\n            config: RwLock::new(Config::default()),\n            documents: DashMap::new(),\n            version_cache: Arc::new(HybridCache::new()),\n            cargo_parser: CargoParser::new(),\n            npm_parser: NpmParser::new(),\n            python_parser: PythonParser::new(),\n            go_parser: GoParser::new(),\n            php_parser: PhpParser::new(),\n            dart_parser: DartParser::new(),\n            csharp_parser: CsharpParser::new(),\n            ruby_parser: RubyParser::new(),\n            crates_io: Arc::new(CratesIoRegistry::with_client(Arc::clone(&http_client))),\n            npm_registry: Arc::new(NpmRegistry::with_client(Arc::clone(&http_client))),\n            pypi: Arc::new(PyPiRegistry::with_client(Arc::clone(&http_client))),\n            go_proxy: Arc::new(GoProxyRegistry::with_client(Arc::clone(&http_client))),\n            packagist: Arc::new(PackagistRegistry::with_client(Arc::clone(&http_client))),\n            pub_dev: Arc::new(PubDevRegistry::with_client(Arc::clone(&http_client))),\n            nuget: Arc::new(NuGetRegistry::with_client(Arc::clone(&http_client))),\n            rubygems: Arc::new(RubyGemsRegistry::with_client(http_client)),\n            osv_client: Arc::new(OsvClient::default()),\n            vuln_cache: Arc::new(VulnerabilityCache::new()),\n        }\n    }\n\n    fn parse_document(&self, uri: &Url, content: &str) -> Vec<crate::parsers::Dependency> {\n        match FileType::detect(uri) {\n            Some(FileType::Cargo) => self.cargo_parser.parse(content),\n            Some(FileType::Npm) => self.npm_parser.parse(content),\n            Some(FileType::Python) => self.python_parser.parse(content),\n            Some(FileType::Go) => self.go_parser.parse(content),\n            Some(FileType::Php) => self.php_parser.parse(content),\n            Some(FileType::Dart) => self.dart_parser.parse(content),\n            Some(FileType::Csharp) => self.csharp_parser.parse(content),\n            Some(FileType::Ruby) => self.ruby_parser.parse(content),\n            None => vec![],\n        }\n    }\n\n    async fn get_version_info(\n        &self,\n        file_type: FileType,\n        package_name: &str,\n    ) -> Option<VersionInfo> {\n        let cache_key = file_type.cache_key(package_name);\n\n        // Check cache first\n        if let Some(cached) = self.version_cache.get(&cache_key) {\n            return Some(cached);\n        }\n\n        // Fetch from appropriate registry\n        let result = match file_type {\n            FileType::Cargo => self.crates_io.get_version_info(package_name).await,\n            FileType::Npm => self.npm_registry.get_version_info(package_name).await,\n            FileType::Python => self.pypi.get_version_info(package_name).await,\n            FileType::Go => self.go_proxy.get_version_info(package_name).await,\n            FileType::Php => self.packagist.get_version_info(package_name).await,\n            FileType::Dart => self.pub_dev.get_version_info(package_name).await,\n            FileType::Csharp => self.nuget.get_version_info(package_name).await,\n            FileType::Ruby => self.rubygems.get_version_info(package_name).await,\n        };\n\n        match result {\n            Ok(info) => {\n                self.version_cache.insert(cache_key, info.clone());\n                Some(info)\n            }\n            Err(e) => {\n                tracing::warn!(\"Failed to fetch version info for {}: {}\", package_name, e);\n                None\n            }\n        }\n    }\n\n    async fn fetch_vulnerabilities_background(\n        dependencies: Vec<crate::parsers::Dependency>,\n        file_type: FileType,\n        cache: Arc<HybridCache>,\n        osv_client: Arc<OsvClient>,\n        vuln_cache: Arc<VulnerabilityCache>,\n        client: Client,\n    ) {\n        use crate::vulnerabilities::cache::VulnCacheKey;\n\n        let ecosystem = file_type.to_ecosystem();\n\n        // Build queries for packages not in vulnerability cache\n        let queries: Vec<VulnerabilityQuery> = dependencies\n            .iter()\n            .filter(|dep| {\n                let vuln_key = VulnCacheKey::new(ecosystem, &dep.name, &dep.version);\n                !vuln_cache.contains(&vuln_key)\n            })\n            .map(|dep| VulnerabilityQuery {\n                ecosystem,\n                package_name: dep.name.clone(),\n                version: dep.version.clone(),\n            })\n            .collect();\n\n        if queries.is_empty() {\n            tracing::debug!(\"Background: All vulnerability info cached, skipping OSV query\");\n            return;\n        }\n\n        tracing::info!(\n            \"Background: Querying OSV.dev for {} packages\",\n            queries.len()\n        );\n\n        // Batch query OSV.dev\n        match osv_client.query_batch(&queries).await {\n            Ok(results) => {\n                let mut updated_count = 0;\n\n                // Update vulnerability cache and version_cache with results\n                for (query, result) in queries.iter().zip(results.iter()) {\n                    // Mark this package as queried in vuln_cache\n                    let vuln_key =\n                        VulnCacheKey::new(ecosystem, &query.package_name, &query.version);\n                    vuln_cache.insert(vuln_key);\n\n                    // Store vulnerabilities and deprecated status in version_cache\n                    let cache_key = file_type.cache_key(&query.package_name);\n                    if let Some(mut info) = cache.get(&cache_key) {\n                        info.vulnerabilities = result.vulnerabilities.clone();\n                        info.deprecated = result.deprecated;\n                        if result.deprecated {\n                            tracing::info!(\n                                \"Background: Package {} {} is deprecated (unmaintained)\",\n                                query.package_name,\n                                query.version\n                            );\n                        }\n                        tracing::debug!(\n                            \"Background: Updated {} {} with {} vulnerabilities, deprecated={}\",\n                            query.package_name,\n                            query.version,\n                            result.vulnerabilities.len(),\n                            result.deprecated\n                        );\n                        cache.insert(cache_key, info);\n                        updated_count += 1;\n                    } else {\n                        tracing::warn!(\n                            \"Background: Could not update vulnerabilities for {}: not found in version cache\",\n                            query.package_name\n                        );\n                    }\n                }\n                tracing::info!(\n                    \"Background: Cached vulnerability info for {} packages\",\n                    updated_count\n                );\n\n                // Refresh UI with new vulnerability data\n                tracing::debug!(\"Background: Refreshing inlay hints after vulnerability check\");\n                client\n                    .send_request::<request::InlayHintRefreshRequest>(())\n                    .await\n                    .ok();\n                client\n                    .send_request::<request::WorkspaceDiagnosticRefresh>(())\n                    .await\n                    .ok();\n\n                tracing::info!(\"Background: Vulnerability check complete, UI updated\");\n            }\n            Err(e) => {\n                tracing::warn!(\n                    \"Background: Failed to fetch vulnerabilities from OSV.dev: {}\",\n                    e\n                );\n            }\n        }\n    }\n\n    async fn process_document(&self, uri: &Url, content: &str) {\n        let Some(file_type) = FileType::detect(uri) else {\n            return;\n        };\n\n        let dependencies = self.parse_document(uri, content);\n\n        tracing::info!(\n            \"Parsed {} dependencies from {}\",\n            dependencies.len(),\n            uri.path()\n        );\n\n        // Clone Arc references for async tasks\n        let crates_io = Arc::clone(&self.crates_io);\n        let npm_registry = Arc::clone(&self.npm_registry);\n        let pypi = Arc::clone(&self.pypi);\n        let go_proxy = Arc::clone(&self.go_proxy);\n        let packagist = Arc::clone(&self.packagist);\n        let pub_dev = Arc::clone(&self.pub_dev);\n        let nuget = Arc::clone(&self.nuget);\n        let rubygems = Arc::clone(&self.rubygems);\n        let cache = Arc::clone(&self.version_cache);\n\n        let fetch_tasks: Vec<_> = dependencies\n            .iter()\n            .map(|dep| {\n                let name = dep.name.clone();\n                let cache_key = file_type.cache_key(&name);\n                let crates_io = Arc::clone(&crates_io);\n                let npm_registry = Arc::clone(&npm_registry);\n                let pypi = Arc::clone(&pypi);\n                let go_proxy = Arc::clone(&go_proxy);\n                let packagist = Arc::clone(&packagist);\n                let pub_dev = Arc::clone(&pub_dev);\n                let nuget = Arc::clone(&nuget);\n                let rubygems = Arc::clone(&rubygems);\n                let cache = Arc::clone(&cache);\n                async move {\n                    // Check cache first\n                    if cache.get(&cache_key).is_some() {\n                        return;\n                    }\n                    // Fetch from appropriate registry\n                    let result = match file_type {\n                        FileType::Cargo => crates_io.get_version_info(&name).await,\n                        FileType::Npm => npm_registry.get_version_info(&name).await,\n                        FileType::Python => pypi.get_version_info(&name).await,\n                        FileType::Go => go_proxy.get_version_info(&name).await,\n                        FileType::Php => packagist.get_version_info(&name).await,\n                        FileType::Dart => pub_dev.get_version_info(&name).await,\n                        FileType::Csharp => nuget.get_version_info(&name).await,\n                        FileType::Ruby => rubygems.get_version_info(&name).await,\n                    };\n                    if let Ok(info) = result {\n                        cache.insert(cache_key, info);\n                    }\n                }\n            })\n            .collect();\n\n        // Run up to 5 concurrent requests\n        let semaphore = Arc::new(tokio::sync::Semaphore::new(5));\n        let handles: Vec<_> = fetch_tasks\n            .into_iter()\n            .map(|task| {\n                let permit = Arc::clone(&semaphore);\n                tokio::spawn(async move {\n                    let _permit = permit.acquire().await;\n                    task.await\n                })\n            })\n            .collect();\n\n        // Wait for all tasks to complete\n        for handle in handles {\n            let _ = handle.await;\n        }\n\n        // Store document state IMMEDIATELY (before vulnerability check)\n        self.documents.insert(\n            uri.clone(),\n            DocumentState {\n                dependencies: dependencies.clone(),\n                file_type,\n            },\n        );\n\n        // Publish diagnostics IMMEDIATELY (versions are available, vulnerabilities will update later)\n        let (diagnostics_enabled, security_show_diags, min_severity, security_enabled) = self\n            .config\n            .read()\n            .map(|c| {\n                (\n                    c.diagnostics.enabled,\n                    c.security.show_diagnostics,\n                    if c.security.show_diagnostics {\n                        Some(c.security.min_severity_level())\n                    } else {\n                        None\n                    },\n                    c.security.enabled,\n                )\n            })\n            .unwrap_or((true, true, None, true));\n\n        if diagnostics_enabled {\n            let severity_filter = if security_show_diags {\n                min_severity\n            } else {\n                None\n            };\n            let diagnostics = create_diagnostics(\n                &dependencies,\n                &self.version_cache,\n                |name| file_type.cache_key(name),\n                severity_filter,\n            );\n\n            self.client\n                .publish_diagnostics(uri.clone(), diagnostics, None)\n                .await;\n        }\n\n        // Refresh inlay hints IMMEDIATELY (versions are available)\n        self.client\n            .send_request::<request::InlayHintRefreshRequest>(())\n            .await\n            .ok();\n\n        // Fetch vulnerabilities from OSV.dev in BACKGROUND (non-blocking)\n        if security_enabled && !dependencies.is_empty() {\n            let dependencies_clone = dependencies.clone();\n            let cache_clone = Arc::clone(&self.version_cache);\n            let osv_client_clone = Arc::clone(&self.osv_client);\n            let vuln_cache_clone = Arc::clone(&self.vuln_cache);\n            let client_clone = self.client.clone();\n\n            tokio::spawn(async move {\n                Self::fetch_vulnerabilities_background(\n                    dependencies_clone,\n                    file_type,\n                    cache_clone,\n                    osv_client_clone,\n                    vuln_cache_clone,\n                    client_clone,\n                )\n                .await;\n            });\n        }\n    }\n\n    /// Generate a vulnerability report for a document\n    async fn generate_vulnerability_report(\n        &self,\n        arguments: &[serde_json::Value],\n    ) -> serde_json::Value {\n        // Parse arguments\n        let format = arguments\n            .first()\n            .and_then(|v| v.get(\"format\"))\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"json\");\n\n        let uri_str = arguments\n            .first()\n            .and_then(|v| v.get(\"uri\"))\n            .and_then(|v| v.as_str());\n\n        // Find the document\n        let (uri, doc_state) = if let Some(uri_str) = uri_str {\n            if let Ok(uri) = Url::parse(uri_str) {\n                if let Some(doc) = self.documents.get(&uri) {\n                    (uri.clone(), Some((doc.file_type, doc.dependencies.clone())))\n                } else {\n                    (uri, None)\n                }\n            } else {\n                return serde_json::json!({\n                    \"error\": \"Invalid URI format\"\n                });\n            }\n        } else {\n            // Use the first open document\n            if let Some(entry) = self.documents.iter().next() {\n                (\n                    entry.key().clone(),\n                    Some((entry.value().file_type, entry.value().dependencies.clone())),\n                )\n            } else {\n                return serde_json::json!({\n                    \"error\": \"No open documents\"\n                });\n            }\n        };\n\n        let Some((file_type, dependencies)) = doc_state else {\n            return serde_json::json!({\n                \"error\": \"Document not found or not yet processed\"\n            });\n        };\n\n        // Collect vulnerabilities from the version cache\n        let mut vulnerabilities: Vec<VulnerabilityReportEntry> = Vec::new();\n        let mut summary = VulnerabilitySummary::default();\n\n        for dep in &dependencies {\n            let cache_key = file_type.cache_key(&dep.name);\n            if let Some(info) = self.version_cache.get(&cache_key) {\n                for vuln in &info.vulnerabilities {\n                    summary.total += 1;\n                    match vuln.severity {\n                        VulnerabilitySeverity::Critical => summary.critical += 1,\n                        VulnerabilitySeverity::High => summary.high += 1,\n                        VulnerabilitySeverity::Medium => summary.medium += 1,\n                        VulnerabilitySeverity::Low => summary.low += 1,\n                    }\n\n                    vulnerabilities.push(VulnerabilityReportEntry {\n                        package: dep.name.clone(),\n                        version: dep.version.clone(),\n                        id: vuln.id.clone(),\n                        severity: format!(\"{:?}\", vuln.severity).to_lowercase(),\n                        description: vuln.description.clone(),\n                        url: vuln.url.clone(),\n                    });\n                }\n            }\n        }\n\n        // Generate report based on format\n        match format {\n            \"markdown\" => {\n                let md = generate_markdown_report(&uri, &summary, &vulnerabilities);\n                serde_json::json!({\n                    \"format\": \"markdown\",\n                    \"content\": md\n                })\n            }\n            _ => {\n                // Default to JSON\n                serde_json::json!({\n                    \"summary\": summary,\n                    \"vulnerabilities\": vulnerabilities,\n                    \"file\": uri.to_string()\n                })\n            }\n        }\n    }\n}\n\n#[tower_lsp::async_trait]\nimpl LanguageServer for DependiBackend {\n    async fn initialize(&self, params: InitializeParams) -> Result<InitializeResult> {\n        // Parse configuration from initialization options\n        let config = Config::from_init_options(params.initialization_options);\n        tracing::info!(\"Configuration: {:?}\", config);\n\n        // Store the configuration\n        if let Ok(mut cfg) = self.config.write() {\n            *cfg = config;\n        }\n\n        Ok(InitializeResult {\n            server_info: Some(ServerInfo {\n                name: \"dependi-lsp\".to_string(),\n                version: Some(env!(\"CARGO_PKG_VERSION\").to_string()),\n            }),\n            capabilities: ServerCapabilities {\n                text_document_sync: Some(TextDocumentSyncCapability::Kind(\n                    TextDocumentSyncKind::FULL,\n                )),\n                inlay_hint_provider: Some(OneOf::Left(true)),\n                hover_provider: Some(HoverProviderCapability::Simple(true)),\n                code_action_provider: Some(CodeActionProviderCapability::Simple(true)),\n                completion_provider: Some(CompletionOptions {\n                    trigger_characters: Some(vec![\"\\\"\".to_string(), \"=\".to_string()]),\n                    ..Default::default()\n                }),\n                execute_command_provider: Some(ExecuteCommandOptions {\n                    commands: vec![\"dependi/generateReport\".to_string()],\n                    ..Default::default()\n                }),\n                ..Default::default()\n            },\n        })\n    }\n\n    async fn initialized(&self, _: InitializedParams) {\n        self.client\n            .log_message(MessageType::INFO, \"Dependi LSP initialized\")\n            .await;\n\n        // Verify all registries share the same HTTP client\n        let base_client = self.crates_io.http_client();\n        debug_assert!(Arc::ptr_eq(&base_client, &self.npm_registry.http_client()));\n        debug_assert!(Arc::ptr_eq(&base_client, &self.pypi.http_client()));\n        debug_assert!(Arc::ptr_eq(&base_client, &self.go_proxy.http_client()));\n        debug_assert!(Arc::ptr_eq(&base_client, &self.packagist.http_client()));\n        debug_assert!(Arc::ptr_eq(&base_client, &self.pub_dev.http_client()));\n        debug_assert!(Arc::ptr_eq(&base_client, &self.nuget.http_client()));\n        debug_assert!(Arc::ptr_eq(&base_client, &self.rubygems.http_client()));\n\n        tracing::info!(\"Dependi LSP initialized\");\n    }\n\n    async fn shutdown(&self) -> Result<()> {\n        tracing::info!(\"Dependi LSP shutting down\");\n        Ok(())\n    }\n\n    async fn did_open(&self, params: DidOpenTextDocumentParams) {\n        let uri = params.text_document.uri;\n        let content = params.text_document.text;\n\n        tracing::debug!(\"Document opened: {}\", uri);\n        self.process_document(&uri, &content).await;\n    }\n\n    async fn did_change(&self, params: DidChangeTextDocumentParams) {\n        let uri = params.text_document.uri;\n\n        // With FULL sync, we get the entire document content\n        if let Some(change) = params.content_changes.into_iter().next() {\n            tracing::debug!(\"Document changed: {}\", uri);\n            self.process_document(&uri, &change.text).await;\n        }\n    }\n\n    async fn did_save(&self, params: DidSaveTextDocumentParams) {\n        let uri = params.text_document.uri;\n\n        // Re-process on save if we have the text\n        if let Some(text) = params.text {\n            tracing::debug!(\"Document saved: {}\", uri);\n            self.process_document(&uri, &text).await;\n        }\n    }\n\n    async fn did_close(&self, params: DidCloseTextDocumentParams) {\n        let uri = params.text_document.uri;\n        tracing::debug!(\"Document closed: {}\", uri);\n        self.documents.remove(&uri);\n\n        // Clear diagnostics for this document\n        self.client.publish_diagnostics(uri, vec![], None).await;\n    }\n\n    async fn inlay_hint(&self, params: InlayHintParams) -> Result<Option<Vec<InlayHint>>> {\n        // Check if inlay hints are enabled\n        let config = self.config.read().unwrap();\n        if !config.inlay_hints.enabled {\n            return Ok(Some(vec![]));\n        }\n        let show_up_to_date = config.inlay_hints.show_up_to_date;\n        let ignored_packages = config.ignore.clone();\n        drop(config);\n\n        let uri = &params.text_document.uri;\n\n        let Some(doc) = self.documents.get(uri) else {\n            return Ok(Some(vec![]));\n        };\n\n        let file_type = doc.file_type;\n        let hints: Vec<InlayHint> = doc\n            .dependencies\n            .iter()\n            .filter(|dep| {\n                // Only show hints for dependencies in the visible range\n                let line = dep.line;\n                line >= params.range.start.line && line <= params.range.end.line\n            })\n            .filter(|dep| {\n                // Skip ignored packages\n                !ignored_packages.iter().any(|pattern| {\n                    if pattern.contains('*') {\n                        let parts: Vec<&str> = pattern.split('*').collect();\n                        if parts.len() == 2 {\n                            dep.name.starts_with(parts[0]) && dep.name.ends_with(parts[1])\n                        } else {\n                            dep.name.starts_with(parts[0])\n                        }\n                    } else {\n                        dep.name == *pattern\n                    }\n                })\n            })\n            .filter_map(|dep| {\n                let cache_key = file_type.cache_key(&dep.name);\n                let version_info = self.version_cache.get(&cache_key);\n                let hint = create_inlay_hint(dep, version_info.as_ref());\n\n                // Optionally filter out up-to-date hints\n                if !show_up_to_date {\n                    let label_text = match &hint.label {\n                        InlayHintLabel::String(s) => s.clone(),\n                        InlayHintLabel::LabelParts(parts) => {\n                            parts.iter().map(|p| p.value.as_str()).collect()\n                        }\n                    };\n                    if label_text.contains(\"[OK]\") {\n                        return None;\n                    }\n                }\n                Some(hint)\n            })\n            .collect();\n\n        tracing::debug!(\"Returning {} inlay hints for {}\", hints.len(), uri);\n        Ok(Some(hints))\n    }\n\n    async fn hover(&self, params: HoverParams) -> Result<Option<Hover>> {\n        let uri = &params.text_document_position_params.text_document.uri;\n        let position = params.text_document_position_params.position;\n\n        let Some(doc) = self.documents.get(uri) else {\n            return Ok(None);\n        };\n\n        let file_type = doc.file_type;\n\n        // Find dependency at this position\n        let dep = doc.dependencies.iter().find(|d| {\n            d.line == position.line\n                && position.character >= d.name_start\n                && position.character <= d.version_end\n        });\n\n        let Some(dep) = dep.cloned() else {\n            return Ok(None);\n        };\n\n        // Drop the lock before async call\n        drop(doc);\n\n        // Get version info\n        let version_info = self.get_version_info(file_type, &dep.name).await;\n\n        let content = match version_info {\n            Some(info) => {\n                let mut parts = vec![format!(\"## {}\\n\", dep.name)];\n\n                if let Some(desc) = &info.description {\n                    parts.push(format!(\"{}\\n\", desc));\n                }\n\n                // Current version with release date\n                let current_date_str = info\n                    .get_release_date(&dep.version)\n                    .map(|dt| format!(\" ({})\", format_release_age(dt)))\n                    .unwrap_or_default();\n                parts.push(format!(\"**Current:** {}{}\", dep.version, current_date_str));\n\n                if let Some(latest) = &info.latest {\n                    let latest_date_str = info\n                        .get_release_date(latest)\n                        .map(|dt| format!(\" ({})\", format_release_age(dt)))\n                        .unwrap_or_default();\n                    parts.push(format!(\"**Latest:** {}{}\", latest, latest_date_str));\n                }\n\n                if let Some(license) = &info.license {\n                    parts.push(format!(\"**License:** {}\", license));\n                }\n\n                if let Some(repo) = &info.repository {\n                    parts.push(format!(\"\\n[Repository]({})\", repo));\n                }\n\n                if let Some(homepage) = &info.homepage {\n                    parts.push(format!(\"[Homepage]({})\", homepage));\n                }\n\n                // Add vulnerability information if present\n                if !info.vulnerabilities.is_empty() {\n                    parts.push(format!(\n                        \"\\n### ⚠ {} Security {}\",\n                        info.vulnerabilities.len(),\n                        if info.vulnerabilities.len() == 1 {\n                            \"Vulnerability\"\n                        } else {\n                            \"Vulnerabilities\"\n                        }\n                    ));\n\n                    for vuln in &info.vulnerabilities {\n                        let severity_icon = match vuln.severity {\n                            VulnerabilitySeverity::Critical => \"⚠\",\n                            VulnerabilitySeverity::High => \"▲\",\n                            VulnerabilitySeverity::Medium => \"●\",\n                            VulnerabilitySeverity::Low => \"○\",\n                        };\n                        let severity_str = match vuln.severity {\n                            VulnerabilitySeverity::Critical => \"CRITICAL\",\n                            VulnerabilitySeverity::High => \"HIGH\",\n                            VulnerabilitySeverity::Medium => \"MEDIUM\",\n                            VulnerabilitySeverity::Low => \"LOW\",\n                        };\n\n                        if let Some(url) = &vuln.url {\n                            parts.push(format!(\n                                \"\\n#### [{}]({}) - {} {}\",\n                                vuln.id, url, severity_icon, severity_str\n                            ));\n                        } else {\n                            parts.push(format!(\n                                \"\\n#### {} - {} {}\",\n                                vuln.id, severity_icon, severity_str\n                            ));\n                        }\n                        parts.push(vuln.description.clone());\n                    }\n                }\n\n                parts.join(\"\\n\")\n            }\n            None => format!(\"## {}\\n\\nCould not fetch package information.\", dep.name),\n        };\n\n        Ok(Some(Hover {\n            contents: HoverContents::Markup(MarkupContent {\n                kind: MarkupKind::Markdown,\n                value: content,\n            }),\n            range: Some(Range {\n                start: Position {\n                    line: dep.line,\n                    character: dep.name_start,\n                },\n                end: Position {\n                    line: dep.line,\n                    character: dep.version_end,\n                },\n            }),\n        }))\n    }\n\n    async fn code_action(&self, params: CodeActionParams) -> Result<Option<CodeActionResponse>> {\n        let uri = &params.text_document.uri;\n\n        let Some(doc) = self.documents.get(uri) else {\n            return Ok(Some(vec![]));\n        };\n\n        let file_type = doc.file_type;\n        let actions = create_code_actions(\n            &doc.dependencies,\n            &self.version_cache,\n            uri,\n            params.range,\n            file_type,\n            |name| file_type.cache_key(name),\n        );\n\n        Ok(Some(actions))\n    }\n\n    async fn completion(&self, params: CompletionParams) -> Result<Option<CompletionResponse>> {\n        let uri = &params.text_document_position.text_document.uri;\n        let position = params.text_document_position.position;\n\n        let Some(doc) = self.documents.get(uri) else {\n            return Ok(Some(CompletionResponse::Array(vec![])));\n        };\n\n        let file_type = doc.file_type;\n        let completions =\n            get_completions(&doc.dependencies, position, &self.version_cache, |name| {\n                file_type.cache_key(name)\n            });\n\n        match completions {\n            Some(items) => Ok(Some(CompletionResponse::Array(items))),\n            None => Ok(Some(CompletionResponse::Array(vec![]))),\n        }\n    }\n\n    async fn execute_command(\n        &self,\n        params: ExecuteCommandParams,\n    ) -> Result<Option<serde_json::Value>> {\n        match params.command.as_str() {\n            \"dependi/generateReport\" => {\n                let report = self.generate_vulnerability_report(&params.arguments).await;\n                Ok(Some(report))\n            }\n            _ => {\n                tracing::warn!(\"Unknown command: {}\", params.command);\n                Ok(None)\n            }\n        }\n    }\n}\n","traces":[{"line":86,"address":[14433952],"length":1,"stats":{"Line":0}},{"line":87,"address":[13104545],"length":1,"stats":{"Line":0}},{"line":90,"address":[13102528,13104286,13104324],"length":1,"stats":{"Line":0}},{"line":91,"address":[17181721,17181626],"length":1,"stats":{"Line":0}},{"line":92,"address":[13729457],"length":1,"stats":{"Line":0}},{"line":97,"address":[17181769,17181836],"length":1,"stats":{"Line":0}},{"line":98,"address":[14432011],"length":1,"stats":{"Line":0}},{"line":99,"address":[17181903,17181955],"length":1,"stats":{"Line":0}},{"line":100,"address":[13102946],"length":1,"stats":{"Line":0}},{"line":101,"address":[17182030],"length":1,"stats":{"Line":0}},{"line":102,"address":[14432237],"length":1,"stats":{"Line":0}},{"line":103,"address":[17182044],"length":1,"stats":{"Line":0}},{"line":104,"address":[14450547],"length":1,"stats":{"Line":0}},{"line":105,"address":[17182058],"length":1,"stats":{"Line":0}},{"line":106,"address":[13103025],"length":1,"stats":{"Line":0}},{"line":107,"address":[14432292],"length":1,"stats":{"Line":0}},{"line":108,"address":[14450591],"length":1,"stats":{"Line":0}},{"line":109,"address":[14432473,14432400],"length":1,"stats":{"Line":0}},{"line":110,"address":[14432529,14432602],"length":1,"stats":{"Line":0}},{"line":111,"address":[14432658,14432731],"length":1,"stats":{"Line":0}},{"line":112,"address":[14432787,14432860],"length":1,"stats":{"Line":0}},{"line":113,"address":[17182677,17182615],"length":1,"stats":{"Line":0}},{"line":114,"address":[17182725,17182787],"length":1,"stats":{"Line":0}},{"line":115,"address":[13103866,13103787],"length":1,"stats":{"Line":0}},{"line":116,"address":[13103899,13103951],"length":1,"stats":{"Line":0}},{"line":117,"address":[14433447,14433387],"length":1,"stats":{"Line":0}},{"line":121,"address":[14431168],"length":1,"stats":{"Line":0}},{"line":122,"address":[17181070,17181154],"length":1,"stats":{"Line":0}},{"line":123,"address":[13102136],"length":1,"stats":{"Line":0}},{"line":124,"address":[17181210],"length":1,"stats":{"Line":0}},{"line":125,"address":[14431408],"length":1,"stats":{"Line":0}},{"line":126,"address":[14449731],"length":1,"stats":{"Line":0}},{"line":127,"address":[14449769],"length":1,"stats":{"Line":0}},{"line":128,"address":[14449807],"length":1,"stats":{"Line":0}},{"line":129,"address":[14431557],"length":1,"stats":{"Line":0}},{"line":130,"address":[14431595],"length":1,"stats":{"Line":0}},{"line":131,"address":[13102099],"length":1,"stats":{"Line":0}},{"line":135,"address":[14431616],"length":1,"stats":{"Line":0}},{"line":140,"address":[18586092,18586365],"length":1,"stats":{"Line":0}},{"line":143,"address":[14236274,14236165],"length":1,"stats":{"Line":0}},{"line":144,"address":[14254704],"length":1,"stats":{"Line":0}},{"line":148,"address":[18586648],"length":1,"stats":{"Line":0}},{"line":149,"address":[14236557,14236869,14235942,14237951],"length":1,"stats":{"Line":0}},{"line":150,"address":[18586167,18586791,18587158,18588343],"length":1,"stats":{"Line":0}},{"line":151,"address":[12463559],"length":1,"stats":{"Line":0}},{"line":152,"address":[12463578],"length":1,"stats":{"Line":0}},{"line":153,"address":[14255689,14254997,14257420,14254314],"length":1,"stats":{"Line":0}},{"line":154,"address":[14237534,14236047,14236747,14239415],"length":1,"stats":{"Line":0}},{"line":155,"address":[14254356,14255073,14255955,14257980],"length":1,"stats":{"Line":0}},{"line":156,"address":[12771362],"length":1,"stats":{"Line":0}},{"line":159,"address":[14256511],"length":1,"stats":{"Line":0}},{"line":160,"address":[14258579],"length":1,"stats":{"Line":0}},{"line":161,"address":[18590346,18590282,18590506,18590532],"length":1,"stats":{"Line":0}},{"line":162,"address":[14258747],"length":1,"stats":{"Line":0}},{"line":164,"address":[14258502],"length":1,"stats":{"Line":0}},{"line":165,"address":[14240230,14240894,14240631],"length":1,"stats":{"Line":0}},{"line":166,"address":[13713728],"length":1,"stats":{"Line":0}},{"line":171,"address":[13104416],"length":1,"stats":{"Line":0}},{"line":181,"address":[14266436,14266234],"length":1,"stats":{"Line":0}},{"line":184,"address":[14266438,14266619],"length":1,"stats":{"Line":0}},{"line":186,"address":[14294752,14284824,14294990,14294984],"length":1,"stats":{"Line":0}},{"line":187,"address":[13747582],"length":1,"stats":{"Line":0}},{"line":188,"address":[13747662,13747722],"length":1,"stats":{"Line":0}},{"line":190,"address":[14266577,14276324,14276192,14276385,14276391],"length":1,"stats":{"Line":0}},{"line":191,"address":[18625316],"length":1,"stats":{"Line":0}},{"line":192,"address":[13747933],"length":1,"stats":{"Line":0}},{"line":193,"address":[13747962],"length":1,"stats":{"Line":0}},{"line":197,"address":[18615442,18615511],"length":1,"stats":{"Line":0}},{"line":198,"address":[14285881,14286172,14285049],"length":1,"stats":{"Line":0}},{"line":202,"address":[18615931],"length":1,"stats":{"Line":0}},{"line":208,"address":[12470203],"length":1,"stats":{"Line":0}},{"line":209,"address":[18617559],"length":1,"stats":{"Line":0}},{"line":210,"address":[18617587],"length":1,"stats":{"Line":0}},{"line":213,"address":[13740493,13740583,13745689],"length":1,"stats":{"Line":0}},{"line":215,"address":[14270713,14269393],"length":1,"stats":{"Line":0}},{"line":217,"address":[14289105,14289177],"length":1,"stats":{"Line":0}},{"line":220,"address":[13742544,13742638],"length":1,"stats":{"Line":0}},{"line":221,"address":[18621901,18619892,18619776],"length":1,"stats":{"Line":0}},{"line":222,"address":[14289744,14289634,14289725],"length":1,"stats":{"Line":0}},{"line":223,"address":[13743132],"length":1,"stats":{"Line":0}},{"line":224,"address":[13743145],"length":1,"stats":{"Line":0}},{"line":225,"address":[18620286],"length":1,"stats":{"Line":0}},{"line":231,"address":[14272775],"length":1,"stats":{"Line":0}},{"line":238,"address":[14290846],"length":1,"stats":{"Line":0}},{"line":239,"address":[14291571,14291512],"length":1,"stats":{"Line":0}},{"line":241,"address":[18620005,18622266],"length":1,"stats":{"Line":0}},{"line":247,"address":[14269763,14269432],"length":1,"stats":{"Line":0}},{"line":253,"address":[14269732,14270039,14270338],"length":1,"stats":{"Line":0}},{"line":254,"address":[14288864,14293275,14288600],"length":1,"stats":{"Line":0}},{"line":255,"address":[13741880],"length":1,"stats":{"Line":0}},{"line":256,"address":[12470225],"length":1,"stats":{"Line":0}},{"line":258,"address":[14275170,14275385,14275112],"length":1,"stats":{"Line":0}},{"line":259,"address":[14275116],"length":1,"stats":{"Line":0}},{"line":260,"address":[18624053,18623791,18615164,18623822,18623723],"length":1,"stats":{"Line":0}},{"line":263,"address":[13747259,13746982],"length":1,"stats":{"Line":0}},{"line":265,"address":[18617505],"length":1,"stats":{"Line":0}},{"line":266,"address":[14274549,14268816,14274304],"length":1,"stats":{"Line":0}},{"line":274,"address":[18594265,18591501,18591280,18595725,18591316,18591565,18591594,18591544],"length":1,"stats":{"Line":0}},{"line":275,"address":[14259816,14259983],"length":1,"stats":{"Line":0}},{"line":279,"address":[18591714],"length":1,"stats":{"Line":0}},{"line":281,"address":[18592224],"length":1,"stats":{"Line":0}},{"line":288,"address":[14242655,14242150],"length":1,"stats":{"Line":0}},{"line":289,"address":[13715482,13715585],"length":1,"stats":{"Line":0}},{"line":290,"address":[14261060,14261171],"length":1,"stats":{"Line":0}},{"line":291,"address":[13715791,13715691],"length":1,"stats":{"Line":0}},{"line":292,"address":[14243000,14243111],"length":1,"stats":{"Line":0}},{"line":293,"address":[14243114,14243225],"length":1,"stats":{"Line":0}},{"line":294,"address":[14261516,14261627],"length":1,"stats":{"Line":0}},{"line":295,"address":[14243453,14243342],"length":1,"stats":{"Line":0}},{"line":296,"address":[14243567,14243456],"length":1,"stats":{"Line":0}},{"line":298,"address":[14261858],"length":1,"stats":{"Line":0}},{"line":300,"address":[13720288,13716447,13721340,13721334],"length":1,"stats":{"Line":0}},{"line":301,"address":[18597779],"length":1,"stats":{"Line":0}},{"line":302,"address":[18597811,18597907],"length":1,"stats":{"Line":0}},{"line":303,"address":[14248072,14247998],"length":1,"stats":{"Line":0}},{"line":304,"address":[14248080,14248151],"length":1,"stats":{"Line":0}},{"line":305,"address":[14248230,14248159],"length":1,"stats":{"Line":0}},{"line":306,"address":[14248309,14248238],"length":1,"stats":{"Line":0}},{"line":307,"address":[14266676,14266605],"length":1,"stats":{"Line":0}},{"line":308,"address":[13720849,13720912],"length":1,"stats":{"Line":0}},{"line":309,"address":[14248475,14248546],"length":1,"stats":{"Line":0}},{"line":310,"address":[14266842,14266913],"length":1,"stats":{"Line":0}},{"line":311,"address":[14248633,14248714],"length":1,"stats":{"Line":0}},{"line":312,"address":[13723795,13726203,13726279,13721143,13723669,13723690,13723531,13723711,13723753,13723440,13723732,13723774,13723626],"length":1,"stats":{"Line":0}},{"line":314,"address":[14268521,14268832],"length":1,"stats":{"Line":0}},{"line":318,"address":[14250695],"length":1,"stats":{"Line":0}},{"line":319,"address":[18602463,18600440,18600200,18599800],"length":1,"stats":{"Line":0}},{"line":320,"address":[18600600,18600230,18602765,18599821],"length":1,"stats":{"Line":0}},{"line":321,"address":[14250354,14253783,14250807,14251355],"length":1,"stats":{"Line":0}},{"line":322,"address":[18603283,18599863,18600290,18600920],"length":1,"stats":{"Line":0}},{"line":323,"address":[18599884,18601080,18600320,18603524],"length":1,"stats":{"Line":0}},{"line":324,"address":[14250909,14254560,14251871,14250417],"length":1,"stats":{"Line":0}},{"line":325,"address":[14254813,14250438,14250943,14252043],"length":1,"stats":{"Line":0}},{"line":326,"address":[14250977,14250459,14252215,14255066],"length":1,"stats":{"Line":0}},{"line":328,"address":[14253458,14255478,14255311],"length":1,"stats":{"Line":0}},{"line":329,"address":[14273650],"length":1,"stats":{"Line":0}},{"line":336,"address":[18593762,18593849],"length":1,"stats":{"Line":0}},{"line":337,"address":[18593911],"length":1,"stats":{"Line":0}},{"line":339,"address":[14268371,14268342,14262505,14268144],"length":1,"stats":{"Line":0}},{"line":340,"address":[14268164,14268247],"length":1,"stats":{"Line":0}},{"line":341,"address":[13721471,13722480,13722582,13723338,13722777,13722505,13722619,13723140],"length":1,"stats":{"Line":0}},{"line":342,"address":[13722808,13722687,13722545,13722609],"length":1,"stats":{"Line":0}},{"line":343,"address":[12798048],"length":1,"stats":{"Line":0}},{"line":349,"address":[14263149,14262563,14262666],"length":1,"stats":{"Line":0}},{"line":350,"address":[14259871,14262825,14263205,14263103,14264296,14262791],"length":1,"stats":{"Line":0}},{"line":354,"address":[18594754,18594944,18594746],"length":1,"stats":{"Line":0}},{"line":355,"address":[13717717,13717667,13717646],"length":1,"stats":{"Line":0}},{"line":356,"address":[13717801],"length":1,"stats":{"Line":0}},{"line":357,"address":[14245053],"length":1,"stats":{"Line":0}},{"line":358,"address":[13717795],"length":1,"stats":{"Line":0}},{"line":363,"address":[14263627,14263683,14263538],"length":1,"stats":{"Line":0}},{"line":366,"address":[18597659,18595056,18597653,18597392],"length":1,"stats":{"Line":0}},{"line":368,"address":[14267246,14267307],"length":1,"stats":{"Line":0}},{"line":369,"address":[18597471],"length":1,"stats":{"Line":0}},{"line":370,"address":[14249168,14249059,14249096],"length":1,"stats":{"Line":0}},{"line":371,"address":[18597535,18597569],"length":1,"stats":{"Line":0}},{"line":373,"address":[14267379],"length":1,"stats":{"Line":0}},{"line":375,"address":[18597552,18597603],"length":1,"stats":{"Line":0}},{"line":378,"address":[14245307,14245360],"length":1,"stats":{"Line":0}},{"line":380,"address":[18595946,18595242],"length":1,"stats":{"Line":0}},{"line":381,"address":[13718194,13718180],"length":1,"stats":{"Line":0}},{"line":382,"address":[14263840],"length":1,"stats":{"Line":0}},{"line":384,"address":[18595290],"length":1,"stats":{"Line":0}},{"line":387,"address":[18595319],"length":1,"stats":{"Line":0}},{"line":388,"address":[13718296],"length":1,"stats":{"Line":0}},{"line":389,"address":[14249264,14245660,14249291],"length":1,"stats":{"Line":0}},{"line":393,"address":[18595454,18595651],"length":1,"stats":{"Line":0}},{"line":394,"address":[13718359,13718439],"length":1,"stats":{"Line":0}},{"line":395,"address":[14241604,14245944,14246028,14245876],"length":1,"stats":{"Line":0}},{"line":399,"address":[13718882,13718150,13719124],"length":1,"stats":{"Line":0}},{"line":400,"address":[14245506],"length":1,"stats":{"Line":0}},{"line":401,"address":[12721749],"length":1,"stats":{"Line":0}},{"line":405,"address":[14246625],"length":1,"stats":{"Line":0}},{"line":406,"address":[18596466,18596404],"length":1,"stats":{"Line":0}},{"line":407,"address":[14265046,14265129],"length":1,"stats":{"Line":0}},{"line":408,"address":[14265228,14265145],"length":1,"stats":{"Line":0}},{"line":409,"address":[18596743,18596664],"length":1,"stats":{"Line":0}},{"line":410,"address":[13719722,13719655],"length":1,"stats":{"Line":0}},{"line":412,"address":[18599027,18599134,18599333,18596834,18598988,18598873,18598848],"length":1,"stats":{"Line":0}},{"line":413,"address":[14267870,14267720],"length":1,"stats":{"Line":0}},{"line":414,"address":[18598913],"length":1,"stats":{"Line":0}},{"line":416,"address":[13722024],"length":1,"stats":{"Line":0}},{"line":417,"address":[18598940],"length":1,"stats":{"Line":0}},{"line":418,"address":[14267712],"length":1,"stats":{"Line":0}},{"line":419,"address":[14249428],"length":1,"stats":{"Line":0}},{"line":421,"address":[13722206,13722170,13722103,13722253],"length":1,"stats":{"Line":0}},{"line":427,"address":[13104368],"length":1,"stats":{"Line":0}},{"line":432,"address":[14258073],"length":1,"stats":{"Line":0}},{"line":434,"address":[14284313,14284304,14276220],"length":1,"stats":{"Line":0}},{"line":435,"address":[18614736,18614745,18606959],"length":1,"stats":{"Line":0}},{"line":438,"address":[18607192],"length":1,"stats":{"Line":0}},{"line":440,"address":[18614841,18614832,18607130],"length":1,"stats":{"Line":0}},{"line":441,"address":[13737737,13730049,13737728],"length":1,"stats":{"Line":0}},{"line":444,"address":[13731101,13731157,13730104],"length":1,"stats":{"Line":0}},{"line":445,"address":[18607379,18607316,18607279],"length":1,"stats":{"Line":0}},{"line":446,"address":[14258503,14258578],"length":1,"stats":{"Line":0}},{"line":447,"address":[14276945,14277146],"length":1,"stats":{"Line":0}},{"line":449,"address":[13730539],"length":1,"stats":{"Line":0}},{"line":452,"address":[13730257,13731339,13731301,13731404,13731784],"length":1,"stats":{"Line":0}},{"line":458,"address":[18607294,18608983,18608936],"length":1,"stats":{"Line":0}},{"line":460,"address":[14278499,14278390],"length":1,"stats":{"Line":0}},{"line":461,"address":[14260294,14260218],"length":1,"stats":{"Line":0}},{"line":464,"address":[14265490,14265445,14265559],"length":1,"stats":{"Line":0}},{"line":470,"address":[13731255,13732413],"length":1,"stats":{"Line":0}},{"line":471,"address":[14278981,14283270,14283232,14283339,14283634],"length":1,"stats":{"Line":0}},{"line":477,"address":[13732482],"length":1,"stats":{"Line":0}},{"line":478,"address":[13732555],"length":1,"stats":{"Line":0}},{"line":480,"address":[13732607],"length":1,"stats":{"Line":0}},{"line":481,"address":[14263229,14260968],"length":1,"stats":{"Line":0}},{"line":482,"address":[18612216,18612115],"length":1,"stats":{"Line":0}},{"line":483,"address":[14263438,14263543],"length":1,"stats":{"Line":0}},{"line":484,"address":[14282026,14281936,14281989],"length":1,"stats":{"Line":0}},{"line":485,"address":[14263708],"length":1,"stats":{"Line":0}},{"line":486,"address":[13735726,13735564],"length":1,"stats":{"Line":0}},{"line":487,"address":[18612796,18612642],"length":1,"stats":{"Line":0}},{"line":488,"address":[14282214,14282068],"length":1,"stats":{"Line":0}},{"line":489,"address":[14282153,14282046],"length":1,"stats":{"Line":0}},{"line":492,"address":[13736308],"length":1,"stats":{"Line":0}},{"line":493,"address":[13735635],"length":1,"stats":{"Line":0}},{"line":494,"address":[14264032],"length":1,"stats":{"Line":0}},{"line":495,"address":[18612940],"length":1,"stats":{"Line":0}},{"line":496,"address":[18613005,18613255,18613076],"length":1,"stats":{"Line":0}},{"line":497,"address":[18613279],"length":1,"stats":{"Line":0}},{"line":498,"address":[18613348],"length":1,"stats":{"Line":0}},{"line":506,"address":[14279298],"length":1,"stats":{"Line":0}},{"line":507,"address":[14280549,14279352],"length":1,"stats":{"Line":0}},{"line":508,"address":[18611326,18611261,18611172,18611223,18611557,18611624,18612012],"length":1,"stats":{"Line":0}},{"line":515,"address":[14279345,14279384,14279422,14279492,14279720,14279971,14280112,14279787,14280041,14280450],"length":1,"stats":{"Line":0}},{"line":518,"address":[18610622],"length":1,"stats":{"Line":0}},{"line":527,"address":[14286346,14281243,14286188,14280973,14281363,14286529,14286286,14280896,14282645,14281103,14286226,14281221,14286406,14286466,14281470,14287101],"length":1,"stats":{"Line":0}},{"line":529,"address":[18629958,18629741],"length":1,"stats":{"Line":0}},{"line":530,"address":[13752862,13753182,13752929],"length":1,"stats":{"Line":0}},{"line":533,"address":[14282129,14281817,14282092],"length":1,"stats":{"Line":0}},{"line":534,"address":[18630595,18631044,18630769,18631013,18630711],"length":1,"stats":{"Line":0}},{"line":537,"address":[14285743],"length":1,"stats":{"Line":0}},{"line":538,"address":[14282799],"length":1,"stats":{"Line":0}},{"line":539,"address":[13753878],"length":1,"stats":{"Line":0}},{"line":540,"address":[14282692,14282767],"length":1,"stats":{"Line":0}},{"line":542,"address":[14284331],"length":1,"stats":{"Line":0}},{"line":543,"address":[14301199],"length":1,"stats":{"Line":0}},{"line":546,"address":[13754243],"length":1,"stats":{"Line":0}},{"line":548,"address":[13754333],"length":1,"stats":{"Line":0}},{"line":549,"address":[14301914],"length":1,"stats":{"Line":0}},{"line":550,"address":[18631929,18631505,18631566,18635311],"length":1,"stats":{"Line":0}},{"line":551,"address":[14301863],"length":1,"stats":{"Line":0}},{"line":553,"address":[13755472],"length":1,"stats":{"Line":0}},{"line":554,"address":[14286728,14283806,14283867],"length":1,"stats":{"Line":0}},{"line":555,"address":[14284143],"length":1,"stats":{"Line":0}},{"line":557,"address":[18632674],"length":1,"stats":{"Line":0}},{"line":562,"address":[14434559],"length":1,"stats":{"Line":0}},{"line":563,"address":[18641701,18641543],"length":1,"stats":{"Line":0}},{"line":564,"address":[14311627],"length":1,"stats":{"Line":0}},{"line":565,"address":[12480377],"length":1,"stats":{"Line":0}},{"line":568,"address":[18641953],"length":1,"stats":{"Line":0}},{"line":569,"address":[14293847,14293926],"length":1,"stats":{"Line":0}},{"line":570,"address":[14312418],"length":1,"stats":{"Line":0}},{"line":571,"address":[14312658],"length":1,"stats":{"Line":0}},{"line":572,"address":[18642707],"length":1,"stats":{"Line":0}},{"line":573,"address":[13765819],"length":1,"stats":{"Line":0}},{"line":574,"address":[14313360],"length":1,"stats":{"Line":0}},{"line":575,"address":[14295294],"length":1,"stats":{"Line":0}},{"line":577,"address":[18643509,18643779],"length":1,"stats":{"Line":0}},{"line":580,"address":[13779502,13779550,13780091,13779431,13779899,13779328,13779509,13779366,13779595],"length":1,"stats":{"Line":0}},{"line":581,"address":[18657008,18656624,18656742],"length":1,"stats":{"Line":0}},{"line":582,"address":[18656965],"length":1,"stats":{"Line":0}},{"line":585,"address":[15231707,15231689,15231650],"length":1,"stats":{"Line":0}},{"line":586,"address":[13776613],"length":1,"stats":{"Line":0}},{"line":587,"address":[18653801],"length":1,"stats":{"Line":0}},{"line":589,"address":[14324245,14324365,14324634],"length":1,"stats":{"Line":0}},{"line":590,"address":[12478020],"length":1,"stats":{"Line":0}},{"line":593,"address":[13104671],"length":1,"stats":{"Line":0}},{"line":594,"address":[14279332],"length":1,"stats":{"Line":0}},{"line":597,"address":[14297861,14297939,14297710],"length":1,"stats":{"Line":0}},{"line":598,"address":[14298036,14298406,14298139],"length":1,"stats":{"Line":0}},{"line":599,"address":[13751455,13750898,13751765,13751903],"length":1,"stats":{"Line":0}},{"line":603,"address":[17185263],"length":1,"stats":{"Line":0}},{"line":604,"address":[18655163],"length":1,"stats":{"Line":0}},{"line":607,"address":[14325640,14325726],"length":1,"stats":{"Line":0}},{"line":608,"address":[13778574,13778305,13778202],"length":1,"stats":{"Line":0}},{"line":609,"address":[12785828],"length":1,"stats":{"Line":0}},{"line":613,"address":[13105615],"length":1,"stats":{"Line":0}},{"line":614,"address":[18657445],"length":1,"stats":{"Line":0}},{"line":615,"address":[18657903,18657533,18657644],"length":1,"stats":{"Line":0}},{"line":616,"address":[14328634,14328357],"length":1,"stats":{"Line":0}},{"line":619,"address":[12478996],"length":1,"stats":{"Line":0}},{"line":622,"address":[13761164,13758623,13758727,13758989,13760800,13758576,13760917,13758814,13758962,13761029,13761074,13760819,13761096],"length":1,"stats":{"Line":0}},{"line":624,"address":[14305948,14306045],"length":1,"stats":{"Line":0}},{"line":625,"address":[14306127,14306203],"length":1,"stats":{"Line":0}},{"line":626,"address":[14287921,14287964],"length":1,"stats":{"Line":0}},{"line":628,"address":[14288096,14287940],"length":1,"stats":{"Line":0}},{"line":629,"address":[13759374],"length":1,"stats":{"Line":0}},{"line":630,"address":[13759414],"length":1,"stats":{"Line":0}},{"line":632,"address":[14306541],"length":1,"stats":{"Line":0}},{"line":634,"address":[14288261],"length":1,"stats":{"Line":0}},{"line":635,"address":[14289727,14288379],"length":1,"stats":{"Line":0}},{"line":638,"address":[13759686,13759611],"length":1,"stats":{"Line":0}},{"line":639,"address":[18636808],"length":1,"stats":{"Line":0}},{"line":642,"address":[14306839,14309360],"length":1,"stats":{"Line":0}},{"line":644,"address":[14291087],"length":1,"stats":{"Line":0}},{"line":645,"address":[18639277],"length":1,"stats":{"Line":0}},{"line":647,"address":[14306874,14309280],"length":1,"stats":{"Line":0}},{"line":649,"address":[14291248,14291996,14292002,14291010],"length":1,"stats":{"Line":0}},{"line":650,"address":[14291306],"length":1,"stats":{"Line":0}},{"line":651,"address":[13762479],"length":1,"stats":{"Line":0}},{"line":652,"address":[18639798,18639710],"length":1,"stats":{"Line":0}},{"line":653,"address":[18640054,18639812,18639895],"length":1,"stats":{"Line":0}},{"line":655,"address":[13763010,13762694],"length":1,"stats":{"Line":0}},{"line":658,"address":[14309636],"length":1,"stats":{"Line":0}},{"line":662,"address":[18636957,18639202,18639224,18638320],"length":1,"stats":{"Line":0}},{"line":663,"address":[14290070],"length":1,"stats":{"Line":0}},{"line":664,"address":[14308550,14308443],"length":1,"stats":{"Line":0}},{"line":665,"address":[18638585,18638652],"length":1,"stats":{"Line":0}},{"line":668,"address":[13761643],"length":1,"stats":{"Line":0}},{"line":669,"address":[13761652],"length":1,"stats":{"Line":0}},{"line":670,"address":[13761865,13761786],"length":1,"stats":{"Line":0}},{"line":671,"address":[18638777],"length":1,"stats":{"Line":0}},{"line":672,"address":[13763145,13763120,13761769,13761902],"length":1,"stats":{"Line":0}},{"line":675,"address":[14290793,14290626],"length":1,"stats":{"Line":0}},{"line":676,"address":[14290857],"length":1,"stats":{"Line":0}},{"line":679,"address":[13761711],"length":1,"stats":{"Line":0}},{"line":683,"address":[14289157,14288804,14288731],"length":1,"stats":{"Line":0}},{"line":684,"address":[13760231],"length":1,"stats":{"Line":0}},{"line":687,"address":[14305058,14298572,14299708,14298142,14299855,14298254,14298362,14298546,14304998,14298080,14299734,14302504],"length":1,"stats":{"Line":0}},{"line":688,"address":[14316771],"length":1,"stats":{"Line":0}},{"line":689,"address":[18646475],"length":1,"stats":{"Line":0}},{"line":691,"address":[18646499,18646592],"length":1,"stats":{"Line":0}},{"line":692,"address":[14298717],"length":1,"stats":{"Line":0}},{"line":695,"address":[13769574,13769718],"length":1,"stats":{"Line":0}},{"line":698,"address":[14298863,14305072],"length":1,"stats":{"Line":0}},{"line":699,"address":[14323393,14323380],"length":1,"stats":{"Line":0}},{"line":700,"address":[18652994],"length":1,"stats":{"Line":0}},{"line":701,"address":[18653018],"length":1,"stats":{"Line":0}},{"line":704,"address":[14317355],"length":1,"stats":{"Line":0}},{"line":705,"address":[14317575],"length":1,"stats":{"Line":0}},{"line":709,"address":[13770062],"length":1,"stats":{"Line":0}},{"line":712,"address":[12477105],"length":1,"stats":{"Line":0}},{"line":714,"address":[14318436],"length":1,"stats":{"Line":0}},{"line":715,"address":[14300213],"length":1,"stats":{"Line":0}},{"line":716,"address":[14300225,14300924,14305016],"length":1,"stats":{"Line":0}},{"line":718,"address":[18649179],"length":1,"stats":{"Line":0}},{"line":719,"address":[13772260,13772148],"length":1,"stats":{"Line":0}},{"line":724,"address":[13772183,13772424],"length":1,"stats":{"Line":0}},{"line":725,"address":[14301631,14305473,14305456],"length":1,"stats":{"Line":0}},{"line":727,"address":[18649601,18649695],"length":1,"stats":{"Line":0}},{"line":729,"address":[14320245],"length":1,"stats":{"Line":0}},{"line":731,"address":[14320424,14320318],"length":1,"stats":{"Line":0}},{"line":732,"address":[14320451,14323472,14323489],"length":1,"stats":{"Line":0}},{"line":734,"address":[13773013,13773100],"length":1,"stats":{"Line":0}},{"line":737,"address":[13773303,13772854],"length":1,"stats":{"Line":0}},{"line":738,"address":[14302531,14302623],"length":1,"stats":{"Line":0}},{"line":741,"address":[13773346,13773548],"length":1,"stats":{"Line":0}},{"line":742,"address":[13773656,13773564],"length":1,"stats":{"Line":0}},{"line":745,"address":[14321293,14321091],"length":1,"stats":{"Line":0}},{"line":746,"address":[13773809,13773858],"length":1,"stats":{"Line":0}},{"line":750,"address":[14321336,14321498],"length":1,"stats":{"Line":0}},{"line":751,"address":[14303384],"length":1,"stats":{"Line":0}},{"line":753,"address":[18651112,18651169],"length":1,"stats":{"Line":0}},{"line":754,"address":[14321573,14321635],"length":1,"stats":{"Line":0}},{"line":755,"address":[14303320],"length":1,"stats":{"Line":0}},{"line":757,"address":[13774125],"length":1,"stats":{"Line":0}},{"line":761,"address":[14303597],"length":1,"stats":{"Line":0}},{"line":762,"address":[14303745],"length":1,"stats":{"Line":0}},{"line":763,"address":[13774630],"length":1,"stats":{"Line":0}},{"line":764,"address":[13774601],"length":1,"stats":{"Line":0}},{"line":765,"address":[14303804],"length":1,"stats":{"Line":0}},{"line":766,"address":[13774543],"length":1,"stats":{"Line":0}},{"line":768,"address":[18651774],"length":1,"stats":{"Line":0}},{"line":769,"address":[18651891],"length":1,"stats":{"Line":0}},{"line":770,"address":[14303982],"length":1,"stats":{"Line":0}},{"line":771,"address":[14303953],"length":1,"stats":{"Line":0}},{"line":772,"address":[14303924],"length":1,"stats":{"Line":0}},{"line":775,"address":[13774811],"length":1,"stats":{"Line":0}},{"line":776,"address":[14304262,14304104],"length":1,"stats":{"Line":0}},{"line":781,"address":[18652431,18652072],"length":1,"stats":{"Line":0}},{"line":786,"address":[14304525,14304769],"length":1,"stats":{"Line":0}},{"line":790,"address":[14321528,14323099],"length":1,"stats":{"Line":0}},{"line":792,"address":[18648175],"length":1,"stats":{"Line":0}},{"line":795,"address":[18648524],"length":1,"stats":{"Line":0}},{"line":796,"address":[14300427],"length":1,"stats":{"Line":0}},{"line":798,"address":[18648319],"length":1,"stats":{"Line":0}},{"line":800,"address":[13771365],"length":1,"stats":{"Line":0}},{"line":802,"address":[14318805],"length":1,"stats":{"Line":0}},{"line":803,"address":[14318821],"length":1,"stats":{"Line":0}},{"line":807,"address":[13771359],"length":1,"stats":{"Line":0}},{"line":813,"address":[17184815],"length":1,"stats":{"Line":0}},{"line":814,"address":[18640537],"length":1,"stats":{"Line":0}},{"line":816,"address":[13763441,13763523],"length":1,"stats":{"Line":0}},{"line":817,"address":[14292462,14292977],"length":1,"stats":{"Line":0}},{"line":820,"address":[18640698,18640773],"length":1,"stats":{"Line":0}},{"line":822,"address":[14292543],"length":1,"stats":{"Line":0}},{"line":823,"address":[14310896],"length":1,"stats":{"Line":0}},{"line":825,"address":[13763740],"length":1,"stats":{"Line":0}},{"line":827,"address":[14311472,14311499],"length":1,"stats":{"Line":0}},{"line":830,"address":[18640916],"length":1,"stats":{"Line":0}},{"line":833,"address":[17184399],"length":1,"stats":{"Line":0}},{"line":834,"address":[14295964],"length":1,"stats":{"Line":0}},{"line":835,"address":[14277684],"length":1,"stats":{"Line":0}},{"line":837,"address":[14296008,14296094],"length":1,"stats":{"Line":0}},{"line":838,"address":[14277893,14278823],"length":1,"stats":{"Line":0}},{"line":841,"address":[13749388,13749313],"length":1,"stats":{"Line":0}},{"line":842,"address":[18626510,18627600],"length":1,"stats":{"Line":0}},{"line":844,"address":[13750523],"length":1,"stats":{"Line":0}},{"line":847,"address":[13749497],"length":1,"stats":{"Line":0}},{"line":848,"address":[13749538],"length":1,"stats":{"Line":0}},{"line":849,"address":[14296673],"length":1,"stats":{"Line":0}},{"line":853,"address":[18645987,18644636,18644105,18644418,18645425,18645585,18644538,18644210,18644064,18645951],"length":1,"stats":{"Line":0}},{"line":857,"address":[13767409],"length":1,"stats":{"Line":0}},{"line":858,"address":[14314974],"length":1,"stats":{"Line":0}},{"line":859,"address":[15238769],"length":1,"stats":{"Line":0}},{"line":860,"address":[14316109],"length":1,"stats":{"Line":0}},{"line":863,"address":[14296781,14297093,14296719],"length":1,"stats":{"Line":0}},{"line":864,"address":[14297004],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":412},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","bin","test_dates.rs"],"content":"// Quick test to verify registry date fetching\nuse dependi_lsp::registries::{\n    Registry, crates_io::CratesIoRegistry, npm::NpmRegistry, pypi::PyPiRegistry,\n};\n\n/// Quick async test program that fetches and prints version information from multiple package registries.\n///\n/// The program queries crates.io for \"serde\", npm for \"express\", and PyPI for \"flask\".\n/// For each registry it prints a sample of the first three version strings, the total\n/// count of release dates, and a sample of the first three release dates. Errors are\n/// printed to standard output.\n///\n/// # Examples\n///\n/// ```no_run\n/// // Run the compiled binary to see registry outputs:\n/// // cargo run --bin registry_test\n/// ```\n#[tokio::main]\nasync fn main() {\n    println!(\"=== Testing crates.io (serde) ===\");\n    let registry = CratesIoRegistry::default();\n    match registry.get_version_info(\"serde\").await {\n        Ok(info) => {\n            println!(\n                \"Versions: {:?}\",\n                info.versions.iter().take(3).collect::<Vec<_>>()\n            );\n            println!(\"Release dates count: {}\", info.release_dates.len());\n            println!(\n                \"Sample dates: {:?}\",\n                info.release_dates.iter().take(3).collect::<Vec<_>>()\n            );\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    println!(\"\\n=== Testing npm (express) ===\");\n    let registry = NpmRegistry::default();\n    match registry.get_version_info(\"express\").await {\n        Ok(info) => {\n            println!(\n                \"Versions: {:?}\",\n                info.versions.iter().take(3).collect::<Vec<_>>()\n            );\n            println!(\"Release dates count: {}\", info.release_dates.len());\n            println!(\n                \"Sample dates: {:?}\",\n                info.release_dates.iter().take(3).collect::<Vec<_>>()\n            );\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n\n    println!(\"\\n=== Testing PyPI (flask) ===\");\n    let registry = PyPiRegistry::default();\n    match registry.get_version_info(\"flask\").await {\n        Ok(info) => {\n            println!(\n                \"Versions: {:?}\",\n                info.versions.iter().take(3).collect::<Vec<_>>()\n            );\n            println!(\"Release dates count: {}\", info.release_dates.len());\n            println!(\n                \"Sample dates: {:?}\",\n                info.release_dates.iter().take(3).collect::<Vec<_>>()\n            );\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n","traces":[{"line":20,"address":[12411062,12410672,12411056],"length":1,"stats":{"Line":0}},{"line":21,"address":[12397524,12397363],"length":1,"stats":{"Line":0}},{"line":22,"address":[12397551],"length":1,"stats":{"Line":0}},{"line":23,"address":[12397422,12397645,12397570,12397767],"length":1,"stats":{"Line":0}},{"line":24,"address":[12398096],"length":1,"stats":{"Line":0}},{"line":25,"address":[12398193,12398106],"length":1,"stats":{"Line":0}},{"line":29,"address":[12398438],"length":1,"stats":{"Line":0}},{"line":30,"address":[12398575],"length":1,"stats":{"Line":0}},{"line":35,"address":[12398006,12398858],"length":1,"stats":{"Line":0}},{"line":38,"address":[12398993,12398823],"length":1,"stats":{"Line":0}},{"line":39,"address":[12399020],"length":1,"stats":{"Line":0}},{"line":40,"address":[12399043,12399126,12399219,12397443],"length":1,"stats":{"Line":0}},{"line":41,"address":[12399542],"length":1,"stats":{"Line":0}},{"line":42,"address":[12399624,12399549],"length":1,"stats":{"Line":0}},{"line":46,"address":[12399857],"length":1,"stats":{"Line":0}},{"line":47,"address":[12400076],"length":1,"stats":{"Line":0}},{"line":52,"address":[12399455,12400271],"length":1,"stats":{"Line":0}},{"line":55,"address":[12400406,12400242],"length":1,"stats":{"Line":0}},{"line":56,"address":[12400433],"length":1,"stats":{"Line":0}},{"line":57,"address":[12400456,12400539,12400632,12397464],"length":1,"stats":{"Line":0}},{"line":58,"address":[12400955],"length":1,"stats":{"Line":0}},{"line":59,"address":[12401123],"length":1,"stats":{"Line":0}},{"line":63,"address":[12401270],"length":1,"stats":{"Line":0}},{"line":64,"address":[12401407],"length":1,"stats":{"Line":0}},{"line":69,"address":[12401681,12400868],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","cache","mod.rs"],"content":"//! Cache layer for package version information\n//!\n//! This module provides traits and implementations for caching package\n//! metadata. The cache layer uses a trait hierarchy:\n//!\n//! - **ReadCache**: For read-only cache operations\n//! - **WriteCache**: Extends ReadCache with write operations\n//!\n//! This separation allows for:\n//! - Read-only cache views for providers that don't need to write\n//! - Dependency injection with minimal interface requirements\n//! - Clear separation of concerns\n\nuse std::fmt::Display;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse dashmap::DashMap;\n\nuse crate::registries::VersionInfo;\n\npub mod sqlite;\n\npub use sqlite::SqliteCache;\n\n/// Trait for read-only cache operations\n///\n/// This trait defines the minimal interface for reading cached values.\n/// Implementations can provide additional write operations via the\n/// [`WriteCache`] trait.\npub trait ReadCache: Send + Sync {\n    /// Get a value from the cache\n    ///\n    /// Returns `None` if the key doesn't exist or the entry is expired.\n    fn get(&self, key: &str) -> Option<VersionInfo>;\n\n    /// Check if a key exists in the cache (without fetching the value)\n    #[allow(dead_code)]\n    fn contains(&self, key: &str) -> bool {\n        self.get(key).is_some()\n    }\n}\n\n/// Trait for writeable cache operations\n///\n/// This trait extends [`ReadCache`] with the ability to insert and update\n/// cache entries. Caches that support both read and write operations should\n/// implement this trait.\npub trait WriteCache: ReadCache {\n    /// Insert a value into the cache\n    ///\n    /// If a value with the same key already exists, it will be overwritten.\n    fn insert(&self, key: String, value: VersionInfo);\n\n    /// Remove a value from the cache\n    #[allow(dead_code)]\n    fn remove(&self, key: &str);\n\n    /// Clear all entries from the cache\n    #[allow(dead_code)]\n    fn clear(&self);\n}\n\n#[deprecated(since = \"0.1.0\", note = \"Use ReadCache instead\")]\npub use ReadCache as Cache;\n\nimpl<T: ReadCache> ReadCache for Arc<T> {\n    fn get(&self, key: &str) -> Option<VersionInfo> {\n        (**self).get(key)\n    }\n\n    fn contains(&self, key: &str) -> bool {\n        (**self).contains(key)\n    }\n}\n\nimpl<T: WriteCache> WriteCache for Arc<T> {\n    fn insert(&self, key: String, value: VersionInfo) {\n        (**self).insert(key, value)\n    }\n\n    fn remove(&self, key: &str) {\n        (**self).remove(key)\n    }\n\n    fn clear(&self) {\n        (**self).clear()\n    }\n}\n\n/// Default TTL for cache entries (1 hour)\nconst DEFAULT_TTL: Duration = Duration::from_secs(3600);\n\n/// Cache entry with expiration\n#[derive(Debug, Clone)]\nstruct CacheEntry {\n    data: VersionInfo,\n    inserted_at: Instant,\n    ttl: Duration,\n}\n\nimpl CacheEntry {\n    fn is_expired(&self) -> bool {\n        self.inserted_at.elapsed() > self.ttl\n    }\n}\n\n/// In-memory cache using DashMap for thread-safety\n#[derive(Clone)]\npub struct MemoryCache {\n    entries: Arc<DashMap<String, CacheEntry>>,\n    ttl: Duration,\n}\n\nimpl Default for MemoryCache {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl MemoryCache {\n    /// Create a new cache with default TTL\n    pub fn new() -> Self {\n        Self {\n            entries: Arc::new(DashMap::new()),\n            ttl: DEFAULT_TTL,\n        }\n    }\n}\n\nimpl ReadCache for MemoryCache {\n    fn get(&self, key: &str) -> Option<VersionInfo> {\n        self.entries.get(key).and_then(|entry| {\n            if entry.is_expired() {\n                None\n            } else {\n                Some(entry.data.clone())\n            }\n        })\n    }\n}\n\nimpl WriteCache for MemoryCache {\n    fn insert(&self, key: String, value: VersionInfo) {\n        self.entries.insert(\n            key,\n            CacheEntry {\n                data: value,\n                inserted_at: Instant::now(),\n                ttl: self.ttl,\n            },\n        );\n    }\n\n    fn remove(&self, key: &str) {\n        self.entries.remove(key);\n    }\n\n    fn clear(&self) {\n        self.entries.clear();\n    }\n}\n\nimpl MemoryCache {\n    /// Remove all expired entries from the cache\n    ///\n    /// Returns the number of entries removed.\n    pub fn cleanup_expired(&self) -> usize {\n        let before = self.entries.len();\n        self.entries.retain(|_, entry| !entry.is_expired());\n        let removed = before - self.entries.len();\n        if removed > 0 {\n            tracing::debug!(\n                \"Cleaned up {} expired cache entries ({} remaining)\",\n                removed,\n                self.entries.len()\n            );\n        }\n        removed\n    }\n\n    /// Get statistics about the cache contents\n    ///\n    /// Returns counts of total, expired, and valid entries.\n    pub fn stats(&self) -> CacheStats {\n        let total = self.entries.len();\n        let expired = self.entries.iter().filter(|e| e.is_expired()).count();\n        CacheStats {\n            total_entries: total,\n            expired_entries: expired,\n            valid_entries: total.saturating_sub(expired),\n        }\n    }\n\n    /// Get the number of entries in the cache (including expired)\n    #[cfg(test)]\n    pub fn len(&self) -> usize {\n        self.entries.len()\n    }\n\n    /// Check if the cache is empty\n    #[cfg(test)]\n    pub fn is_empty(&self) -> bool {\n        self.entries.is_empty()\n    }\n\n    /// Create a new cache with custom TTL\n    #[cfg(test)]\n    pub fn with_ttl(ttl: Duration) -> Self {\n        Self {\n            entries: Arc::new(DashMap::new()),\n            ttl,\n        }\n    }\n}\n\n/// Statistics about cache contents\n#[derive(Debug, Clone)]\npub struct CacheStats {\n    /// Total number of entries in the cache\n    pub total_entries: usize,\n    /// Number of expired entries\n    pub expired_entries: usize,\n    /// Number of valid (non-expired) entries\n    pub valid_entries: usize,\n}\n\nimpl Display for CacheStats {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"CacheStats {{ total: {}, expired: {}, valid: {} }}\",\n            self.total_entries, self.expired_entries, self.valid_entries\n        )\n    }\n}\n\n/// Hybrid cache that uses memory for fast access and SQLite for persistence\npub struct HybridCache {\n    memory: MemoryCache,\n    sqlite: Option<Arc<SqliteCache>>,\n}\n\nimpl Default for HybridCache {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Cleanup interval for background task (30 minutes)\nconst CLEANUP_INTERVAL: Duration = Duration::from_secs(30 * 60);\n\nimpl HybridCache {\n    /// Create a new hybrid cache\n    pub fn new() -> Self {\n        let sqlite = match SqliteCache::new() {\n            Ok(cache) => {\n                tracing::info!(\"SQLite cache initialized\");\n                Some(Arc::new(cache))\n            }\n            Err(e) => {\n                tracing::warn!(\n                    \"Failed to initialize SQLite cache, using memory only: {}\",\n                    e\n                );\n                None\n            }\n        };\n\n        let memory = MemoryCache::new();\n        Self::spawn_cleanup_task(memory.clone(), sqlite.clone());\n\n        Self { memory, sqlite }\n    }\n\n    /// Spawn a background task that periodically cleans up expired entries\n    fn spawn_cleanup_task(memory: MemoryCache, sqlite: Option<Arc<SqliteCache>>) {\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(CLEANUP_INTERVAL);\n            interval.tick().await; // Skip immediate first tick\n\n            loop {\n                interval.tick().await;\n\n                let stats = memory.stats();\n                let removed = memory.cleanup_expired();\n                if removed > 0 {\n                    tracing::info!(\n                        \"Background cleanup: removed {} expired entries from memory cache (was: {})\",\n                        removed,\n                        stats\n                    );\n                }\n\n                if let Some(ref sqlite) = sqlite\n                    && let Ok(rows) = sqlite.cleanup_expired()\n                    && rows > 0\n                {\n                    tracing::info!(\n                        \"Background cleanup: removed {} expired entries from SQLite cache\",\n                        rows\n                    );\n                }\n            }\n        });\n    }\n}\n\nimpl ReadCache for HybridCache {\n    fn get(&self, key: &str) -> Option<VersionInfo> {\n        // Fast path: check memory cache first\n        if let Some(value) = self.memory.get(key) {\n            return Some(value);\n        }\n\n        // Slow path: check SQLite cache\n        if let Some(ref sqlite) = self.sqlite\n            && let Some(value) = sqlite.get(key)\n        {\n            // Populate memory cache for future fast access\n            self.memory.insert(key.to_string(), value.clone());\n            return Some(value);\n        }\n\n        None\n    }\n}\n\nimpl WriteCache for HybridCache {\n    fn insert(&self, key: String, value: VersionInfo) {\n        self.memory.insert(key.clone(), value.clone());\n        if let Some(ref sqlite) = self.sqlite {\n            sqlite.insert(key, value);\n        }\n    }\n\n    fn remove(&self, key: &str) {\n        self.memory.remove(key);\n        if let Some(ref sqlite) = self.sqlite {\n            sqlite.remove(key);\n        }\n    }\n\n    fn clear(&self) {\n        self.memory.clear();\n        if let Some(ref sqlite) = self.sqlite {\n            sqlite.clear();\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_version_info() -> VersionInfo {\n        VersionInfo {\n            latest: Some(\"1.0.0\".to_string()),\n            latest_prerelease: None,\n            versions: vec![\"1.0.0\".to_string()],\n            description: None,\n            homepage: None,\n            repository: None,\n            license: None,\n            vulnerabilities: vec![],\n            deprecated: false,\n            yanked: false,\n            yanked_versions: vec![],\n            release_dates: Default::default(),\n        }\n    }\n\n    #[test]\n    fn test_memory_cache_cleanup_expired() {\n        let cache = MemoryCache::with_ttl(Duration::from_millis(10));\n\n        cache.insert(\"key1\".to_string(), create_test_version_info());\n        cache.insert(\"key2\".to_string(), create_test_version_info());\n\n        assert_eq!(cache.len(), 2);\n\n        // Wait for entries to expire\n        std::thread::sleep(Duration::from_millis(20));\n\n        let removed = cache.cleanup_expired();\n        assert_eq!(removed, 2);\n        assert_eq!(cache.len(), 0);\n    }\n\n    #[test]\n    fn test_memory_cache_cleanup_partial() {\n        let cache = MemoryCache::with_ttl(Duration::from_millis(200));\n\n        cache.insert(\"key1\".to_string(), create_test_version_info());\n\n        // Wait for first entry to almost expire\n        std::thread::sleep(Duration::from_millis(150));\n\n        // Insert second entry\n        cache.insert(\"key2\".to_string(), create_test_version_info());\n\n        // Wait for first to expire but not second\n        std::thread::sleep(Duration::from_millis(100));\n\n        let removed = cache.cleanup_expired();\n        assert_eq!(removed, 1);\n        assert_eq!(cache.len(), 1);\n        assert!(cache.get(\"key2\").is_some());\n    }\n\n    #[test]\n    fn test_memory_cache_stats() {\n        let cache = MemoryCache::with_ttl(Duration::from_millis(100));\n\n        cache.insert(\"key1\".to_string(), create_test_version_info());\n        cache.insert(\"key2\".to_string(), create_test_version_info());\n\n        let stats = cache.stats();\n        assert_eq!(stats.total_entries, 2);\n        assert_eq!(stats.expired_entries, 0);\n        assert_eq!(stats.valid_entries, 2);\n\n        // Wait for expiration\n        std::thread::sleep(Duration::from_millis(150));\n\n        let stats = cache.stats();\n        assert_eq!(stats.total_entries, 2);\n        assert_eq!(stats.expired_entries, 2);\n        assert_eq!(stats.valid_entries, 0);\n    }\n\n    #[test]\n    fn test_cache_stats_display() {\n        let stats = CacheStats {\n            total_entries: 10,\n            expired_entries: 3,\n            valid_entries: 7,\n        };\n        let display = format!(\"{}\", stats);\n        assert!(display.contains(\"total: 10\"));\n        assert!(display.contains(\"expired: 3\"));\n        assert!(display.contains(\"valid: 7\"));\n    }\n\n    #[test]\n    fn test_memory_cache_is_empty() {\n        let cache = MemoryCache::with_ttl(Duration::from_secs(60));\n        assert!(cache.is_empty());\n        cache.insert(\"key\".to_string(), create_test_version_info());\n        assert!(!cache.is_empty());\n    }\n}\n","traces":[{"line":39,"address":[13497218,13497212,13497232,13497378,13497372,13497072],"length":1,"stats":{"Line":0}},{"line":40,"address":[13479544],"length":1,"stats":{"Line":0}},{"line":68,"address":[13834992,13835088],"length":1,"stats":{"Line":5}},{"line":69,"address":[13835044,13835140],"length":1,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[17473984,17474210,17474482,17474256],"length":1,"stats":{"Line":3}},{"line":79,"address":[17474009,17474101,17474373,17474281],"length":1,"stats":{"Line":7}},{"line":82,"address":[17474528],"length":1,"stats":{"Line":0}},{"line":83,"address":[14977884],"length":1,"stats":{"Line":0}},{"line":86,"address":[14977280],"length":1,"stats":{"Line":0}},{"line":87,"address":[13835189],"length":1,"stats":{"Line":0}},{"line":103,"address":[19711696],"length":1,"stats":{"Line":3}},{"line":104,"address":[13829534],"length":1,"stats":{"Line":3}},{"line":116,"address":[13851728],"length":1,"stats":{"Line":0}},{"line":117,"address":[12998024],"length":1,"stats":{"Line":0}},{"line":123,"address":[12996464],"length":1,"stats":{"Line":3}},{"line":125,"address":[13832029],"length":1,"stats":{"Line":4}},{"line":132,"address":[13852400],"length":1,"stats":{"Line":5}},{"line":133,"address":[13852450],"length":1,"stats":{"Line":10}},{"line":134,"address":[13497852,13497911,13497790],"length":1,"stats":{"Line":14}},{"line":135,"address":[13468970],"length":1,"stats":{"Line":0}},{"line":137,"address":[14964694,14964654],"length":1,"stats":{"Line":10}},{"line":144,"address":[13853296,13853835,13853779],"length":1,"stats":{"Line":3}},{"line":145,"address":[13835038,13835390],"length":1,"stats":{"Line":6}},{"line":146,"address":[13853433],"length":1,"stats":{"Line":3}},{"line":147,"address":[12999867],"length":1,"stats":{"Line":3}},{"line":148,"address":[12999724],"length":1,"stats":{"Line":3}},{"line":149,"address":[13835214],"length":1,"stats":{"Line":3}},{"line":150,"address":[13853571],"length":1,"stats":{"Line":3}},{"line":155,"address":[19717840],"length":1,"stats":{"Line":0}},{"line":156,"address":[13853913],"length":1,"stats":{"Line":0}},{"line":159,"address":[13853264],"length":1,"stats":{"Line":0}},{"line":160,"address":[13834981],"length":1,"stats":{"Line":0}},{"line":168,"address":[13831376],"length":1,"stats":{"Line":2}},{"line":169,"address":[19713540],"length":1,"stats":{"Line":2}},{"line":170,"address":[14615328,14615360],"length":1,"stats":{"Line":6}},{"line":171,"address":[13849737,13849796],"length":1,"stats":{"Line":2}},{"line":172,"address":[13831498],"length":1,"stats":{"Line":2}},{"line":173,"address":[12996118],"length":1,"stats":{"Line":0}},{"line":185,"address":[13850384],"length":1,"stats":{"Line":2}},{"line":186,"address":[12996582],"length":1,"stats":{"Line":2}},{"line":187,"address":[12996613],"length":1,"stats":{"Line":6}},{"line":191,"address":[13832235],"length":1,"stats":{"Line":2}},{"line":197,"address":[12996432],"length":1,"stats":{"Line":2}},{"line":198,"address":[12996437],"length":1,"stats":{"Line":2}},{"line":203,"address":[12996736],"length":1,"stats":{"Line":2}},{"line":204,"address":[19714469],"length":1,"stats":{"Line":2}},{"line":209,"address":[12996768],"length":1,"stats":{"Line":2}},{"line":211,"address":[12996799],"length":1,"stats":{"Line":2}},{"line":229,"address":[19715296],"length":1,"stats":{"Line":2}},{"line":230,"address":[12997599],"length":1,"stats":{"Line":2}},{"line":245,"address":[12997984],"length":1,"stats":{"Line":0}},{"line":246,"address":[12997992],"length":1,"stats":{"Line":0}},{"line":255,"address":[13848750,13847984,13848718],"length":1,"stats":{"Line":0}},{"line":256,"address":[12994167],"length":1,"stats":{"Line":0}},{"line":257,"address":[13829824],"length":1,"stats":{"Line":0}},{"line":258,"address":[13829934,13829864,13830200],"length":1,"stats":{"Line":0}},{"line":259,"address":[13848445,13848680],"length":1,"stats":{"Line":0}},{"line":261,"address":[13848068],"length":1,"stats":{"Line":0}},{"line":262,"address":[13829796,13830513,13830767],"length":1,"stats":{"Line":0}},{"line":266,"address":[12995171],"length":1,"stats":{"Line":0}},{"line":270,"address":[12994859],"length":1,"stats":{"Line":0}},{"line":271,"address":[19713501,19713300,19713272,19713228],"length":1,"stats":{"Line":0}},{"line":277,"address":[13847888],"length":1,"stats":{"Line":0}},{"line":278,"address":[13467790,13465407,13465376,13465749,13465478,13465510,13466015],"length":1,"stats":{"Line":0}},{"line":279,"address":[13494381],"length":1,"stats":{"Line":0}},{"line":280,"address":[13494515,13494575,13494698,13494425],"length":1,"stats":{"Line":0}},{"line":283,"address":[12462264],"length":1,"stats":{"Line":0}},{"line":285,"address":[14962027],"length":1,"stats":{"Line":0}},{"line":286,"address":[14962054],"length":1,"stats":{"Line":0}},{"line":287,"address":[14613705],"length":1,"stats":{"Line":0}},{"line":288,"address":[14613760],"length":1,"stats":{"Line":0}},{"line":295,"address":[14962108,14962710],"length":1,"stats":{"Line":0}},{"line":296,"address":[13466990,13467094],"length":1,"stats":{"Line":0}},{"line":297,"address":[13467110],"length":1,"stats":{"Line":0}},{"line":299,"address":[14614457,14614526,14614767],"length":1,"stats":{"Line":0}},{"line":310,"address":[12998651,12998048,12998645],"length":1,"stats":{"Line":0}},{"line":312,"address":[12998104],"length":1,"stats":{"Line":0}},{"line":313,"address":[13851901],"length":1,"stats":{"Line":0}},{"line":317,"address":[12998213,12998269],"length":1,"stats":{"Line":0}},{"line":318,"address":[12998375,12998277],"length":1,"stats":{"Line":0}},{"line":321,"address":[13833818,13833921,13834057,13833890],"length":1,"stats":{"Line":0}},{"line":322,"address":[19716297],"length":1,"stats":{"Line":0}},{"line":325,"address":[13833758],"length":1,"stats":{"Line":0}},{"line":330,"address":[13852592,13853096,13853118],"length":1,"stats":{"Line":0}},{"line":331,"address":[13834445,13834334,13834789],"length":1,"stats":{"Line":0}},{"line":332,"address":[12999106],"length":1,"stats":{"Line":0}},{"line":333,"address":[12999256,12999155],"length":1,"stats":{"Line":0}},{"line":337,"address":[13834864],"length":1,"stats":{"Line":0}},{"line":338,"address":[12999441],"length":1,"stats":{"Line":0}},{"line":339,"address":[19717183],"length":1,"stats":{"Line":0}},{"line":340,"address":[12999500],"length":1,"stats":{"Line":0}},{"line":344,"address":[13852512],"length":1,"stats":{"Line":0}},{"line":345,"address":[13834237],"length":1,"stats":{"Line":0}},{"line":346,"address":[13834251],"length":1,"stats":{"Line":0}},{"line":347,"address":[13834286],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":97},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","cache","sqlite.rs"],"content":"//! SQLite persistent cache for package version information with connection pooling\n\nuse std::path::PathBuf;\nuse std::sync::Arc;\n#[cfg(test)]\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse r2d2::{Pool, PooledConnection};\nuse r2d2_sqlite::SqliteConnectionManager;\nuse rusqlite::params;\n\nuse crate::cache::{ReadCache, WriteCache};\nuse crate::registries::VersionInfo;\n\n/// Default TTL for cache entries (1 hour)\nconst DEFAULT_TTL_SECS: i64 = 3600;\n\n#[cfg(test)]\nstatic TEST_DB_COUNTER: AtomicU64 = AtomicU64::new(0);\n\n/// Configuration for SQLite cache pool\n#[derive(Debug, Clone)]\npub struct SqliteCacheConfig {\n    /// Maximum number of connections in the pool\n    pub max_pool_size: u32,\n    /// Minimum number of idle connections to maintain\n    pub min_idle_connections: u32,\n    /// Timeout in seconds for acquiring a connection\n    pub connection_timeout_secs: u64,\n    /// SQLite busy timeout in milliseconds\n    pub busy_timeout_ms: u32,\n    /// SQLite cache size in kilobytes\n    pub cache_size_kb: i64,\n    /// Time-to-live for cache entries in seconds\n    pub ttl_secs: i64,\n}\n\nimpl Default for SqliteCacheConfig {\n    fn default() -> Self {\n        Self {\n            max_pool_size: 10,\n            min_idle_connections: 2,\n            connection_timeout_secs: 5,\n            busy_timeout_ms: 5000,\n            cache_size_kb: 64000,\n            ttl_secs: DEFAULT_TTL_SECS,\n        }\n    }\n}\n\n/// SQLite-based persistent cache with connection pooling\npub struct SqliteCache {\n    pool: Arc<Pool<SqliteConnectionManager>>,\n    ttl_secs: i64,\n}\n\nimpl SqliteCache {\n    /// Create a new SQLite cache at the default location (~/.cache/dependi/cache.db)\n    pub fn new() -> anyhow::Result<Self> {\n        Self::with_config(SqliteCacheConfig::default())\n    }\n\n    /// Create a new SQLite cache with custom configuration\n    pub fn with_config(config: SqliteCacheConfig) -> anyhow::Result<Self> {\n        let cache_dir = Self::cache_dir()?;\n        std::fs::create_dir_all(&cache_dir)?;\n        let db_path = cache_dir.join(\"cache.db\");\n        Self::with_path_and_config(db_path, config)\n    }\n\n    /// Create a new SQLite cache at a custom path with custom configuration\n    pub fn with_path_and_config(path: PathBuf, config: SqliteCacheConfig) -> anyhow::Result<Self> {\n        let busy_timeout_ms = config.busy_timeout_ms;\n        let cache_size_kb = config.cache_size_kb;\n\n        let manager = SqliteConnectionManager::file(&path).with_init(move |conn| {\n            let pragmas = format!(\n                \"PRAGMA busy_timeout={};\n                 PRAGMA synchronous=NORMAL;\n                 PRAGMA cache_size=-{};\",\n                busy_timeout_ms, cache_size_kb\n            );\n            conn.execute_batch(&pragmas)?;\n            Ok(())\n        });\n\n        let pool = Pool::builder()\n            .max_size(config.max_pool_size)\n            .min_idle(Some(config.min_idle_connections))\n            .connection_timeout(Duration::from_secs(config.connection_timeout_secs))\n            .idle_timeout(Some(Duration::from_secs(600)))\n            .max_lifetime(Some(Duration::from_secs(1800)))\n            .build(manager)?;\n\n        let cache = Self {\n            pool: Arc::new(pool),\n            ttl_secs: config.ttl_secs,\n        };\n\n        cache.init_schema()?;\n        cache.cleanup_expired()?;\n\n        let state = cache.pool_state();\n        tracing::debug!(\n            connections = state.connections,\n            idle = state.idle_connections,\n            \"SQLite cache pool initialized\"\n        );\n\n        Ok(cache)\n    }\n\n    /// Create an in-memory cache (for testing)\n    ///\n    /// Uses a shared in-memory database URI so all pooled connections access\n    /// the same database. Each call generates a unique database name to avoid\n    /// conflicts between tests.\n    #[cfg(test)]\n    pub fn in_memory() -> anyhow::Result<Self> {\n        let db_id = TEST_DB_COUNTER.fetch_add(1, Ordering::SeqCst);\n        let uri = format!(\"file:memdb{}?mode=memory&cache=shared\", db_id);\n        let config = SqliteCacheConfig::default();\n\n        let manager = SqliteConnectionManager::file(&uri).with_init(|conn| {\n            conn.execute_batch(\n                \"PRAGMA busy_timeout=5000;\n                 PRAGMA synchronous=NORMAL;\n                 PRAGMA cache_size=-64000;\",\n            )?;\n            Ok(())\n        });\n\n        let pool = Pool::builder().max_size(5).build(manager)?;\n\n        let cache = Self {\n            pool: Arc::new(pool),\n            ttl_secs: config.ttl_secs,\n        };\n\n        cache.init_schema_memory()?;\n        Ok(cache)\n    }\n\n    /// Initialize schema for in-memory database (no WAL mode)\n    #[cfg(test)]\n    fn init_schema_memory(&self) -> anyhow::Result<()> {\n        let conn = self.pool.get()?;\n\n        conn.execute(\n            \"CREATE TABLE IF NOT EXISTS packages (\n                key TEXT PRIMARY KEY,\n                data TEXT NOT NULL,\n                inserted_at INTEGER NOT NULL,\n                ttl_secs INTEGER NOT NULL\n            )\",\n            [],\n        )?;\n        conn.execute(\n            \"CREATE INDEX IF NOT EXISTS idx_expiry ON packages(inserted_at, ttl_secs)\",\n            [],\n        )?;\n        Ok(())\n    }\n\n    /// Get the cache directory\n    fn cache_dir() -> anyhow::Result<PathBuf> {\n        let cache_dir = dirs::cache_dir()\n            .ok_or_else(|| anyhow::anyhow!(\"Could not determine cache directory\"))?;\n        Ok(cache_dir.join(\"dependi\"))\n    }\n\n    /// Get a connection from the pool, returning None if unavailable\n    fn get_conn(&self) -> Option<PooledConnection<SqliteConnectionManager>> {\n        self.pool.get().ok()\n    }\n\n    /// Initialize the database schema with WAL mode\n    ///\n    /// Note: Per-connection PRAGMAs (busy_timeout, synchronous, cache_size)\n    /// are applied via with_init() on every new connection from the pool.\n    /// Only WAL mode (database-level) is set here.\n    fn init_schema(&self) -> anyhow::Result<()> {\n        let conn = self.pool.get()?;\n\n        conn.execute_batch(\"PRAGMA journal_mode=WAL;\")?;\n\n        conn.execute(\n            \"CREATE TABLE IF NOT EXISTS packages (\n                key TEXT PRIMARY KEY,\n                data TEXT NOT NULL,\n                inserted_at INTEGER NOT NULL,\n                ttl_secs INTEGER NOT NULL\n            )\",\n            [],\n        )?;\n        conn.execute(\n            \"CREATE INDEX IF NOT EXISTS idx_expiry ON packages(inserted_at, ttl_secs)\",\n            [],\n        )?;\n        Ok(())\n    }\n}\n\nimpl ReadCache for SqliteCache {\n    fn get(&self, key: &str) -> Option<VersionInfo> {\n        let conn = self.get_conn()?;\n        let now = current_timestamp();\n\n        let result: Result<(String, i64, i64), _> = conn.query_row(\n            \"SELECT data, inserted_at, ttl_secs FROM packages WHERE key = ?\",\n            [key],\n            |row| Ok((row.get(0)?, row.get(1)?, row.get(2)?)),\n        );\n\n        match result {\n            Ok((data, inserted_at, ttl_secs)) => {\n                if now > inserted_at + ttl_secs {\n                    let _ = conn.execute(\"DELETE FROM packages WHERE key = ?\", [key]);\n                    None\n                } else {\n                    serde_json::from_str(&data).ok()\n                }\n            }\n            Err(_) => None,\n        }\n    }\n}\n\nimpl WriteCache for SqliteCache {\n    fn insert(&self, key: String, value: VersionInfo) {\n        let Some(conn) = self.get_conn() else {\n            return;\n        };\n        let now = current_timestamp();\n        let data = match serde_json::to_string(&value) {\n            Ok(d) => d,\n            Err(_) => return,\n        };\n\n        let _ = conn.execute(\n            \"INSERT OR REPLACE INTO packages (key, data, inserted_at, ttl_secs) VALUES (?, ?, ?, ?)\",\n            params![key, data, now, self.ttl_secs],\n        );\n    }\n\n    fn remove(&self, key: &str) {\n        let Some(conn) = self.get_conn() else {\n            return;\n        };\n        let _ = conn.execute(\"DELETE FROM packages WHERE key = ?\", [key]);\n    }\n\n    fn clear(&self) {\n        let Some(conn) = self.get_conn() else {\n            return;\n        };\n        let _ = conn.execute(\"DELETE FROM packages\", []);\n    }\n}\n\nimpl SqliteCache {\n    /// Insert multiple values in a single transaction\n    #[cfg(test)]\n    pub fn insert_batch(&self, entries: Vec<(String, VersionInfo)>) -> anyhow::Result<usize> {\n        if entries.is_empty() {\n            return Ok(0);\n        }\n\n        let mut conn = self.pool.get()?;\n        let tx = conn.transaction()?;\n        let now = current_timestamp();\n        let mut count = 0;\n\n        for (key, value) in entries {\n            let data = serde_json::to_string(&value)?;\n            tx.execute(\n                \"INSERT OR REPLACE INTO packages (key, data, inserted_at, ttl_secs) VALUES (?, ?, ?, ?)\",\n                params![key, data, now, self.ttl_secs],\n            )?;\n            count += 1;\n        }\n\n        tx.commit()?;\n        Ok(count)\n    }\n\n    /// Remove a value from the cache, returning whether it existed\n    #[cfg(test)]\n    pub fn remove_with_result(&self, key: &str) -> bool {\n        let Some(conn) = self.get_conn() else {\n            return false;\n        };\n        conn.execute(\"DELETE FROM packages WHERE key = ?\", [key])\n            .map(|rows| rows > 0)\n            .unwrap_or(false)\n    }\n\n    /// Clear all entries from the cache, returning the count\n    #[cfg(test)]\n    pub fn clear_with_count(&self) -> anyhow::Result<usize> {\n        let conn = self.pool.get()?;\n        let rows = conn.execute(\"DELETE FROM packages\", [])?;\n        Ok(rows)\n    }\n\n    /// Remove expired entries from the cache\n    pub fn cleanup_expired(&self) -> anyhow::Result<usize> {\n        let conn = self.pool.get()?;\n        let now = current_timestamp();\n        let rows = conn.execute(\n            \"DELETE FROM packages WHERE inserted_at + ttl_secs < ?\",\n            [now],\n        )?;\n        Ok(rows)\n    }\n\n    /// Get pool statistics for monitoring\n    pub fn pool_state(&self) -> PoolState {\n        let state = self.pool.state();\n        PoolState {\n            connections: state.connections,\n            idle_connections: state.idle_connections,\n        }\n    }\n}\n\n/// Pool statistics for monitoring\n#[derive(Debug, Clone, Copy)]\npub struct PoolState {\n    /// Total number of connections in the pool\n    pub connections: u32,\n    /// Number of idle connections available\n    pub idle_connections: u32,\n}\n\n/// Get current Unix timestamp\nfn current_timestamp() -> i64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap_or_default()\n        .as_secs() as i64\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_version_info() -> VersionInfo {\n        VersionInfo {\n            latest: Some(\"1.0.0\".to_string()),\n            latest_prerelease: None,\n            versions: vec![\"1.0.0\".to_string(), \"0.9.0\".to_string()],\n            description: Some(\"Test package\".to_string()),\n            homepage: None,\n            repository: None,\n            license: Some(\"MIT\".to_string()),\n            vulnerabilities: vec![],\n            deprecated: false,\n            yanked: false,\n            yanked_versions: vec![],\n            release_dates: Default::default(),\n        }\n    }\n\n    #[test]\n    fn test_insert_and_get() {\n        let cache = SqliteCache::in_memory().unwrap();\n        let info = create_test_version_info();\n\n        cache.insert(\"test:package\".to_string(), info.clone());\n        let retrieved = cache.get(\"test:package\");\n\n        assert!(retrieved.is_some());\n        let retrieved = retrieved.unwrap();\n        assert_eq!(retrieved.latest, info.latest);\n        assert_eq!(retrieved.versions, info.versions);\n    }\n\n    #[test]\n    fn test_get_nonexistent() {\n        let cache = SqliteCache::in_memory().unwrap();\n        let retrieved = cache.get(\"nonexistent\");\n        assert!(retrieved.is_none());\n    }\n\n    #[test]\n    fn test_overwrite() {\n        let cache = SqliteCache::in_memory().unwrap();\n\n        let info1 = VersionInfo {\n            latest: Some(\"1.0.0\".to_string()),\n            ..create_test_version_info()\n        };\n        let info2 = VersionInfo {\n            latest: Some(\"2.0.0\".to_string()),\n            ..create_test_version_info()\n        };\n\n        cache.insert(\"test:package\".to_string(), info1);\n        cache.insert(\"test:package\".to_string(), info2);\n\n        let retrieved = cache.get(\"test:package\").unwrap();\n        assert_eq!(retrieved.latest, Some(\"2.0.0\".to_string()));\n    }\n\n    #[test]\n    fn test_pool_state() {\n        let cache = SqliteCache::in_memory().unwrap();\n        let state = cache.pool_state();\n        assert!(state.connections > 0);\n    }\n\n    #[test]\n    fn test_remove() {\n        let cache = SqliteCache::in_memory().unwrap();\n        let info = create_test_version_info();\n\n        cache.insert(\"test:package\".to_string(), info);\n        assert!(cache.get(\"test:package\").is_some());\n\n        let removed = cache.remove_with_result(\"test:package\");\n        assert!(removed);\n        assert!(cache.get(\"test:package\").is_none());\n\n        let removed_again = cache.remove_with_result(\"test:package\");\n        assert!(!removed_again);\n    }\n\n    #[test]\n    fn test_clear() {\n        let cache = SqliteCache::in_memory().unwrap();\n        let info = create_test_version_info();\n\n        cache.insert(\"pkg1\".to_string(), info.clone());\n        cache.insert(\"pkg2\".to_string(), info.clone());\n        cache.insert(\"pkg3\".to_string(), info);\n\n        let cleared = cache.clear_with_count().unwrap();\n        assert_eq!(cleared, 3);\n\n        assert!(cache.get(\"pkg1\").is_none());\n        assert!(cache.get(\"pkg2\").is_none());\n        assert!(cache.get(\"pkg3\").is_none());\n    }\n\n    #[test]\n    fn test_insert_batch() {\n        let cache = SqliteCache::in_memory().unwrap();\n\n        let entries: Vec<(String, VersionInfo)> = (0..10)\n            .map(|i| {\n                let mut info = create_test_version_info();\n                info.latest = Some(format!(\"{}.0.0\", i));\n                (format!(\"pkg{}\", i), info)\n            })\n            .collect();\n\n        let count = cache.insert_batch(entries).unwrap();\n        assert_eq!(count, 10);\n\n        for i in 0..10 {\n            let retrieved = cache.get(&format!(\"pkg{}\", i)).unwrap();\n            assert_eq!(retrieved.latest, Some(format!(\"{}.0.0\", i)));\n        }\n    }\n\n    #[test]\n    fn test_insert_batch_empty() {\n        let cache = SqliteCache::in_memory().unwrap();\n        let count = cache.insert_batch(vec![]).unwrap();\n        assert_eq!(count, 0);\n    }\n\n    #[test]\n    fn test_concurrent_reads() {\n        use std::sync::Arc;\n        use std::thread;\n\n        let cache = Arc::new(SqliteCache::in_memory().unwrap());\n\n        for i in 0..20 {\n            let mut info = create_test_version_info();\n            info.latest = Some(format!(\"{}.0.0\", i));\n            cache.insert(format!(\"pkg{}\", i), info);\n        }\n\n        let handles: Vec<_> = (0..10)\n            .map(|thread_id| {\n                let cache = Arc::clone(&cache);\n                thread::spawn(move || {\n                    for i in 0..20 {\n                        let key = format!(\"pkg{}\", i);\n                        let result = cache.get(&key);\n                        assert!(\n                            result.is_some(),\n                            \"Thread {} failed to read {}\",\n                            thread_id,\n                            key\n                        );\n                    }\n                })\n            })\n            .collect();\n\n        for handle in handles {\n            handle.join().expect(\"Thread panicked\");\n        }\n    }\n\n    #[test]\n    fn test_concurrent_writes() {\n        use std::sync::Arc;\n        use std::thread;\n\n        let cache = Arc::new(SqliteCache::in_memory().unwrap());\n\n        let handles: Vec<_> = (0..5)\n            .map(|thread_id| {\n                let cache = Arc::clone(&cache);\n                thread::spawn(move || {\n                    for i in 0..10 {\n                        let key = format!(\"thread{}:pkg{}\", thread_id, i);\n                        let mut info = create_test_version_info();\n                        info.latest = Some(format!(\"{}.{}.0\", thread_id, i));\n                        cache.insert(key, info);\n                    }\n                })\n            })\n            .collect();\n\n        for handle in handles {\n            handle.join().expect(\"Thread panicked\");\n        }\n\n        for thread_id in 0..5 {\n            for i in 0..10 {\n                let key = format!(\"thread{}:pkg{}\", thread_id, i);\n                let result = cache.get(&key);\n                assert!(result.is_some(), \"Missing key: {}\", key);\n            }\n        }\n    }\n\n    #[test]\n    fn test_concurrent_mixed_operations() {\n        use std::sync::Arc;\n        use std::thread;\n\n        let cache = Arc::new(SqliteCache::in_memory().unwrap());\n\n        for i in 0..50 {\n            let mut info = create_test_version_info();\n            info.latest = Some(format!(\"{}.0.0\", i));\n            cache.insert(format!(\"pkg{}\", i), info);\n        }\n\n        let handles: Vec<_> = (0..10)\n            .map(|thread_id| {\n                let cache = Arc::clone(&cache);\n                thread::spawn(move || {\n                    for i in 0..50 {\n                        match thread_id % 3 {\n                            0 => {\n                                let _ = cache.get(&format!(\"pkg{}\", i));\n                            }\n                            1 => {\n                                let mut info = create_test_version_info();\n                                info.latest = Some(format!(\"updated-{}-{}\", thread_id, i));\n                                cache.insert(format!(\"pkg{}\", i), info);\n                            }\n                            _ => {\n                                let mut info = create_test_version_info();\n                                info.latest = Some(format!(\"new-{}-{}\", thread_id, i));\n                                cache.insert(format!(\"new-pkg-{}-{}\", thread_id, i), info);\n                            }\n                        }\n                    }\n                })\n            })\n            .collect();\n\n        for handle in handles {\n            handle.join().expect(\"Thread panicked\");\n        }\n    }\n\n    #[test]\n    fn test_config_default() {\n        let config = SqliteCacheConfig::default();\n        assert_eq!(config.max_pool_size, 10);\n        assert_eq!(config.min_idle_connections, 2);\n        assert_eq!(config.busy_timeout_ms, 5000);\n        assert_eq!(config.cache_size_kb, 64000);\n        assert_eq!(config.ttl_secs, DEFAULT_TTL_SECS);\n    }\n}\n","traces":[{"line":40,"address":[13626640],"length":1,"stats":{"Line":2}},{"line":60,"address":[13596592],"length":1,"stats":{"Line":0}},{"line":61,"address":[12843437],"length":1,"stats":{"Line":0}},{"line":65,"address":[13622048,13622514],"length":1,"stats":{"Line":0}},{"line":66,"address":[13622070],"length":1,"stats":{"Line":0}},{"line":67,"address":[13622218,13622285],"length":1,"stats":{"Line":0}},{"line":68,"address":[13622389],"length":1,"stats":{"Line":0}},{"line":69,"address":[13622458],"length":1,"stats":{"Line":0}},{"line":73,"address":[13625492,13623232,13625374],"length":1,"stats":{"Line":0}},{"line":74,"address":[12841287],"length":1,"stats":{"Line":0}},{"line":75,"address":[12841344],"length":1,"stats":{"Line":0}},{"line":77,"address":[13594498,13594420],"length":1,"stats":{"Line":0}},{"line":78,"address":[14163310],"length":1,"stats":{"Line":0}},{"line":84,"address":[13450130,13450203],"length":1,"stats":{"Line":0}},{"line":85,"address":[15085346],"length":1,"stats":{"Line":0}},{"line":88,"address":[12841822,12841692,12841477,12842168,12843331,12842084,12841952],"length":1,"stats":{"Line":0}},{"line":89,"address":[13623529],"length":1,"stats":{"Line":0}},{"line":90,"address":[12841564],"length":1,"stats":{"Line":0}},{"line":91,"address":[12843377,12841716,12841611],"length":1,"stats":{"Line":0}},{"line":92,"address":[12841846,12841744,12843359],"length":1,"stats":{"Line":0}},{"line":93,"address":[12841976,12841874,12843341],"length":1,"stats":{"Line":0}},{"line":94,"address":[12841991,12842136],"length":1,"stats":{"Line":0}},{"line":97,"address":[19250017],"length":1,"stats":{"Line":0}},{"line":98,"address":[19250099],"length":1,"stats":{"Line":0}},{"line":101,"address":[19250127,19250181,19251065],"length":1,"stats":{"Line":0}},{"line":102,"address":[19251048,19250286],"length":1,"stats":{"Line":0}},{"line":104,"address":[12842643],"length":1,"stats":{"Line":0}},{"line":105,"address":[13595815,13596133],"length":1,"stats":{"Line":0}},{"line":111,"address":[19250740],"length":1,"stats":{"Line":0}},{"line":120,"address":[12844894,12843936,12844942],"length":1,"stats":{"Line":22}},{"line":121,"address":[12843953],"length":1,"stats":{"Line":22}},{"line":122,"address":[19251793],"length":1,"stats":{"Line":14}},{"line":123,"address":[12844126],"length":1,"stats":{"Line":22}},{"line":125,"address":[14163888],"length":1,"stats":{"Line":28}},{"line":126,"address":[14163934,14164035],"length":1,"stats":{"Line":3}},{"line":131,"address":[15085711],"length":1,"stats":{"Line":10}},{"line":134,"address":[19252091,19252025,19252710],"length":1,"stats":{"Line":44}},{"line":137,"address":[12844531],"length":1,"stats":{"Line":5}},{"line":138,"address":[12844605],"length":1,"stats":{"Line":2}},{"line":141,"address":[19252483,19252429],"length":1,"stats":{"Line":11}},{"line":142,"address":[12844787],"length":1,"stats":{"Line":5}},{"line":147,"address":[12840877,12840096,12840883],"length":1,"stats":{"Line":2}},{"line":148,"address":[19247903],"length":1,"stats":{"Line":8}},{"line":150,"address":[12840870,12840392,12840338,12840547],"length":1,"stats":{"Line":10}},{"line":159,"address":[12840848,12840770,12840598],"length":1,"stats":{"Line":4}},{"line":163,"address":[12840812],"length":1,"stats":{"Line":8}},{"line":167,"address":[13597107,13596752,13597101],"length":1,"stats":{"Line":0}},{"line":168,"address":[13625724,13625792,13625697],"length":1,"stats":{"Line":0}},{"line":169,"address":[15085472,15085476],"length":1,"stats":{"Line":0}},{"line":170,"address":[13625867,13625933],"length":1,"stats":{"Line":0}},{"line":174,"address":[13625584],"length":1,"stats":{"Line":3}},{"line":175,"address":[13596694],"length":1,"stats":{"Line":3}},{"line":183,"address":[13593094,13593100,13592048],"length":1,"stats":{"Line":0}},{"line":184,"address":[13592063],"length":1,"stats":{"Line":0}},{"line":186,"address":[12835042,12835797,12835096],"length":1,"stats":{"Line":0}},{"line":188,"address":[13592549,13592734,13593075],"length":1,"stats":{"Line":0}},{"line":197,"address":[13592784,13592969,13593052],"length":1,"stats":{"Line":0}},{"line":201,"address":[13593015],"length":1,"stats":{"Line":0}},{"line":206,"address":[12846550,12845600,12846488],"length":1,"stats":{"Line":2}},{"line":207,"address":[13626739],"length":1,"stats":{"Line":2}},{"line":208,"address":[19253643,19253589],"length":1,"stats":{"Line":4}},{"line":210,"address":[13598077,13598025],"length":1,"stats":{"Line":6}},{"line":212,"address":[19253683],"length":1,"stats":{"Line":4}},{"line":213,"address":[13479838,13479808],"length":1,"stats":{"Line":8}},{"line":216,"address":[13627044],"length":1,"stats":{"Line":2}},{"line":217,"address":[12846002],"length":1,"stats":{"Line":8}},{"line":218,"address":[19254176,19253874],"length":1,"stats":{"Line":7}},{"line":219,"address":[13598375,13598486],"length":1,"stats":{"Line":0}},{"line":220,"address":[12846371],"length":1,"stats":{"Line":0}},{"line":222,"address":[12846235,12846184],"length":1,"stats":{"Line":16}},{"line":225,"address":[13598158],"length":1,"stats":{"Line":2}},{"line":231,"address":[12847619,12847668,12846816],"length":1,"stats":{"Line":2}},{"line":232,"address":[13599132,13599084],"length":1,"stats":{"Line":7}},{"line":235,"address":[19254753,19254827],"length":1,"stats":{"Line":13}},{"line":236,"address":[13628207],"length":1,"stats":{"Line":14}},{"line":237,"address":[13628309],"length":1,"stats":{"Line":2}},{"line":241,"address":[19255255,19255086],"length":1,"stats":{"Line":16}},{"line":243,"address":[13628541],"length":1,"stats":{"Line":12}},{"line":247,"address":[12847696,12847971,12847977],"length":1,"stats":{"Line":0}},{"line":248,"address":[19255535],"length":1,"stats":{"Line":0}},{"line":251,"address":[13629101,13629021],"length":1,"stats":{"Line":0}},{"line":254,"address":[13599016,13599010,13598784],"length":1,"stats":{"Line":0}},{"line":255,"address":[13598802],"length":1,"stats":{"Line":0}},{"line":258,"address":[13598880,13598947],"length":1,"stats":{"Line":0}},{"line":265,"address":[19244096,19246596,19246366],"length":1,"stats":{"Line":2}},{"line":266,"address":[12836354,12836440],"length":1,"stats":{"Line":4}},{"line":267,"address":[19244261],"length":1,"stats":{"Line":2}},{"line":270,"address":[19244246,19246560,19244306],"length":1,"stats":{"Line":4}},{"line":271,"address":[12836798,12836727,12838719],"length":1,"stats":{"Line":4}},{"line":272,"address":[12837017,12837083],"length":1,"stats":{"Line":4}},{"line":273,"address":[12837091],"length":1,"stats":{"Line":2}},{"line":275,"address":[12837284,12837103],"length":1,"stats":{"Line":4}},{"line":276,"address":[19246382,19245193,19245576],"length":1,"stats":{"Line":4}},{"line":277,"address":[19245930,19245755,19246316,19246099],"length":1,"stats":{"Line":4}},{"line":279,"address":[19245824],"length":1,"stats":{"Line":2}},{"line":281,"address":[12838358,12838413],"length":1,"stats":{"Line":2}},{"line":284,"address":[19245218,19245501],"length":1,"stats":{"Line":2}},{"line":285,"address":[12837624],"length":1,"stats":{"Line":2}},{"line":290,"address":[12841232,12840896,12841226],"length":1,"stats":{"Line":2}},{"line":291,"address":[12840943],"length":1,"stats":{"Line":2}},{"line":292,"address":[19248827],"length":1,"stats":{"Line":0}},{"line":294,"address":[12841097,12841196,12841023],"length":1,"stats":{"Line":6}},{"line":295,"address":[14163200,14163205],"length":1,"stats":{"Line":6}},{"line":301,"address":[12840064,12840070,12839488],"length":1,"stats":{"Line":2}},{"line":302,"address":[12839503],"length":1,"stats":{"Line":2}},{"line":303,"address":[12839735,12839789,12840042],"length":1,"stats":{"Line":4}},{"line":304,"address":[12839991],"length":1,"stats":{"Line":2}},{"line":308,"address":[13594279,13593616,13594273],"length":1,"stats":{"Line":0}},{"line":309,"address":[12838847],"length":1,"stats":{"Line":0}},{"line":310,"address":[12839123,12839069],"length":1,"stats":{"Line":0}},{"line":311,"address":[13594145,13594250,13593923,13593962],"length":1,"stats":{"Line":0}},{"line":313,"address":[13593954],"length":1,"stats":{"Line":0}},{"line":315,"address":[13594197],"length":1,"stats":{"Line":0}},{"line":319,"address":[13592000],"length":1,"stats":{"Line":2}},{"line":320,"address":[19242553],"length":1,"stats":{"Line":2}},{"line":338,"address":[12844960],"length":1,"stats":{"Line":10}},{"line":339,"address":[13597124],"length":1,"stats":{"Line":3}},{"line":340,"address":[13626067],"length":1,"stats":{"Line":8}},{"line":341,"address":[13597161],"length":1,"stats":{"Line":6}},{"line":342,"address":[13597180],"length":1,"stats":{"Line":13}}],"covered":67,"coverable":120},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","config.rs"],"content":"//! Configuration management for Dependi LSP\n\nuse serde::Deserialize;\n\n/// Default cache TTL (1 hour)\nconst DEFAULT_CACHE_TTL_SECS: u64 = 3600;\n\n/// Default vulnerability cache TTL (6 hours)\nconst DEFAULT_VULN_CACHE_TTL_SECS: u64 = 6 * 3600;\n\n/// LSP configuration\n#[derive(Debug, Clone, Deserialize, Default)]\n#[serde(default)]\npub struct Config {\n    /// Inlay hints configuration\n    pub inlay_hints: InlayHintsConfig,\n    /// Diagnostics configuration\n    pub diagnostics: DiagnosticsConfig,\n    /// Cache configuration\n    pub cache: CacheConfig,\n    /// Security/vulnerability configuration\n    pub security: SecurityConfig,\n    /// Packages to ignore (glob patterns)\n    #[serde(default)]\n    pub ignore: Vec<String>,\n}\n\n/// Inlay hints configuration\n#[derive(Debug, Clone, Deserialize)]\n#[serde(default)]\npub struct InlayHintsConfig {\n    /// Enable inlay hints\n    pub enabled: bool,\n    /// Show hints for up-to-date packages\n    pub show_up_to_date: bool,\n}\n\nimpl Default for InlayHintsConfig {\n    fn default() -> Self {\n        Self {\n            enabled: true,\n            show_up_to_date: true,\n        }\n    }\n}\n\n/// Diagnostics configuration\n#[derive(Debug, Clone, Deserialize)]\n#[serde(default)]\npub struct DiagnosticsConfig {\n    /// Enable diagnostics\n    pub enabled: bool,\n}\n\nimpl Default for DiagnosticsConfig {\n    fn default() -> Self {\n        Self { enabled: true }\n    }\n}\n\n/// Cache configuration\n#[derive(Debug, Clone, Deserialize)]\n#[serde(default)]\npub struct CacheConfig {\n    /// Cache TTL in seconds\n    pub ttl_secs: u64,\n}\n\nimpl Default for CacheConfig {\n    fn default() -> Self {\n        Self {\n            ttl_secs: DEFAULT_CACHE_TTL_SECS,\n        }\n    }\n}\n\n/// Security/vulnerability scanning configuration\n#[derive(Debug, Clone, Deserialize)]\n#[serde(default)]\npub struct SecurityConfig {\n    /// Enable vulnerability scanning\n    pub enabled: bool,\n    /// Show vulnerabilities in inlay hints\n    pub show_in_hints: bool,\n    /// Show vulnerabilities as diagnostics\n    pub show_diagnostics: bool,\n    /// Minimum severity level to display (\"low\", \"medium\", \"high\", \"critical\")\n    pub min_severity: String,\n    /// Vulnerability cache TTL in seconds (default: 6 hours)\n    pub cache_ttl_secs: u64,\n}\n\nimpl Default for SecurityConfig {\n    fn default() -> Self {\n        Self {\n            enabled: true,\n            show_in_hints: true,\n            show_diagnostics: true,\n            min_severity: \"low\".to_string(),\n            cache_ttl_secs: DEFAULT_VULN_CACHE_TTL_SECS,\n        }\n    }\n}\n\nimpl SecurityConfig {\n    /// Parse minimum severity level to VulnerabilitySeverity\n    pub fn min_severity_level(&self) -> crate::registries::VulnerabilitySeverity {\n        crate::registries::VulnerabilitySeverity::from_str_loose(&self.min_severity)\n    }\n}\n\nimpl Config {\n    /// Parse configuration from initialization options\n    pub fn from_init_options(options: Option<serde_json::Value>) -> Self {\n        match options {\n            Some(value) => serde_json::from_value(value).unwrap_or_default(),\n            None => Self::default(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_default_config() {\n        let config = Config::default();\n        assert!(config.inlay_hints.enabled);\n        assert!(config.inlay_hints.show_up_to_date);\n        assert!(config.diagnostics.enabled);\n        assert_eq!(config.cache.ttl_secs, DEFAULT_CACHE_TTL_SECS);\n        assert!(config.ignore.is_empty());\n    }\n\n    #[test]\n    fn test_parse_from_json() {\n        let json = json!({\n            \"inlay_hints\": {\n                \"enabled\": false,\n                \"show_up_to_date\": false\n            },\n            \"diagnostics\": {\n                \"enabled\": false\n            },\n            \"cache\": {\n                \"ttl_secs\": 7200\n            },\n            \"ignore\": [\"test-*\", \"internal-pkg\"]\n        });\n\n        let config = Config::from_init_options(Some(json));\n        assert!(!config.inlay_hints.enabled);\n        assert!(!config.inlay_hints.show_up_to_date);\n        assert!(!config.diagnostics.enabled);\n        assert_eq!(config.cache.ttl_secs, 7200);\n        assert_eq!(config.ignore.len(), 2);\n    }\n\n    #[test]\n    fn test_partial_config() {\n        let json = json!({\n            \"inlay_hints\": {\n                \"enabled\": false\n            }\n        });\n\n        let config = Config::from_init_options(Some(json));\n        assert!(!config.inlay_hints.enabled);\n        // Other fields should use defaults\n        assert!(config.inlay_hints.show_up_to_date);\n        assert!(config.diagnostics.enabled);\n    }\n\n    #[test]\n    fn test_security_config_defaults() {\n        let config = SecurityConfig::default();\n        assert!(config.enabled);\n        assert!(config.show_in_hints);\n        assert!(config.show_diagnostics);\n        assert_eq!(config.min_severity, \"low\");\n        assert_eq!(config.cache_ttl_secs, DEFAULT_VULN_CACHE_TTL_SECS);\n    }\n\n    #[test]\n    fn test_security_config_from_json() {\n        let json = json!({\n            \"security\": {\n                \"enabled\": false,\n                \"show_in_hints\": false,\n                \"show_diagnostics\": false,\n                \"min_severity\": \"high\",\n                \"cache_ttl_secs\": 3600\n            }\n        });\n\n        let config = Config::from_init_options(Some(json));\n        assert!(!config.security.enabled);\n        assert!(!config.security.show_in_hints);\n        assert!(!config.security.show_diagnostics);\n        assert_eq!(config.security.min_severity, \"high\");\n        assert_eq!(config.security.cache_ttl_secs, 3600);\n    }\n\n    #[test]\n    fn test_min_severity_level_parsing() {\n        use crate::registries::VulnerabilitySeverity;\n\n        let config = SecurityConfig {\n            min_severity: \"low\".to_string(),\n            ..Default::default()\n        };\n        assert_eq!(config.min_severity_level(), VulnerabilitySeverity::Low);\n\n        let config = SecurityConfig {\n            min_severity: \"medium\".to_string(),\n            ..Default::default()\n        };\n        assert_eq!(config.min_severity_level(), VulnerabilitySeverity::Medium);\n\n        let config = SecurityConfig {\n            min_severity: \"high\".to_string(),\n            ..Default::default()\n        };\n        assert_eq!(config.min_severity_level(), VulnerabilitySeverity::High);\n\n        let config = SecurityConfig {\n            min_severity: \"critical\".to_string(),\n            ..Default::default()\n        };\n        assert_eq!(config.min_severity_level(), VulnerabilitySeverity::Critical);\n    }\n\n    #[test]\n    fn test_from_init_options_none() {\n        let config = Config::from_init_options(None);\n        assert!(config.inlay_hints.enabled);\n        assert!(config.diagnostics.enabled);\n    }\n\n    #[test]\n    fn test_from_init_options_invalid_json() {\n        let json = json!(\"invalid\");\n        let config = Config::from_init_options(Some(json));\n        assert!(config.inlay_hints.enabled);\n    }\n\n    #[test]\n    fn test_cache_config_defaults() {\n        let config = CacheConfig::default();\n        assert_eq!(config.ttl_secs, DEFAULT_CACHE_TTL_SECS);\n    }\n\n    #[test]\n    fn test_diagnostics_config_defaults() {\n        let config = DiagnosticsConfig::default();\n        assert!(config.enabled);\n    }\n\n    #[test]\n    fn test_inlay_hints_config_defaults() {\n        let config = InlayHintsConfig::default();\n        assert!(config.enabled);\n        assert!(config.show_up_to_date);\n    }\n}\n","traces":[{"line":39,"address":[15088928],"length":1,"stats":{"Line":2}},{"line":55,"address":[29957150],"length":1,"stats":{"Line":7}},{"line":69,"address":[29957152],"length":1,"stats":{"Line":2}},{"line":93,"address":[25956385],"length":1,"stats":{"Line":0}},{"line":94,"address":[13714720],"length":1,"stats":{"Line":2}},{"line":99,"address":[13714733],"length":1,"stats":{"Line":2}},{"line":105,"address":[29956485,29956480],"length":1,"stats":{"Line":0}},{"line":107,"address":[13683120],"length":1,"stats":{"Line":2}},{"line":108,"address":[13385445],"length":1,"stats":{"Line":2}},{"line":114,"address":[13683152],"length":1,"stats":{"Line":3}},{"line":115,"address":[13683173],"length":1,"stats":{"Line":4}},{"line":116,"address":[13683199],"length":1,"stats":{"Line":2}},{"line":117,"address":[13683273],"length":1,"stats":{"Line":2}}],"covered":11,"coverable":13},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","document.rs"],"content":"//! Document state and parsing logic\n//!\n//! This module handles document state management and dependency parsing\n//! for different file types.\n\nuse crate::file_types::FileType;\nuse crate::parsers::Dependency;\n\n/// State of a parsed dependency document.\n///\n/// Stores the parsed dependencies and detected file type for a document\n/// that has been opened in the editor.\npub struct DocumentState {\n    /// List of dependencies extracted from the document.\n    pub dependencies: Vec<Dependency>,\n    /// The detected file type (determines which parser/registry to use).\n    pub file_type: FileType,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","file_types.rs"],"content":"//! File type detection and ecosystem mapping\n//!\n//! This module handles detection of dependency file types from URIs\n//! and provides mappings to ecosystems and cache keys.\n\nuse tower_lsp::lsp_types::Url;\n\nuse crate::vulnerabilities::Ecosystem;\n\n/// Supported dependency file types.\n///\n/// Each variant corresponds to a specific package manager ecosystem\n/// and determines which parser and registry client to use.\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum FileType {\n    /// Rust packages (Cargo.toml)\n    Cargo,\n    /// JavaScript/Node.js packages (package.json)\n    Npm,\n    /// Python packages (requirements.txt, pyproject.toml)\n    Python,\n    /// Go modules (go.mod)\n    Go,\n    /// PHP packages (composer.json)\n    Php,\n    /// Dart/Flutter packages (pubspec.yaml)\n    Dart,\n    /// C#/.NET packages (*.csproj)\n    Csharp,\n    /// Ruby gems (Gemfile)\n    Ruby,\n}\n\nimpl FileType {\n    /// Detect the file type from a document URI.\n    ///\n    /// Returns `Some(FileType)` if the URI matches a known dependency file pattern,\n    /// or `None` if the file type is not recognized.\n    pub fn detect(uri: &Url) -> Option<Self> {\n        let path = uri.path();\n        if path.ends_with(\"Cargo.toml\") {\n            Some(FileType::Cargo)\n        } else if path.ends_with(\"package.json\") {\n            Some(FileType::Npm)\n        } else if path.ends_with(\"requirements.txt\")\n            || path.ends_with(\"requirements-dev.txt\")\n            || path.ends_with(\"requirements-test.txt\")\n            || path.ends_with(\"pyproject.toml\")\n        {\n            Some(FileType::Python)\n        } else if path.ends_with(\"go.mod\") {\n            Some(FileType::Go)\n        } else if path.ends_with(\"composer.json\") {\n            Some(FileType::Php)\n        } else if path.ends_with(\"pubspec.yaml\") {\n            Some(FileType::Dart)\n        } else if path.ends_with(\".csproj\") {\n            Some(FileType::Csharp)\n        } else if path.ends_with(\"Gemfile\") {\n            Some(FileType::Ruby)\n        } else {\n            None\n        }\n    }\n\n    /// Convert to the corresponding vulnerability ecosystem identifier.\n    ///\n    /// Used for querying the OSV.dev API with the correct ecosystem.\n    pub fn to_ecosystem(self) -> Ecosystem {\n        match self {\n            FileType::Cargo => Ecosystem::CratesIo,\n            FileType::Npm => Ecosystem::Npm,\n            FileType::Python => Ecosystem::PyPI,\n            FileType::Go => Ecosystem::Go,\n            FileType::Php => Ecosystem::Packagist,\n            FileType::Dart => Ecosystem::Pub,\n            FileType::Csharp => Ecosystem::NuGet,\n            FileType::Ruby => Ecosystem::RubyGems,\n        }\n    }\n\n    /// Generate a cache key for a package.\n    ///\n    /// The cache key includes the registry prefix (e.g., \"crates:\", \"npm:\")\n    /// to avoid collisions between packages with the same name in different ecosystems.\n    pub fn cache_key(self, package_name: &str) -> String {\n        match self {\n            FileType::Cargo => format!(\"crates:{}\", package_name),\n            FileType::Npm => format!(\"npm:{}\", package_name),\n            FileType::Python => format!(\"pypi:{}\", package_name),\n            FileType::Go => format!(\"go:{}\", package_name),\n            FileType::Php => format!(\"packagist:{}\", package_name),\n            FileType::Dart => format!(\"pub:{}\", package_name),\n            FileType::Csharp => format!(\"nuget:{}\", package_name),\n            FileType::Ruby => format!(\"rubygems:{}\", package_name),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_detect_cargo() {\n        let uri = Url::parse(\"file:///project/Cargo.toml\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Cargo));\n    }\n\n    #[test]\n    fn test_detect_npm() {\n        let uri = Url::parse(\"file:///project/package.json\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Npm));\n    }\n\n    #[test]\n    fn test_detect_python_requirements() {\n        let uri = Url::parse(\"file:///project/requirements.txt\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Python));\n\n        let uri = Url::parse(\"file:///project/requirements-dev.txt\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Python));\n    }\n\n    #[test]\n    fn test_detect_pyproject() {\n        let uri = Url::parse(\"file:///project/pyproject.toml\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Python));\n    }\n\n    #[test]\n    fn test_detect_go() {\n        let uri = Url::parse(\"file:///project/go.mod\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Go));\n    }\n\n    #[test]\n    fn test_detect_php() {\n        let uri = Url::parse(\"file:///project/composer.json\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Php));\n    }\n\n    #[test]\n    fn test_detect_dart() {\n        let uri = Url::parse(\"file:///project/pubspec.yaml\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Dart));\n    }\n\n    #[test]\n    fn test_detect_csharp() {\n        let uri = Url::parse(\"file:///project/MyProject.csproj\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Csharp));\n    }\n\n    #[test]\n    fn test_detect_ruby() {\n        let uri = Url::parse(\"file:///project/Gemfile\").unwrap();\n        assert_eq!(FileType::detect(&uri), Some(FileType::Ruby));\n    }\n\n    #[test]\n    fn test_detect_unknown() {\n        let uri = Url::parse(\"file:///project/unknown.txt\").unwrap();\n        assert_eq!(FileType::detect(&uri), None);\n    }\n\n    #[test]\n    fn test_to_ecosystem() {\n        assert_eq!(FileType::Cargo.to_ecosystem(), Ecosystem::CratesIo);\n        assert_eq!(FileType::Npm.to_ecosystem(), Ecosystem::Npm);\n        assert_eq!(FileType::Python.to_ecosystem(), Ecosystem::PyPI);\n        assert_eq!(FileType::Go.to_ecosystem(), Ecosystem::Go);\n        assert_eq!(FileType::Php.to_ecosystem(), Ecosystem::Packagist);\n        assert_eq!(FileType::Dart.to_ecosystem(), Ecosystem::Pub);\n        assert_eq!(FileType::Csharp.to_ecosystem(), Ecosystem::NuGet);\n        assert_eq!(FileType::Ruby.to_ecosystem(), Ecosystem::RubyGems);\n    }\n\n    #[test]\n    fn test_cache_key() {\n        assert_eq!(FileType::Cargo.cache_key(\"serde\"), \"crates:serde\");\n        assert_eq!(FileType::Npm.cache_key(\"lodash\"), \"npm:lodash\");\n        assert_eq!(FileType::Python.cache_key(\"requests\"), \"pypi:requests\");\n        assert_eq!(\n            FileType::Go.cache_key(\"github.com/gin-gonic/gin\"),\n            \"go:github.com/gin-gonic/gin\"\n        );\n    }\n}\n","traces":[{"line":39,"address":[12953488],"length":1,"stats":{"Line":4}},{"line":40,"address":[14315913],"length":1,"stats":{"Line":4}},{"line":41,"address":[14316006,14315945],"length":1,"stats":{"Line":6}},{"line":42,"address":[12953585],"length":1,"stats":{"Line":2}},{"line":43,"address":[14316050,14315977],"length":1,"stats":{"Line":5}},{"line":44,"address":[14334333],"length":1,"stats":{"Line":2}},{"line":45,"address":[19256325,19256398],"length":1,"stats":{"Line":6}},{"line":46,"address":[19256369],"length":1,"stats":{"Line":4}},{"line":47,"address":[14334397],"length":1,"stats":{"Line":6}},{"line":48,"address":[14334429],"length":1,"stats":{"Line":2}},{"line":50,"address":[14334377],"length":1,"stats":{"Line":2}},{"line":51,"address":[12953818,12953757],"length":1,"stats":{"Line":7}},{"line":52,"address":[14334517],"length":1,"stats":{"Line":2}},{"line":53,"address":[14334566,14334493],"length":1,"stats":{"Line":5}},{"line":54,"address":[14316273],"length":1,"stats":{"Line":2}},{"line":55,"address":[12953833,12953903],"length":1,"stats":{"Line":5}},{"line":56,"address":[14334602],"length":1,"stats":{"Line":2}},{"line":57,"address":[19256594,19256664],"length":1,"stats":{"Line":5}},{"line":58,"address":[14316355],"length":1,"stats":{"Line":2}},{"line":59,"address":[14334655,14334619],"length":1,"stats":{"Line":5}},{"line":60,"address":[12953953],"length":1,"stats":{"Line":2}},{"line":62,"address":[14334650],"length":1,"stats":{"Line":2}},{"line":69,"address":[19256096],"length":1,"stats":{"Line":2}},{"line":70,"address":[14334087],"length":1,"stats":{"Line":2}},{"line":71,"address":[12953414],"length":1,"stats":{"Line":2}},{"line":72,"address":[12953421],"length":1,"stats":{"Line":2}},{"line":73,"address":[14315844],"length":1,"stats":{"Line":2}},{"line":74,"address":[14315851],"length":1,"stats":{"Line":2}},{"line":75,"address":[14315858],"length":1,"stats":{"Line":2}},{"line":76,"address":[14334153],"length":1,"stats":{"Line":2}},{"line":77,"address":[12953456],"length":1,"stats":{"Line":2}},{"line":78,"address":[14334167],"length":1,"stats":{"Line":2}},{"line":86,"address":[12953968],"length":1,"stats":{"Line":2}},{"line":87,"address":[14334709],"length":1,"stats":{"Line":2}},{"line":88,"address":[12954036],"length":1,"stats":{"Line":2}},{"line":89,"address":[14316572],"length":1,"stats":{"Line":2}},{"line":90,"address":[12954294],"length":1,"stats":{"Line":2}},{"line":91,"address":[14316848],"length":1,"stats":{"Line":2}},{"line":92,"address":[14316986],"length":1,"stats":{"Line":0}},{"line":93,"address":[14317124],"length":1,"stats":{"Line":0}},{"line":94,"address":[14317262],"length":1,"stats":{"Line":0}},{"line":95,"address":[14317400],"length":1,"stats":{"Line":0}}],"covered":38,"coverable":42},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","lib.rs"],"content":"//! Dependi LSP - Language Server for dependency management\n//!\n//! This crate provides a Language Server Protocol implementation for\n//! managing dependencies in various package managers (Cargo, npm, etc.)\n\npub mod backend;\npub mod cache;\npub mod config;\npub mod document;\npub mod file_types;\npub mod parsers;\npub mod providers;\npub mod registries;\npub mod reports;\npub mod utils;\npub mod vulnerabilities;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","main.rs"],"content":"mod backend;\nmod cache;\nmod config;\nmod document;\nmod file_types;\nmod parsers;\nmod providers;\nmod registries;\nmod reports;\nmod utils;\nmod vulnerabilities;\n\nuse std::path::PathBuf;\nuse std::process::ExitCode;\n\nuse clap::{Parser, Subcommand};\nuse tower_lsp::{LspService, Server};\nuse tracing_subscriber::{EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};\n\nuse crate::backend::DependiBackend;\n\n#[derive(Parser)]\n#[command(name = \"dependi-lsp\")]\n#[command(about = \"Language server for dependency management\", long_about = None)]\n#[command(version)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option<Commands>,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Start the LSP server (default behavior)\n    Lsp,\n    /// Scan a file for vulnerabilities and exit with code 1 if found\n    Scan {\n        /// Path to the dependency file to scan\n        #[arg(short, long)]\n        file: PathBuf,\n\n        /// Output format: json, markdown, or summary\n        #[arg(short, long, default_value = \"summary\")]\n        output: String,\n\n        /// Minimum severity level to report (low, medium, high, critical)\n        #[arg(short, long, default_value = \"low\")]\n        min_severity: String,\n\n        /// Exit with code 1 if vulnerabilities are found\n        #[arg(long, default_value = \"true\")]\n        fail_on_vulns: bool,\n    },\n}\n\n#[tokio::main]\nasync fn main() -> ExitCode {\n    let cli = Cli::parse();\n\n    // Initialize tracing\n    tracing_subscriber::registry()\n        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\")))\n        .with(tracing_subscriber::fmt::layer().with_writer(std::io::stderr))\n        .init();\n\n    match cli.command {\n        Some(Commands::Scan {\n            file,\n            output,\n            min_severity,\n            fail_on_vulns,\n        }) => run_scan(file, output, min_severity, fail_on_vulns).await,\n        Some(Commands::Lsp) | None => {\n            run_lsp().await;\n            ExitCode::SUCCESS\n        }\n    }\n}\n\nasync fn run_lsp() {\n    tracing::info!(\"Starting Dependi LSP server\");\n\n    let stdin = tokio::io::stdin();\n    let stdout = tokio::io::stdout();\n\n    let (service, socket) = LspService::new(DependiBackend::new);\n    Server::new(stdin, stdout, socket).serve(service).await;\n}\n\nasync fn run_scan(\n    file: PathBuf,\n    output: String,\n    min_severity: String,\n    fail_on_vulns: bool,\n) -> ExitCode {\n    use crate::parsers::{\n        Parser, cargo::CargoParser, csharp::CsharpParser, dart::DartParser, go::GoParser,\n        npm::NpmParser, php::PhpParser, python::PythonParser,\n    };\n    use crate::registries::VulnerabilitySeverity;\n    use crate::vulnerabilities::{Ecosystem, VulnerabilityQuery, osv::OsvClient};\n\n    // Read file (using async I/O)\n    let content = match tokio::fs::read_to_string(&file).await {\n        Ok(c) => c,\n        Err(e) => {\n            eprintln!(\"Error reading file: {}\", e);\n            return ExitCode::FAILURE;\n        }\n    };\n\n    let file_name = file.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n\n    // Detect file type and parse\n    let (dependencies, ecosystem) = if file_name == \"Cargo.toml\" {\n        (CargoParser::new().parse(&content), Ecosystem::CratesIo)\n    } else if file_name == \"package.json\" {\n        (NpmParser::new().parse(&content), Ecosystem::Npm)\n    } else if file_name == \"requirements.txt\" || file_name == \"pyproject.toml\" {\n        (PythonParser::new().parse(&content), Ecosystem::PyPI)\n    } else if file_name == \"go.mod\" {\n        (GoParser::new().parse(&content), Ecosystem::Go)\n    } else if file_name == \"composer.json\" {\n        (PhpParser::new().parse(&content), Ecosystem::Packagist)\n    } else if file_name == \"pubspec.yaml\" {\n        (DartParser::new().parse(&content), Ecosystem::Pub)\n    } else if file_name.ends_with(\".csproj\") {\n        (CsharpParser::new().parse(&content), Ecosystem::NuGet)\n    } else {\n        eprintln!(\"Unsupported file type: {}\", file_name);\n        return ExitCode::FAILURE;\n    };\n\n    if dependencies.is_empty() {\n        println!(\"No dependencies found in {}\", file.display());\n        return ExitCode::SUCCESS;\n    }\n\n    eprintln!(\n        \"Scanning {} dependencies in {}...\",\n        dependencies.len(),\n        file.display()\n    );\n\n    // Build vulnerability queries\n    let queries: Vec<VulnerabilityQuery> = dependencies\n        .iter()\n        .map(|dep| VulnerabilityQuery {\n            ecosystem,\n            package_name: dep.name.clone(),\n            version: dep.version.clone(),\n        })\n        .collect();\n\n    // Query OSV.dev\n    let osv_client = OsvClient::default();\n    let results = match osv_client.query_batch(&queries).await {\n        Ok(r) => r,\n        Err(e) => {\n            eprintln!(\"Error querying OSV.dev: {}\", e);\n            return ExitCode::FAILURE;\n        }\n    };\n\n    // Parse minimum severity using shared method\n    let min_sev = VulnerabilitySeverity::from_str_loose(&min_severity);\n\n    // Filter and collect vulnerabilities\n    let mut total_vulns = 0;\n    let mut critical_count = 0;\n    let mut high_count = 0;\n    let mut medium_count = 0;\n    let mut low_count = 0;\n    let mut vuln_details: Vec<serde_json::Value> = Vec::new();\n\n    for (dep, result) in dependencies.iter().zip(results.iter()) {\n        for vuln in &result.vulnerabilities {\n            // Filter by severity using shared method\n            if !vuln.severity.meets_threshold(&min_sev) {\n                continue;\n            }\n\n            total_vulns += 1;\n            match vuln.severity {\n                VulnerabilitySeverity::Critical => critical_count += 1,\n                VulnerabilitySeverity::High => high_count += 1,\n                VulnerabilitySeverity::Medium => medium_count += 1,\n                VulnerabilitySeverity::Low => low_count += 1,\n            }\n\n            vuln_details.push(serde_json::json!({\n                \"package\": dep.name,\n                \"version\": dep.version,\n                \"id\": vuln.id,\n                \"severity\": vuln.severity.as_str(),\n                \"description\": vuln.description,\n                \"url\": vuln.url\n            }));\n        }\n    }\n\n    // Output results\n    match output.as_str() {\n        \"json\" => {\n            let report = serde_json::json!({\n                \"file\": file.display().to_string(),\n                \"summary\": {\n                    \"total\": total_vulns,\n                    \"critical\": critical_count,\n                    \"high\": high_count,\n                    \"medium\": medium_count,\n                    \"low\": low_count\n                },\n                \"vulnerabilities\": vuln_details\n            });\n            println!(\"{}\", serde_json::to_string_pretty(&report).unwrap());\n        }\n        \"markdown\" => {\n            println!(\"# Vulnerability Report\\n\");\n            println!(\"**File**: {}\", file.display());\n            println!(\"**Date**: {}\\n\", chrono::Local::now().format(\"%Y-%m-%d\"));\n            println!(\"## Summary\\n\");\n            println!(\"| Severity | Count |\");\n            println!(\"|----------|-------|\");\n            println!(\"| ⚠ Critical | {} |\", critical_count);\n            println!(\"| ▲ High | {} |\", high_count);\n            println!(\"| ● Medium | {} |\", medium_count);\n            println!(\"| ○ Low | {} |\", low_count);\n            println!(\"| **Total** | **{}** |\\n\", total_vulns);\n\n            if !vuln_details.is_empty() {\n                println!(\"## Vulnerabilities\\n\");\n                for vuln in &vuln_details {\n                    let severity_icon = match vuln[\"severity\"].as_str().unwrap_or(\"low\") {\n                        \"critical\" => \"⚠\",\n                        \"high\" => \"▲\",\n                        \"medium\" => \"●\",\n                        _ => \"○\",\n                    };\n                    println!(\n                        \"### {}@{}\\n\",\n                        vuln[\"package\"].as_str().unwrap_or(\"\"),\n                        vuln[\"version\"].as_str().unwrap_or(\"\")\n                    );\n                    if let Some(url) = vuln[\"url\"].as_str() {\n                        println!(\n                            \"- **[{}]({})** ({} {}): {}\",\n                            vuln[\"id\"].as_str().unwrap_or(\"\"),\n                            url,\n                            severity_icon,\n                            vuln[\"severity\"].as_str().unwrap_or(\"\").to_uppercase(),\n                            vuln[\"description\"].as_str().unwrap_or(\"\")\n                        );\n                    } else {\n                        println!(\n                            \"- **{}** ({} {}): {}\",\n                            vuln[\"id\"].as_str().unwrap_or(\"\"),\n                            severity_icon,\n                            vuln[\"severity\"].as_str().unwrap_or(\"\").to_uppercase(),\n                            vuln[\"description\"].as_str().unwrap_or(\"\")\n                        );\n                    }\n                    println!();\n                }\n            }\n        }\n        _ => {\n            // Summary format\n            println!(\"Vulnerability Scan Results for {}\\n\", file.display());\n            println!(\"  ⚠ Critical: {}\", critical_count);\n            println!(\"  ▲ High:     {}\", high_count);\n            println!(\"  ● Medium:   {}\", medium_count);\n            println!(\"  ○ Low:      {}\", low_count);\n            println!(\"  ─────────────\");\n            println!(\"  Total:      {}\\n\", total_vulns);\n\n            if total_vulns == 0 {\n                println!(\"[OK] No vulnerabilities found!\");\n            } else {\n                println!(\"⚠ {} vulnerabilities found!\", total_vulns);\n            }\n        }\n    }\n\n    // Exit code\n    if fail_on_vulns && total_vulns > 0 {\n        ExitCode::FAILURE\n    } else {\n        ExitCode::SUCCESS\n    }\n}\n","traces":[{"line":56,"address":[20310736,20311126,20311132],"length":1,"stats":{"Line":0}},{"line":57,"address":[15530587],"length":1,"stats":{"Line":0}},{"line":60,"address":[15530908,15531042,15530743],"length":1,"stats":{"Line":0}},{"line":61,"address":[15530813,15530840,15530778,15530940,15531577,15532224,15532240],"length":1,"stats":{"Line":0}},{"line":62,"address":[15530978,15530971,15531543,15531071],"length":1,"stats":{"Line":0}},{"line":65,"address":[15531169],"length":1,"stats":{"Line":0}},{"line":66,"address":[15531630,15530653,15531488,15531391],"length":1,"stats":{"Line":0}},{"line":73,"address":[15531246,15531414,15531854,15530668],"length":1,"stats":{"Line":0}},{"line":74,"address":[15531990],"length":1,"stats":{"Line":0}},{"line":79,"address":[15532496,15532336,15532361,15533649,15533868,15532454],"length":1,"stats":{"Line":0}},{"line":80,"address":[15532542,15532401,15532756],"length":1,"stats":{"Line":0}},{"line":82,"address":[15532734],"length":1,"stats":{"Line":0}},{"line":83,"address":[15532987],"length":1,"stats":{"Line":0}},{"line":85,"address":[15533136,15533067],"length":1,"stats":{"Line":0}},{"line":86,"address":[15533680,15533246,15532481,15533484],"length":1,"stats":{"Line":0}},{"line":89,"address":[20311184],"length":1,"stats":{"Line":0}},{"line":103,"address":[15356940],"length":1,"stats":{"Line":0}},{"line":104,"address":[15534888],"length":1,"stats":{"Line":0}},{"line":105,"address":[15534826],"length":1,"stats":{"Line":0}},{"line":106,"address":[15534850,15538009],"length":1,"stats":{"Line":0}},{"line":107,"address":[15538078],"length":1,"stats":{"Line":0}},{"line":111,"address":[15550640,15550654,15535044,15534950],"length":1,"stats":{"Line":0}},{"line":114,"address":[15536898,15535221,15536005],"length":1,"stats":{"Line":0}},{"line":115,"address":[15535306,15536773],"length":1,"stats":{"Line":0}},{"line":116,"address":[15536760,15535274,15535323],"length":1,"stats":{"Line":0}},{"line":117,"address":[15535369,15536635],"length":1,"stats":{"Line":0}},{"line":118,"address":[15535337,15535386,15535449,15536622],"length":1,"stats":{"Line":0}},{"line":119,"address":[15536497,15535432],"length":1,"stats":{"Line":0}},{"line":120,"address":[15536484,15535463],"length":1,"stats":{"Line":0}},{"line":121,"address":[15536359,15535548],"length":1,"stats":{"Line":0}},{"line":122,"address":[15535516,15536346,15535565],"length":1,"stats":{"Line":0}},{"line":123,"address":[15535611,15536221],"length":1,"stats":{"Line":0}},{"line":124,"address":[15535579,15535628,15536208],"length":1,"stats":{"Line":0}},{"line":125,"address":[15535686,15536083],"length":1,"stats":{"Line":0}},{"line":126,"address":[15535642,15535703],"length":1,"stats":{"Line":0}},{"line":127,"address":[15535751,15535872],"length":1,"stats":{"Line":0}},{"line":129,"address":[15535717,15535758],"length":1,"stats":{"Line":0}},{"line":130,"address":[15535827],"length":1,"stats":{"Line":0}},{"line":133,"address":[15536058,15536957],"length":1,"stats":{"Line":0}},{"line":134,"address":[15537001,15537777],"length":1,"stats":{"Line":0}},{"line":135,"address":[15537932],"length":1,"stats":{"Line":0}},{"line":138,"address":[15537055],"length":1,"stats":{"Line":0}},{"line":145,"address":[15537320,15537443],"length":1,"stats":{"Line":0}},{"line":147,"address":[15550615,15537413,15550416,15550548,15550609],"length":1,"stats":{"Line":0}},{"line":148,"address":[15550452],"length":1,"stats":{"Line":0}},{"line":149,"address":[15550461],"length":1,"stats":{"Line":0}},{"line":150,"address":[15550490],"length":1,"stats":{"Line":0}},{"line":155,"address":[15537473],"length":1,"stats":{"Line":0}},{"line":156,"address":[15356961],"length":1,"stats":{"Line":0}},{"line":157,"address":[15538446],"length":1,"stats":{"Line":0}},{"line":158,"address":[15538388],"length":1,"stats":{"Line":0}},{"line":159,"address":[15538412,15550212],"length":1,"stats":{"Line":0}},{"line":160,"address":[15550281],"length":1,"stats":{"Line":0}},{"line":165,"address":[15538510,15538593],"length":1,"stats":{"Line":0}},{"line":168,"address":[15538621],"length":1,"stats":{"Line":0}},{"line":169,"address":[15538632],"length":1,"stats":{"Line":0}},{"line":170,"address":[15538643],"length":1,"stats":{"Line":0}},{"line":171,"address":[15538654],"length":1,"stats":{"Line":0}},{"line":172,"address":[15538665],"length":1,"stats":{"Line":0}},{"line":173,"address":[15538676],"length":1,"stats":{"Line":0}},{"line":175,"address":[15538703,15538793],"length":1,"stats":{"Line":0}},{"line":176,"address":[15539148,15547851],"length":1,"stats":{"Line":0}},{"line":178,"address":[15547956],"length":1,"stats":{"Line":0}},{"line":182,"address":[15547989,15548053],"length":1,"stats":{"Line":0}},{"line":183,"address":[15548023],"length":1,"stats":{"Line":0}},{"line":184,"address":[15548133,15548275],"length":1,"stats":{"Line":0}},{"line":185,"address":[15548241,15548113],"length":1,"stats":{"Line":0}},{"line":186,"address":[15548207,15548093],"length":1,"stats":{"Line":0}},{"line":187,"address":[15548161,15548073],"length":1,"stats":{"Line":0}},{"line":190,"address":[15548196,15549215,15549776,15548963,15549450,15548343,15548641,15548305,15549297,15549521,15548712,15549147,15549705,15548413,15548896],"length":1,"stats":{"Line":0}},{"line":194,"address":[15549195,15549265],"length":1,"stats":{"Line":0}},{"line":202,"address":[15539182],"length":1,"stats":{"Line":0}},{"line":203,"address":[15539247],"length":1,"stats":{"Line":0}},{"line":204,"address":[15545276,15539336,15545134,15544569,15544641,15544761,15544531,15544788,15545210,15545504,15545079,15546067,15546251,15546317,15546647,15546713,15547636,15545567,15545751,15545817,15546001],"length":1,"stats":{"Line":0}},{"line":205,"address":[15544620,15544695],"length":1,"stats":{"Line":0}},{"line":215,"address":[15546947,15546998],"length":1,"stats":{"Line":0}},{"line":217,"address":[15539302,15539353],"length":1,"stats":{"Line":0}},{"line":218,"address":[15540348,15539394],"length":1,"stats":{"Line":0}},{"line":219,"address":[15540375],"length":1,"stats":{"Line":0}},{"line":220,"address":[15540573],"length":1,"stats":{"Line":0}},{"line":221,"address":[15540782],"length":1,"stats":{"Line":0}},{"line":222,"address":[15540827],"length":1,"stats":{"Line":0}},{"line":223,"address":[15540872],"length":1,"stats":{"Line":0}},{"line":224,"address":[15540925],"length":1,"stats":{"Line":0}},{"line":225,"address":[15541029],"length":1,"stats":{"Line":0}},{"line":226,"address":[15541133],"length":1,"stats":{"Line":0}},{"line":227,"address":[15541237],"length":1,"stats":{"Line":0}},{"line":228,"address":[15541341],"length":1,"stats":{"Line":0}},{"line":230,"address":[15541445],"length":1,"stats":{"Line":0}},{"line":231,"address":[15541476],"length":1,"stats":{"Line":0}},{"line":232,"address":[15541521],"length":1,"stats":{"Line":0}},{"line":233,"address":[15541690],"length":1,"stats":{"Line":0}},{"line":234,"address":[15541933,15541852],"length":1,"stats":{"Line":0}},{"line":235,"address":[15541907,15542020,15541972],"length":1,"stats":{"Line":0}},{"line":236,"address":[15542091,15541994,15542056],"length":1,"stats":{"Line":0}},{"line":237,"address":[15542062],"length":1,"stats":{"Line":0}},{"line":239,"address":[15542285],"length":1,"stats":{"Line":0}},{"line":244,"address":[15542607],"length":1,"stats":{"Line":0}},{"line":245,"address":[15543348,15543179],"length":1,"stats":{"Line":0}},{"line":254,"address":[15542821,15543740],"length":1,"stats":{"Line":0}},{"line":262,"address":[15543703,15544507],"length":1,"stats":{"Line":0}},{"line":268,"address":[15539367,15539439],"length":1,"stats":{"Line":0}},{"line":269,"address":[15539602],"length":1,"stats":{"Line":0}},{"line":270,"address":[15539706],"length":1,"stats":{"Line":0}},{"line":271,"address":[15539810],"length":1,"stats":{"Line":0}},{"line":272,"address":[15539914],"length":1,"stats":{"Line":0}},{"line":273,"address":[15540010],"length":1,"stats":{"Line":0}},{"line":274,"address":[15540063],"length":1,"stats":{"Line":0}},{"line":276,"address":[15540159],"length":1,"stats":{"Line":0}},{"line":277,"address":[15540230,15540169],"length":1,"stats":{"Line":0}},{"line":279,"address":[15540277,15540203],"length":1,"stats":{"Line":0}},{"line":285,"address":[15540259,15547222],"length":1,"stats":{"Line":0}},{"line":286,"address":[15547234],"length":1,"stats":{"Line":0}},{"line":288,"address":[15547214],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":114},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","cargo.rs"],"content":"//! Parser for Cargo.toml files using structured TOML parsing\n\nuse super::{Dependency, Parser};\nuse taplo::dom::Node;\nuse taplo::parser::parse;\n\n/// Parser for Rust Cargo.toml dependency files\n#[derive(Debug, Default)]\npub struct CargoParser;\n\nimpl CargoParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for CargoParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        let parsed = parse(content);\n\n        // If there are critical parse errors, return empty\n        if parsed.errors.iter().any(|e| e.message.contains(\"expected\")) {\n            return Vec::new();\n        }\n\n        let dom = parsed.into_dom();\n\n        let mut dependencies = Vec::new();\n\n        // Define dependency sections to parse: (section_name, is_dev)\n        let sections = [\n            (\"dependencies\", false),\n            (\"dev-dependencies\", true),\n            (\"build-dependencies\", false),\n        ];\n\n        for (section_name, is_dev) in sections {\n            // Parse regular section dependencies (e.g., [dependencies])\n            if let Some(section) = dom.get(section_name).as_table() {\n                let entries = section.entries().read();\n                for (key, value) in entries.iter() {\n                    let name = key.value().to_string();\n                    if let Some(dep) = parse_dependency(&name, value, content, is_dev) {\n                        dependencies.push(dep);\n                    }\n                }\n            }\n\n            // Parse table-style dependencies (e.g., [dependencies.reqwest])\n            let pattern = format!(\"{}.*\", section_name);\n            if let Ok(keys) = pattern.parse::<taplo::dom::Keys>()\n                && let Ok(matches) = dom.find_all_matches(keys, false)\n            {\n                for (key_path, node) in matches {\n                    // Extract the dependency name from the key path\n                    let key_str = key_path.to_string();\n                    let name = key_str\n                        .split('.')\n                        .next_back()\n                        .unwrap_or(&key_str)\n                        .to_string();\n\n                    // For table dependencies, look for the version key\n                    if let Some(table) = node.as_table()\n                        && let Some(version_node) = table.get(\"version\")\n                        && let Some(version_str) = version_node.as_str()\n                    {\n                        let version = version_str.value().to_string();\n                        let optional = table\n                            .get(\"optional\")\n                            .and_then(|n| n.as_bool().map(|b| b.value()))\n                            .unwrap_or(false);\n\n                        if let Some((line, name_start, name_end, version_start, version_end)) =\n                            find_table_dependency_positions(content, &name, &version)\n                        {\n                            dependencies.push(Dependency {\n                                name,\n                                version,\n                                line,\n                                name_start,\n                                name_end,\n                                version_start,\n                                version_end,\n                                dev: is_dev,\n                                optional,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        dependencies\n    }\n}\n\n/// Parse a single dependency from a TOML node\nfn parse_dependency(name: &str, node: &Node, content: &str, is_dev: bool) -> Option<Dependency> {\n    match node {\n        Node::Str(s) => {\n            // Simple dependency: name = \"1.0.0\"\n            let version = s.value().to_string();\n            let (line, name_start, name_end, version_start, version_end) =\n                find_simple_dependency_positions(content, name, &version)?;\n\n            Some(Dependency {\n                name: name.to_string(),\n                version,\n                line,\n                name_start,\n                name_end,\n                version_start,\n                version_end,\n                dev: is_dev,\n                optional: false,\n            })\n        }\n        Node::Table(table) => {\n            // Inline table: name = { version = \"1.0.0\", ... }\n            let version_node = table.get(\"version\")?;\n            let version_str = version_node.as_str()?;\n            let version = version_str.value().to_string();\n\n            let optional = table\n                .get(\"optional\")\n                .and_then(|n| n.as_bool().map(|b| b.value()))\n                .unwrap_or(false);\n\n            let (line, name_start, name_end, version_start, version_end) =\n                find_inline_table_positions(content, name, &version)?;\n\n            Some(Dependency {\n                name: name.to_string(),\n                version,\n                line,\n                name_start,\n                name_end,\n                version_start,\n                version_end,\n                dev: is_dev,\n                optional,\n            })\n        }\n        _ => None,\n    }\n}\n\n/// Find positions for a simple dependency: `name = \"version\"`\nfn find_simple_dependency_positions(\n    content: &str,\n    name: &str,\n    version: &str,\n) -> Option<(u32, u32, u32, u32, u32)> {\n    for (line_idx, line) in content.lines().enumerate() {\n        // Look for pattern: name = \"version\" or name = 'version'\n        let trimmed = line.trim();\n        if !trimmed.starts_with(name) {\n            continue;\n        }\n\n        // Check if this line has the exact name followed by =\n        let after_name = trimmed[name.len()..].trim_start();\n        if !after_name.starts_with('=') {\n            continue;\n        }\n\n        // Check for simple string value (not inline table)\n        let after_eq = after_name[1..].trim_start();\n        if after_eq.starts_with('{') {\n            continue; // This is an inline table, skip\n        }\n\n        // Check if version is in this line\n        if !line.contains(version) {\n            continue;\n        }\n\n        // Calculate positions\n        let name_start = line.find(name)? as u32;\n        let name_end = name_start + name.len() as u32;\n\n        // Find version position (inside quotes)\n        let version_start = line.find(version)? as u32;\n        let version_end = version_start + version.len() as u32;\n\n        return Some((\n            line_idx as u32,\n            name_start,\n            name_end,\n            version_start,\n            version_end,\n        ));\n    }\n    None\n}\n\n/// Find positions for an inline table dependency: `name = { version = \"1.0.0\", ... }`\nfn find_inline_table_positions(\n    content: &str,\n    name: &str,\n    version: &str,\n) -> Option<(u32, u32, u32, u32, u32)> {\n    for (line_idx, line) in content.lines().enumerate() {\n        let trimmed = line.trim();\n        if !trimmed.starts_with(name) {\n            continue;\n        }\n\n        // Check if this line has the name followed by = and {\n        let after_name = trimmed[name.len()..].trim_start();\n        if !after_name.starts_with('=') {\n            continue;\n        }\n\n        let after_eq = after_name[1..].trim_start();\n        if !after_eq.starts_with('{') {\n            continue;\n        }\n\n        // Check if version is in this line\n        if !line.contains(version) {\n            continue;\n        }\n\n        // Calculate positions\n        let name_start = line.find(name)? as u32;\n        let name_end = name_start + name.len() as u32;\n\n        // Find version position (inside quotes after \"version =\")\n        let version_start = line.find(version)? as u32;\n        let version_end = version_start + version.len() as u32;\n\n        return Some((\n            line_idx as u32,\n            name_start,\n            name_end,\n            version_start,\n            version_end,\n        ));\n    }\n    None\n}\n\n/// Find positions for a table dependency: `[dependencies.name]` with `version = \"x.y.z\"`\nfn find_table_dependency_positions(\n    content: &str,\n    name: &str,\n    version: &str,\n) -> Option<(u32, u32, u32, u32, u32)> {\n    let mut found_table = false;\n    let mut name_start = 0u32;\n    let mut name_end = 0u32;\n\n    for (line_idx, line) in content.lines().enumerate() {\n        let trimmed = line.trim();\n\n        // Look for the table header containing the dependency name\n        if trimmed.starts_with('[') && trimmed.ends_with(']') && trimmed.contains(name) {\n            // Check if this is a dependencies table\n            let inner = &trimmed[1..trimmed.len() - 1];\n            if inner.contains(\"dependencies.\") && inner.ends_with(name) {\n                found_table = true;\n                // Name position is in the header after the last dot\n                if let Some(dot_pos) = line.rfind('.') {\n                    name_start = (dot_pos + 1) as u32;\n                    name_end = (line.len() - 1) as u32; // Before the closing ]\n                }\n                continue;\n            }\n        }\n\n        // If we found the table, look for version = \"x.y.z\"\n        if found_table {\n            // Check if we hit a new section\n            if trimmed.starts_with('[') {\n                break;\n            }\n\n            if trimmed.starts_with(\"version\") && line.contains(version) {\n                let version_start = line.find(version)? as u32;\n                let version_end = version_start + version.len() as u32;\n                return Some((\n                    line_idx as u32,\n                    name_start,\n                    name_end,\n                    version_start,\n                    version_end,\n                ));\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_dependency() {\n        let parser = CargoParser::new();\n        let content = r#\"\n[dependencies]\nserde = \"1.0.0\"\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"serde\");\n        assert_eq!(deps[0].version, \"1.0.0\");\n        assert!(!deps[0].dev);\n    }\n\n    #[test]\n    fn test_inline_table_dependency() {\n        let parser = CargoParser::new();\n        let content = r#\"\n[dependencies]\nserde = { version = \"1.0.0\", features = [\"derive\"] }\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"serde\");\n        assert_eq!(deps[0].version, \"1.0.0\");\n    }\n\n    #[test]\n    fn test_dev_dependencies() {\n        let parser = CargoParser::new();\n        let content = r#\"\n[dev-dependencies]\ntokio-test = \"0.4\"\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"tokio-test\");\n        assert!(deps[0].dev);\n    }\n\n    #[test]\n    fn test_multiple_sections() {\n        let parser = CargoParser::new();\n        let content = r#\"\n[package]\nname = \"test\"\n\n[dependencies]\nserde = \"1.0\"\ntokio = { version = \"1.0\", features = [\"full\"] }\n\n[dev-dependencies]\ncriterion = \"0.5\"\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 3);\n\n        let serde = deps.iter().find(|d| d.name == \"serde\").unwrap();\n        assert_eq!(serde.version, \"1.0\");\n        assert!(!serde.dev);\n\n        let tokio = deps.iter().find(|d| d.name == \"tokio\").unwrap();\n        assert_eq!(tokio.version, \"1.0\");\n        assert!(!tokio.dev);\n\n        let criterion = deps.iter().find(|d| d.name == \"criterion\").unwrap();\n        assert_eq!(criterion.version, \"0.5\");\n        assert!(criterion.dev);\n    }\n\n    #[test]\n    fn test_table_dependency() {\n        let parser = CargoParser::new();\n        let content = r#\"\n[dependencies.reqwest]\nversion = \"0.12\"\nfeatures = [\"json\"]\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"reqwest\");\n        assert_eq!(deps[0].version, \"0.12\");\n    }\n\n    #[test]\n    fn test_optional_dependency() {\n        let parser = CargoParser::new();\n        let content = r#\"\n[dependencies]\noptional-dep = { version = \"1.0\", optional = true }\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert!(deps[0].optional);\n    }\n}\n","traces":[{"line":18,"address":[13773568,13775816,13778658],"length":1,"stats":{"Line":6}},{"line":19,"address":[14459109],"length":1,"stats":{"Line":7}},{"line":22,"address":[13024528,13024553],"length":1,"stats":{"Line":10}},{"line":23,"address":[13773983],"length":1,"stats":{"Line":0}},{"line":26,"address":[18570248,18570357],"length":1,"stats":{"Line":10}},{"line":28,"address":[18570381],"length":1,"stats":{"Line":6}},{"line":31,"address":[18570537],"length":1,"stats":{"Line":6}},{"line":32,"address":[12895168],"length":1,"stats":{"Line":6}},{"line":33,"address":[13774127],"length":1,"stats":{"Line":6}},{"line":34,"address":[14459618],"length":1,"stats":{"Line":7}},{"line":37,"address":[12895512,12895598,12895369],"length":1,"stats":{"Line":22}},{"line":39,"address":[12895830,12895678,12895925],"length":1,"stats":{"Line":22}},{"line":40,"address":[12895980,12896029],"length":1,"stats":{"Line":13}},{"line":41,"address":[14460492,14460571],"length":1,"stats":{"Line":13}},{"line":42,"address":[13775362,13775481],"length":1,"stats":{"Line":13}},{"line":43,"address":[12896560,12896674],"length":1,"stats":{"Line":13}},{"line":44,"address":[12896833,12896862],"length":1,"stats":{"Line":7}},{"line":50,"address":[14460891,14461278],"length":1,"stats":{"Line":6}},{"line":51,"address":[13776115,13775930,13776013],"length":1,"stats":{"Line":9}},{"line":52,"address":[13776333,13776147,13776250],"length":1,"stats":{"Line":10}},{"line":54,"address":[18572677,18572905,18572770],"length":1,"stats":{"Line":9}},{"line":56,"address":[12897749],"length":1,"stats":{"Line":3}},{"line":57,"address":[12897956],"length":1,"stats":{"Line":3}},{"line":60,"address":[12898131],"length":1,"stats":{"Line":3}},{"line":64,"address":[13777224,13777300],"length":1,"stats":{"Line":9}},{"line":65,"address":[12898454,12898392],"length":1,"stats":{"Line":8}},{"line":66,"address":[14463027,14462954],"length":1,"stats":{"Line":8}},{"line":68,"address":[13777626,13777679],"length":1,"stats":{"Line":6}},{"line":69,"address":[12898866],"length":1,"stats":{"Line":3}},{"line":71,"address":[13024606,13024720,13024729,13024592],"length":1,"stats":{"Line":13}},{"line":74,"address":[14463311],"length":1,"stats":{"Line":4}},{"line":77,"address":[12899186,12899341],"length":1,"stats":{"Line":4}},{"line":78,"address":[14463534],"length":1,"stats":{"Line":2}},{"line":79,"address":[18574410],"length":1,"stats":{"Line":2}},{"line":94,"address":[12895748],"length":1,"stats":{"Line":4}},{"line":99,"address":[14454997,14454989,14453536],"length":1,"stats":{"Line":6}},{"line":100,"address":[13768206],"length":1,"stats":{"Line":6}},{"line":101,"address":[14453838],"length":1,"stats":{"Line":5}},{"line":103,"address":[12889497],"length":1,"stats":{"Line":5}},{"line":104,"address":[13768439,13769643],"length":1,"stats":{"Line":5}},{"line":107,"address":[14455424],"length":1,"stats":{"Line":5}},{"line":108,"address":[12890938],"length":1,"stats":{"Line":4}},{"line":109,"address":[12890994],"length":1,"stats":{"Line":4}},{"line":119,"address":[13768278],"length":1,"stats":{"Line":3}},{"line":121,"address":[14453754,14453929],"length":1,"stats":{"Line":5}},{"line":122,"address":[14454061,14453988,14454995],"length":1,"stats":{"Line":8}},{"line":123,"address":[13768703],"length":1,"stats":{"Line":3}},{"line":125,"address":[14454347],"length":1,"stats":{"Line":3}},{"line":127,"address":[14454304],"length":1,"stats":{"Line":13}},{"line":130,"address":[12889998],"length":1,"stats":{"Line":3}},{"line":133,"address":[13769297],"length":1,"stats":{"Line":3}},{"line":134,"address":[13769188],"length":1,"stats":{"Line":4}},{"line":135,"address":[14454705],"length":1,"stats":{"Line":4}},{"line":145,"address":[13768252],"length":1,"stats":{"Line":0}},{"line":150,"address":[12893536],"length":1,"stats":{"Line":5}},{"line":155,"address":[14458080,14457997],"length":1,"stats":{"Line":10}},{"line":157,"address":[14458196],"length":1,"stats":{"Line":5}},{"line":158,"address":[12893875],"length":1,"stats":{"Line":5}},{"line":163,"address":[12893924],"length":1,"stats":{"Line":5}},{"line":164,"address":[14458366],"length":1,"stats":{"Line":6}},{"line":169,"address":[14458396],"length":1,"stats":{"Line":4}},{"line":170,"address":[14458447],"length":1,"stats":{"Line":4}},{"line":175,"address":[12894118],"length":1,"stats":{"Line":4}},{"line":180,"address":[14458521],"length":1,"stats":{"Line":4}},{"line":181,"address":[12894357,12894253],"length":1,"stats":{"Line":4}},{"line":184,"address":[12894307,12894375],"length":1,"stats":{"Line":4}},{"line":185,"address":[13773336,13773473],"length":1,"stats":{"Line":4}},{"line":187,"address":[18569742],"length":1,"stats":{"Line":4}},{"line":195,"address":[14458263],"length":1,"stats":{"Line":0}},{"line":199,"address":[14455616],"length":1,"stats":{"Line":3}},{"line":204,"address":[18566688,18566605],"length":1,"stats":{"Line":6}},{"line":205,"address":[13770452],"length":1,"stats":{"Line":3}},{"line":206,"address":[13770499],"length":1,"stats":{"Line":3}},{"line":211,"address":[18566900],"length":1,"stats":{"Line":3}},{"line":212,"address":[14456078],"length":1,"stats":{"Line":4}},{"line":216,"address":[18567004],"length":1,"stats":{"Line":4}},{"line":217,"address":[13770703],"length":1,"stats":{"Line":4}},{"line":222,"address":[18567095],"length":1,"stats":{"Line":4}},{"line":227,"address":[14456234],"length":1,"stats":{"Line":4}},{"line":228,"address":[14456335,14456439],"length":1,"stats":{"Line":4}},{"line":231,"address":[18567284,18567352],"length":1,"stats":{"Line":4}},{"line":232,"address":[13771186,13771049],"length":1,"stats":{"Line":4}},{"line":234,"address":[13771105],"length":1,"stats":{"Line":4}},{"line":242,"address":[18566871],"length":1,"stats":{"Line":2}},{"line":246,"address":[13771200],"length":1,"stats":{"Line":5}},{"line":251,"address":[13771296],"length":1,"stats":{"Line":4}},{"line":252,"address":[12892392],"length":1,"stats":{"Line":4}},{"line":253,"address":[13771315],"length":1,"stats":{"Line":4}},{"line":255,"address":[14456782,14456865],"length":1,"stats":{"Line":9}},{"line":256,"address":[14456981],"length":1,"stats":{"Line":4}},{"line":259,"address":[12892650,12892712],"length":1,"stats":{"Line":12}},{"line":261,"address":[13771683,13771798],"length":1,"stats":{"Line":2}},{"line":262,"address":[13771771,13771831],"length":1,"stats":{"Line":4}},{"line":263,"address":[13771856],"length":1,"stats":{"Line":2}},{"line":265,"address":[14457320,14457770,14457873],"length":1,"stats":{"Line":6}},{"line":266,"address":[13772393,13772330],"length":1,"stats":{"Line":2}},{"line":267,"address":[18568761,18568720,18568773],"length":1,"stats":{"Line":4}},{"line":274,"address":[12892683],"length":1,"stats":{"Line":4}},{"line":276,"address":[13771924],"length":1,"stats":{"Line":2}},{"line":280,"address":[12893041],"length":1,"stats":{"Line":2}},{"line":281,"address":[12893129],"length":1,"stats":{"Line":2}},{"line":282,"address":[18568639,18568496],"length":1,"stats":{"Line":2}},{"line":283,"address":[13772210],"length":1,"stats":{"Line":2}},{"line":284,"address":[12893280],"length":1,"stats":{"Line":2}},{"line":285,"address":[14457652],"length":1,"stats":{"Line":2}},{"line":286,"address":[13772203],"length":1,"stats":{"Line":2}},{"line":293,"address":[13771584],"length":1,"stats":{"Line":4}}],"covered":104,"coverable":107},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","csharp.rs"],"content":"//! Parser for C# .csproj files (NuGet PackageReference format)\n\nuse super::{Dependency, Parser};\n\n/// Parser for C# .csproj files\n#[derive(Debug, Default)]\npub struct CsharpParser;\n\nimpl CsharpParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for CsharpParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        let mut dependencies = Vec::new();\n\n        for (line_idx, line) in content.lines().enumerate() {\n            let line_num = line_idx as u32;\n            let trimmed = line.trim();\n\n            // Look for PackageReference elements\n            // Format 1: <PackageReference Include=\"Package\" Version=\"1.0.0\" />\n            // Format 2: <PackageReference Include=\"Package\"><Version>1.0.0</Version></PackageReference>\n            if trimmed.contains(\"<PackageReference\")\n                && trimmed.contains(\"Include=\")\n                && let Some(dep) = parse_package_reference(line, line_num)\n            {\n                dependencies.push(dep);\n            }\n        }\n\n        dependencies\n    }\n}\n\n/// Parse a PackageReference XML element\nfn parse_package_reference(line: &str, line_num: u32) -> Option<Dependency> {\n    // Extract Include attribute (package name)\n    let include_start = line.find(\"Include=\\\"\")? + 9;\n    let include_content = &line[include_start..];\n    let include_end = include_content.find('\"')?;\n    let name = &include_content[..include_end];\n\n    // Try to find Version attribute on same line\n    let version = if let Some(version_attr_start) = line.find(\"Version=\\\"\") {\n        let version_content = &line[version_attr_start + 9..];\n        let version_end = version_content.find('\"')?;\n        version_content[..version_end].to_string()\n    } else if let Some(version_elem_start) = line.find(\"<Version>\") {\n        // Format: <Version>1.0.0</Version>\n        let version_content = &line[version_elem_start + 9..];\n        let version_end = version_content.find('<')?;\n        version_content[..version_end].to_string()\n    } else {\n        // Version might be centrally managed (Directory.Packages.props)\n        // Skip for now\n        return None;\n    };\n\n    // Calculate positions\n    let name_pattern = format!(\"\\\"{}\\\"\", name);\n    let name_pos = line.find(&name_pattern)?;\n    let name_start = (name_pos + 1) as u32;\n    let name_end = name_start + name.len() as u32;\n\n    let version_start = line.find(&version)? as u32;\n    let version_end = version_start + version.len() as u32;\n\n    Some(Dependency {\n        name: name.to_string(),\n        version,\n        line: line_num,\n        name_start,\n        name_end,\n        version_start,\n        version_end,\n        dev: false, // NuGet doesn't have explicit dev dependencies in .csproj\n        optional: false,\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_self_closing() {\n        let content = r#\"\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n  </PropertyGroup>\n  <ItemGroup>\n    <PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n    <PackageReference Include=\"Serilog\" Version=\"3.1.1\" />\n  </ItemGroup>\n</Project>\n\"#;\n        let parser = CsharpParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 2);\n\n        let newtonsoft = deps.iter().find(|d| d.name == \"Newtonsoft.Json\").unwrap();\n        assert_eq!(newtonsoft.version, \"13.0.3\");\n\n        let serilog = deps.iter().find(|d| d.name == \"Serilog\").unwrap();\n        assert_eq!(serilog.version, \"3.1.1\");\n    }\n\n    #[test]\n    fn test_parse_expanded_format() {\n        let content = r#\"\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.Extensions.Logging\" Version=\"8.0.0\" />\n  </ItemGroup>\n</Project>\n\"#;\n        let parser = CsharpParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"Microsoft.Extensions.Logging\");\n        assert_eq!(deps[0].version, \"8.0.0\");\n    }\n\n    #[test]\n    fn test_version_positions() {\n        let content = r#\"\n<Project>\n  <ItemGroup>\n    <PackageReference Include=\"Serilog\" Version=\"3.1.1\" />\n  </ItemGroup>\n</Project>\n\"#;\n        let parser = CsharpParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 1);\n        let dep = &deps[0];\n        assert!(dep.version_start > dep.name_end);\n    }\n\n    #[test]\n    fn test_skip_no_version() {\n        let content = r#\"\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <ItemGroup>\n    <PackageReference Include=\"Newtonsoft.Json\" />\n    <PackageReference Include=\"Serilog\" Version=\"3.1.1\" />\n  </ItemGroup>\n</Project>\n\"#;\n        let parser = CsharpParser::new();\n        let deps = parser.parse(content);\n\n        // Should only find Serilog (Newtonsoft.Json has no version)\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"Serilog\");\n    }\n\n    #[test]\n    fn test_multiple_item_groups() {\n        let content = r#\"\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <ItemGroup>\n    <PackageReference Include=\"Package1\" Version=\"1.0.0\" />\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(Configuration)'=='Debug'\">\n    <PackageReference Include=\"Package2\" Version=\"2.0.0\" />\n  </ItemGroup>\n</Project>\n\"#;\n        let parser = CsharpParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 2);\n    }\n}\n","traces":[{"line":16,"address":[16506659,16506653,16505952],"length":1,"stats":{"Line":2}},{"line":17,"address":[14455523],"length":1,"stats":{"Line":2}},{"line":19,"address":[14455555,14455603],"length":1,"stats":{"Line":9}},{"line":20,"address":[14455803],"length":1,"stats":{"Line":6}},{"line":21,"address":[14484738,14484812],"length":1,"stats":{"Line":14}},{"line":26,"address":[14846420],"length":1,"stats":{"Line":8}},{"line":27,"address":[14846470],"length":1,"stats":{"Line":8}},{"line":28,"address":[16506500],"length":1,"stats":{"Line":8}},{"line":30,"address":[14485084],"length":1,"stats":{"Line":5}},{"line":34,"address":[16506309],"length":1,"stats":{"Line":4}},{"line":39,"address":[14484268,14482000,14484274],"length":1,"stats":{"Line":8}},{"line":41,"address":[14453163,14453428],"length":1,"stats":{"Line":8}},{"line":42,"address":[14453322],"length":1,"stats":{"Line":8}},{"line":43,"address":[14843916,14843992],"length":1,"stats":{"Line":8}},{"line":44,"address":[14453492],"length":1,"stats":{"Line":8}},{"line":47,"address":[16502527],"length":1,"stats":{"Line":8}},{"line":48,"address":[14453601,14453830,14453724],"length":1,"stats":{"Line":12}},{"line":49,"address":[14844317,14844393],"length":1,"stats":{"Line":7}},{"line":50,"address":[14844432],"length":1,"stats":{"Line":7}},{"line":51,"address":[14482571,14482908],"length":1,"stats":{"Line":2}},{"line":53,"address":[14844604,14844537,14844704],"length":1,"stats":{"Line":0}},{"line":54,"address":[14483036,14483112],"length":1,"stats":{"Line":0}},{"line":55,"address":[14483149],"length":1,"stats":{"Line":0}},{"line":59,"address":[16503016],"length":1,"stats":{"Line":2}},{"line":63,"address":[14454305,14453937],"length":1,"stats":{"Line":12}},{"line":64,"address":[16504291,16503417,16503488],"length":1,"stats":{"Line":10}},{"line":65,"address":[14483531,14483592],"length":1,"stats":{"Line":3}},{"line":66,"address":[14454693,14454763,14454636],"length":1,"stats":{"Line":7}},{"line":68,"address":[14483662,14483719,14484226],"length":1,"stats":{"Line":7}},{"line":69,"address":[14845512,14845433],"length":1,"stats":{"Line":5}},{"line":71,"address":[14845604],"length":1,"stats":{"Line":3}},{"line":72,"address":[14454953],"length":1,"stats":{"Line":4}},{"line":73,"address":[14455040],"length":1,"stats":{"Line":4}}],"covered":30,"coverable":33},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","dart.rs"],"content":"//! Parser for Dart/Flutter pubspec.yaml files\n\nuse super::{Dependency, Parser};\n\n/// Parser for Dart pubspec.yaml dependency files\n#[derive(Debug, Default)]\npub struct DartParser;\n\nimpl DartParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for DartParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        let mut dependencies = Vec::new();\n        let mut current_section: Option<DependencySection> = None;\n        let mut in_nested_block = false;\n\n        for (line_idx, line) in content.lines().enumerate() {\n            let line_num = line_idx as u32;\n            let trimmed = line.trim();\n\n            // Skip comments and empty lines\n            if trimmed.is_empty() || trimmed.starts_with('#') {\n                continue;\n            }\n\n            // Check for section headers (no indentation, ends with :)\n            if !line.starts_with(' ') && !line.starts_with('\\t') && trimmed.ends_with(':') {\n                let section_name = trimmed.trim_end_matches(':');\n                current_section = match section_name {\n                    \"dependencies\" => Some(DependencySection::Dependencies),\n                    \"dev_dependencies\" => Some(DependencySection::DevDependencies),\n                    \"dependency_overrides\" => Some(DependencySection::DependencyOverrides),\n                    _ => None,\n                };\n                in_nested_block = false;\n                continue;\n            }\n\n            // Only process if we're in a dependency section\n            let Some(section) = &current_section else {\n                continue;\n            };\n\n            // Check if we're exiting the section (new top-level key)\n            if !line.starts_with(' ') && !line.starts_with('\\t') {\n                current_section = None;\n                continue;\n            }\n\n            // Skip if we're in a nested block (git, path, sdk dependencies)\n            if in_nested_block {\n                // Check if this line is less indented than before (exit nested)\n                let indent = line.len() - line.trim_start().len();\n                if indent <= 2 {\n                    in_nested_block = false;\n                } else {\n                    continue;\n                }\n            }\n\n            // Parse dependency line\n            if let Some(dep) = parse_dart_dependency_line(line, line_num, section.is_dev()) {\n                // Check if this is a complex dependency (sdk, git, path)\n                if is_complex_dependency(trimmed) {\n                    in_nested_block = true;\n                    continue;\n                }\n\n                // Skip Flutter SDK dependencies\n                if is_flutter_sdk_dependency(&dep.name) {\n                    continue;\n                }\n\n                dependencies.push(dep);\n            } else if trimmed.ends_with(':') && !trimmed.contains(' ') {\n                // This is a package name without version on same line\n                // Could be a complex dependency\n                in_nested_block = true;\n            }\n        }\n\n        dependencies\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nenum DependencySection {\n    Dependencies,\n    DevDependencies,\n    DependencyOverrides,\n}\n\nimpl DependencySection {\n    fn is_dev(&self) -> bool {\n        matches!(self, DependencySection::DevDependencies)\n    }\n}\n\n/// Parse a single dependency line in YAML format\nfn parse_dart_dependency_line(line: &str, line_num: u32, dev: bool) -> Option<Dependency> {\n    let trimmed = line.trim();\n\n    // Skip if it doesn't contain a colon\n    if !trimmed.contains(':') {\n        return None;\n    }\n\n    let colon_pos = trimmed.find(':')?;\n    let name = trimmed[..colon_pos].trim();\n    let version_part = trimmed[colon_pos + 1..].trim();\n\n    // Skip if no version (could be a complex dependency)\n    if version_part.is_empty() {\n        return None;\n    }\n\n    // Skip if it's a complex dependency (starts with { or contains special keys)\n    if version_part.starts_with('{') || !version_part.starts_with('^') && version_part.contains(':')\n    {\n        return None;\n    }\n\n    // Clean the version (remove quotes if present)\n    let version = version_part\n        .trim_matches('\"')\n        .trim_matches('\\'')\n        .to_string();\n\n    // Skip if version is empty or looks like a path/git/sdk reference\n    if version.is_empty() || version.starts_with('/') || version.starts_with('.') {\n        return None;\n    }\n\n    // Calculate positions\n    let name_start = line.find(name)? as u32;\n    let name_end = name_start + name.len() as u32;\n    let version_start = line.find(&version)? as u32;\n    let version_end = version_start + version.len() as u32;\n\n    Some(Dependency {\n        name: name.to_string(),\n        version,\n        line: line_num,\n        name_start,\n        name_end,\n        version_start,\n        version_end,\n        dev,\n        optional: false,\n    })\n}\n\n/// Check if a line indicates a complex dependency (git, path, sdk)\nfn is_complex_dependency(line: &str) -> bool {\n    let trimmed = line.trim();\n    trimmed.ends_with(':') && !trimmed.contains(' ')\n        || trimmed.contains(\"sdk:\")\n        || trimmed.contains(\"git:\")\n        || trimmed.contains(\"path:\")\n        || trimmed.contains(\"hosted:\")\n}\n\n/// Check if a package is a Flutter SDK dependency\nfn is_flutter_sdk_dependency(name: &str) -> bool {\n    matches!(\n        name,\n        \"flutter\"\n            | \"flutter_test\"\n            | \"flutter_localizations\"\n            | \"flutter_driver\"\n            | \"flutter_web_plugins\"\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_simple_dependencies() {\n        let content = r#\"\nname: my_app\nversion: 1.0.0\n\ndependencies:\n  http: ^1.0.0\n  provider: ^6.0.0\n\ndev_dependencies:\n  mockito: ^5.4.0\n\"#;\n        let parser = DartParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 3);\n\n        let http = deps.iter().find(|d| d.name == \"http\").unwrap();\n        assert_eq!(http.version, \"^1.0.0\");\n        assert!(!http.dev);\n\n        let mockito = deps.iter().find(|d| d.name == \"mockito\").unwrap();\n        assert!(mockito.dev);\n    }\n\n    #[test]\n    fn test_skip_flutter_sdk() {\n        let content = r#\"\ndependencies:\n  flutter:\n    sdk: flutter\n  http: ^1.0.0\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  mockito: ^5.4.0\n\"#;\n        let parser = DartParser::new();\n        let deps = parser.parse(content);\n\n        // Should only find http and mockito, not flutter or flutter_test\n        assert_eq!(deps.len(), 2);\n        assert!(deps.iter().any(|d| d.name == \"http\"));\n        assert!(deps.iter().any(|d| d.name == \"mockito\"));\n        assert!(!deps.iter().any(|d| d.name == \"flutter\"));\n        assert!(!deps.iter().any(|d| d.name == \"flutter_test\"));\n    }\n\n    #[test]\n    fn test_skip_git_dependencies() {\n        let content = r#\"\ndependencies:\n  http: ^1.0.0\n  custom_pkg:\n    git:\n      url: https://github.com/user/repo.git\n      ref: main\n  provider: ^6.0.0\n\"#;\n        let parser = DartParser::new();\n        let deps = parser.parse(content);\n\n        // Should only find http and provider\n        assert_eq!(deps.len(), 2);\n        assert!(deps.iter().any(|d| d.name == \"http\"));\n        assert!(deps.iter().any(|d| d.name == \"provider\"));\n    }\n\n    #[test]\n    fn test_version_positions() {\n        let content = r#\"\ndependencies:\n  http: ^1.0.0\n\"#;\n        let parser = DartParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 1);\n        let http = &deps[0];\n        assert_eq!(http.name, \"http\");\n        assert!(http.version_start > http.name_end);\n    }\n\n    #[test]\n    fn test_quoted_versions() {\n        let content = r#\"\ndependencies:\n  http: \"^1.0.0\"\n  provider: '^6.0.0'\n\"#;\n        let parser = DartParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 2);\n        assert_eq!(deps[0].version, \"^1.0.0\");\n        assert_eq!(deps[1].version, \"^6.0.0\");\n    }\n\n    #[test]\n    fn test_dependency_overrides() {\n        let content = r#\"\ndependencies:\n  http: ^1.0.0\n\ndependency_overrides:\n  http: ^1.1.0\n\"#;\n        let parser = DartParser::new();\n        let deps = parser.parse(content);\n\n        // Should find both (override and regular)\n        assert_eq!(deps.len(), 2);\n    }\n}\n","traces":[{"line":16,"address":[13858560,13858478,13856560],"length":1,"stats":{"Line":3}},{"line":17,"address":[12961823],"length":1,"stats":{"Line":4}},{"line":18,"address":[13856664],"length":1,"stats":{"Line":2}},{"line":19,"address":[13856672],"length":1,"stats":{"Line":5}},{"line":21,"address":[13856739,13856688],"length":1,"stats":{"Line":8}},{"line":22,"address":[12962140],"length":1,"stats":{"Line":7}},{"line":23,"address":[12962147,12962245],"length":1,"stats":{"Line":11}},{"line":26,"address":[13838803],"length":1,"stats":{"Line":5}},{"line":31,"address":[13838900,13839006],"length":1,"stats":{"Line":12}},{"line":32,"address":[13857362],"length":1,"stats":{"Line":7}},{"line":33,"address":[13857587],"length":1,"stats":{"Line":9}},{"line":34,"address":[13857496,13857430],"length":1,"stats":{"Line":11}},{"line":35,"address":[13857473,13857510,13857549],"length":1,"stats":{"Line":11}},{"line":36,"address":[13857579,13857563,13857526],"length":1,"stats":{"Line":6}},{"line":37,"address":[12962761],"length":1,"stats":{"Line":0}},{"line":39,"address":[17282585],"length":1,"stats":{"Line":3}},{"line":44,"address":[17282238,17282622],"length":1,"stats":{"Line":11}},{"line":49,"address":[12962838,12962920],"length":1,"stats":{"Line":3}},{"line":50,"address":[12962926],"length":1,"stats":{"Line":0}},{"line":55,"address":[12963122,12962904],"length":1,"stats":{"Line":11}},{"line":57,"address":[13857785,13857902],"length":1,"stats":{"Line":2}},{"line":58,"address":[12963083],"length":1,"stats":{"Line":2}},{"line":59,"address":[13839634],"length":1,"stats":{"Line":2}},{"line":66,"address":[12962947,12963622,12963154],"length":1,"stats":{"Line":18}},{"line":68,"address":[13858126,13858221],"length":1,"stats":{"Line":9}},{"line":69,"address":[13858252],"length":1,"stats":{"Line":0}},{"line":74,"address":[17283259,17283219],"length":1,"stats":{"Line":9}},{"line":78,"address":[13858296],"length":1,"stats":{"Line":7}},{"line":79,"address":[13840200,13839888,13840142,13840267,13839865,13840123,13840155],"length":1,"stats":{"Line":11}},{"line":82,"address":[13858547],"length":1,"stats":{"Line":2}},{"line":86,"address":[12962186],"length":1,"stats":{"Line":5}},{"line":98,"address":[17278592],"length":1,"stats":{"Line":9}},{"line":99,"address":[17278597],"length":1,"stats":{"Line":3}},{"line":104,"address":[13837986,13836160,13837992],"length":1,"stats":{"Line":2}},{"line":105,"address":[13854558],"length":1,"stats":{"Line":7}},{"line":108,"address":[17279209],"length":1,"stats":{"Line":3}},{"line":109,"address":[13836336],"length":1,"stats":{"Line":0}},{"line":112,"address":[13836367,13836446],"length":1,"stats":{"Line":8}},{"line":113,"address":[12960013],"length":1,"stats":{"Line":4}},{"line":114,"address":[12960077,12960194],"length":1,"stats":{"Line":8}},{"line":117,"address":[13836664],"length":1,"stats":{"Line":4}},{"line":118,"address":[12960248],"length":1,"stats":{"Line":2}},{"line":122,"address":[17279717,17279599,17279658],"length":1,"stats":{"Line":10}},{"line":124,"address":[12960307],"length":1,"stats":{"Line":0}},{"line":134,"address":[12960578,12960499,12960434],"length":1,"stats":{"Line":9}},{"line":135,"address":[13855330],"length":1,"stats":{"Line":0}},{"line":139,"address":[13837207,13837984],"length":1,"stats":{"Line":5}},{"line":140,"address":[17280244,17280331],"length":1,"stats":{"Line":5}},{"line":141,"address":[17280838,17280314,17280361],"length":1,"stats":{"Line":9}},{"line":142,"address":[17280556,17280475],"length":1,"stats":{"Line":5}},{"line":144,"address":[12961289],"length":1,"stats":{"Line":4}},{"line":145,"address":[13837663],"length":1,"stats":{"Line":5}},{"line":146,"address":[12961241],"length":1,"stats":{"Line":5}},{"line":158,"address":[12959248],"length":1,"stats":{"Line":4}},{"line":159,"address":[17278638],"length":1,"stats":{"Line":6}},{"line":160,"address":[13854132,13854060,13854117],"length":1,"stats":{"Line":3}},{"line":161,"address":[13835796],"length":1,"stats":{"Line":7}},{"line":162,"address":[13854148],"length":1,"stats":{"Line":3}},{"line":163,"address":[13854179],"length":1,"stats":{"Line":6}},{"line":164,"address":[13835922],"length":1,"stats":{"Line":4}},{"line":168,"address":[13835968],"length":1,"stats":{"Line":3}},{"line":169,"address":[13836044],"length":1,"stats":{"Line":0}}],"covered":55,"coverable":62},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","go.rs"],"content":"//! Parser for Go module files (go.mod)\n\nuse super::{Dependency, Parser};\n\n/// Parser for Go go.mod dependency files\n#[derive(Debug, Default)]\npub struct GoParser;\n\nimpl GoParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for GoParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        let mut dependencies = Vec::new();\n        let mut in_require_block = false;\n\n        for (line_idx, line) in content.lines().enumerate() {\n            let line_num = line_idx as u32;\n            let trimmed = line.trim();\n\n            // Skip empty lines and comments\n            if trimmed.is_empty() || trimmed.starts_with(\"//\") {\n                continue;\n            }\n\n            // Check for require block start\n            if trimmed == \"require (\" {\n                in_require_block = true;\n                continue;\n            }\n\n            // Check for block end\n            if trimmed == \")\" {\n                in_require_block = false;\n                continue;\n            }\n\n            // Parse single-line require: require github.com/pkg/errors v0.9.1\n            if trimmed.starts_with(\"require \") && !trimmed.contains(\"(\") {\n                let rest = &trimmed[8..]; // Skip \"require \"\n                if let Some(dep) = parse_require_line(line, rest, line_num) {\n                    dependencies.push(dep);\n                }\n                continue;\n            }\n\n            // Parse lines inside require block\n            if in_require_block && let Some(dep) = parse_require_line(line, trimmed, line_num) {\n                dependencies.push(dep);\n            }\n        }\n\n        dependencies\n    }\n}\n\n/// Parse a require line (either standalone or inside a block)\n/// Format: module/path v1.2.3 [// indirect]\nfn parse_require_line(line: &str, content: &str, line_num: u32) -> Option<Dependency> {\n    let trimmed = content.trim();\n\n    // Skip empty lines, comments, and replace directives\n    if trimmed.is_empty() || trimmed.starts_with(\"//\") || trimmed.starts_with(\"replace\") {\n        return None;\n    }\n\n    // Remove inline comment (// indirect or other comments)\n    let is_indirect = trimmed.contains(\"// indirect\");\n    let without_comment = if let Some(pos) = trimmed.find(\"//\") {\n        trimmed[..pos].trim()\n    } else {\n        trimmed\n    };\n\n    // Split into module path and version\n    let parts: Vec<&str> = without_comment.split_whitespace().collect();\n    if parts.len() < 2 {\n        return None;\n    }\n\n    let module_path = parts[0];\n    let version = parts[1];\n\n    // Version must start with 'v'\n    if !version.starts_with('v') {\n        return None;\n    }\n\n    // Calculate positions in the original line\n    let name_start = line.find(module_path)? as u32;\n    let name_end = name_start + module_path.len() as u32;\n    let version_start = line.find(version)? as u32;\n    let version_end = version_start + version.len() as u32;\n\n    Some(Dependency {\n        name: module_path.to_string(),\n        version: version.to_string(),\n        line: line_num,\n        name_start,\n        name_end,\n        version_start,\n        version_end,\n        dev: false,\n        optional: is_indirect, // Mark indirect dependencies as optional\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_require() {\n        let parser = GoParser::new();\n        let content = r#\"\nmodule example.com/mymodule\n\ngo 1.21\n\nrequire github.com/pkg/errors v0.9.1\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"github.com/pkg/errors\");\n        assert_eq!(deps[0].version, \"v0.9.1\");\n        assert!(!deps[0].optional);\n    }\n\n    #[test]\n    fn test_require_block() {\n        let parser = GoParser::new();\n        let content = r#\"\nmodule example.com/mymodule\n\ngo 1.21\n\nrequire (\n    github.com/gin-gonic/gin v1.9.1\n    golang.org/x/text v0.14.0\n)\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 2);\n\n        let gin = deps.iter().find(|d| d.name.contains(\"gin\")).unwrap();\n        assert_eq!(gin.version, \"v1.9.1\");\n\n        let text = deps.iter().find(|d| d.name.contains(\"text\")).unwrap();\n        assert_eq!(text.version, \"v0.14.0\");\n    }\n\n    #[test]\n    fn test_indirect_dependency() {\n        let parser = GoParser::new();\n        let content = r#\"\nrequire (\n    github.com/direct/dep v1.0.0\n    github.com/indirect/dep v2.0.0 // indirect\n)\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 2);\n\n        let direct = deps.iter().find(|d| d.name.contains(\"direct\")).unwrap();\n        assert!(!direct.optional);\n\n        let indirect = deps.iter().find(|d| d.name.contains(\"indirect\")).unwrap();\n        assert!(indirect.optional);\n    }\n\n    #[test]\n    fn test_multiple_require_blocks() {\n        let parser = GoParser::new();\n        let content = r#\"\nrequire (\n    github.com/pkg/a v1.0.0\n)\n\nrequire (\n    github.com/pkg/b v2.0.0\n)\n\nrequire github.com/pkg/c v3.0.0\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 3);\n    }\n\n    #[test]\n    fn test_version_position() {\n        let parser = GoParser::new();\n        let content = \"require github.com/pkg/errors v0.9.1\";\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n\n        let dep = &deps[0];\n        // \"require \" is 8 chars (0-7)\n        // \"github.com/pkg/errors\" is 21 chars (8-28), so name_end = 29\n        // \" \" is at position 29\n        // \"v0.9.1\" is 6 chars (30-35), so version_end = 36\n        assert_eq!(dep.name_start, 8);\n        assert_eq!(dep.name_end, 29);\n        assert_eq!(dep.version_start, 30);\n        assert_eq!(dep.version_end, 36);\n    }\n\n    #[test]\n    fn test_skip_replace_directives() {\n        let parser = GoParser::new();\n        let content = r#\"\nrequire github.com/old/pkg v1.0.0\n\nreplace github.com/old/pkg => github.com/new/pkg v2.0.0\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"github.com/old/pkg\");\n    }\n}\n","traces":[{"line":16,"address":[12989197,12989203,12988000],"length":1,"stats":{"Line":2}},{"line":17,"address":[14451875],"length":1,"stats":{"Line":2}},{"line":18,"address":[14451899],"length":1,"stats":{"Line":2}},{"line":20,"address":[14451915,14451963],"length":1,"stats":{"Line":6}},{"line":21,"address":[14481091],"length":1,"stats":{"Line":3}},{"line":22,"address":[14481169,14481098],"length":1,"stats":{"Line":6}},{"line":25,"address":[14452257],"length":1,"stats":{"Line":3}},{"line":30,"address":[15968587],"length":1,"stats":{"Line":3}},{"line":31,"address":[14481353],"length":1,"stats":{"Line":3}},{"line":36,"address":[15968627,15968674],"length":1,"stats":{"Line":10}},{"line":37,"address":[15968723],"length":1,"stats":{"Line":3}},{"line":42,"address":[15968740,15968680,15968765],"length":1,"stats":{"Line":12}},{"line":43,"address":[14481514],"length":1,"stats":{"Line":4}},{"line":44,"address":[14452684],"length":1,"stats":{"Line":4}},{"line":45,"address":[14452812],"length":1,"stats":{"Line":4}},{"line":51,"address":[14481442,14481784],"length":1,"stats":{"Line":5}},{"line":52,"address":[15969249],"length":1,"stats":{"Line":2}},{"line":56,"address":[12988365],"length":1,"stats":{"Line":6}},{"line":62,"address":[14451684,14451700,14449920],"length":1,"stats":{"Line":3}},{"line":63,"address":[14450045],"length":1,"stats":{"Line":2}},{"line":66,"address":[12986280,12986371],"length":1,"stats":{"Line":5}},{"line":67,"address":[15965473],"length":1,"stats":{"Line":0}},{"line":71,"address":[14479145],"length":1,"stats":{"Line":3}},{"line":72,"address":[12986459],"length":1,"stats":{"Line":5}},{"line":73,"address":[14450347],"length":1,"stats":{"Line":2}},{"line":75,"address":[14450405],"length":1,"stats":{"Line":4}},{"line":79,"address":[12986613],"length":1,"stats":{"Line":5}},{"line":80,"address":[14450570,14450499],"length":1,"stats":{"Line":11}},{"line":81,"address":[14479550],"length":1,"stats":{"Line":0}},{"line":84,"address":[14479504,14479576],"length":1,"stats":{"Line":12}},{"line":85,"address":[14479615],"length":1,"stats":{"Line":5}},{"line":88,"address":[15966091],"length":1,"stats":{"Line":7}},{"line":89,"address":[14479733],"length":1,"stats":{"Line":0}},{"line":93,"address":[14450852,14451695,14450902],"length":1,"stats":{"Line":12}},{"line":94,"address":[12987305,12987212],"length":1,"stats":{"Line":5}},{"line":95,"address":[14451100,14451151,14451690],"length":1,"stats":{"Line":12}},{"line":96,"address":[12987451,12987532],"length":1,"stats":{"Line":7}},{"line":98,"address":[14480414],"length":1,"stats":{"Line":5}},{"line":99,"address":[14451333],"length":1,"stats":{"Line":5}},{"line":100,"address":[14451383],"length":1,"stats":{"Line":7}}],"covered":37,"coverable":40},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","mod.rs"],"content":"//! Parsers for dependency files (Cargo.toml, package.json, etc.)\n\nuse serde::{Deserialize, Serialize};\n\n/// Represents a dependency extracted from a manifest file\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Dependency {\n    /// Package name\n    pub name: String,\n    /// Version specifier (e.g., \"1.0.0\", \"^1.0\", \">=1,<2\")\n    pub version: String,\n    /// Line number in the file (0-indexed)\n    pub line: u32,\n    /// Column where the package name starts\n    pub name_start: u32,\n    /// Column where the package name ends\n    pub name_end: u32,\n    /// Column where the version string starts\n    pub version_start: u32,\n    /// Column where the version string ends\n    pub version_end: u32,\n    /// Whether this is a dev dependency\n    pub dev: bool,\n    /// Whether this dependency is optional\n    pub optional: bool,\n}\n\n/// Trait for parsing dependency files\npub trait Parser: Send + Sync {\n    /// Parse the given file content and extract dependencies\n    fn parse(&self, content: &str) -> Vec<Dependency>;\n}\n\npub mod cargo;\npub mod csharp;\npub mod dart;\npub mod go;\npub mod npm;\npub mod php;\npub mod python;\npub mod ruby;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","npm.rs"],"content":"//! Parser for package.json files\n\nuse super::{Dependency, Parser};\n\n/// Parser for npm package.json dependency files\n#[derive(Debug, Default)]\npub struct NpmParser;\n\nimpl NpmParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for NpmParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        let mut dependencies = Vec::new();\n\n        // Track which section we're in\n        let mut current_section: Option<DependencyType> = None;\n        let mut section_brace_depth = 0;\n        let mut in_section_object = false;\n\n        for (line_idx, line) in content.lines().enumerate() {\n            let line_num = line_idx as u32;\n            let trimmed = line.trim();\n\n            // Check for section headers first\n            if let Some(section) = detect_section(trimmed) {\n                current_section = Some(section);\n                // Count braces after the section name to determine if we're in the object\n                let section_start = if trimmed.contains(\"devDependencies\") {\n                    trimmed.find(\"devDependencies\").unwrap() + \"devDependencies\".len()\n                } else if trimmed.contains(\"peerDependencies\") {\n                    trimmed.find(\"peerDependencies\").unwrap() + \"peerDependencies\".len()\n                } else if trimmed.contains(\"optionalDependencies\") {\n                    trimmed.find(\"optionalDependencies\").unwrap() + \"optionalDependencies\".len()\n                } else if trimmed.contains(\"dependencies\") {\n                    trimmed.find(\"dependencies\").unwrap() + \"dependencies\".len()\n                } else {\n                    0\n                };\n\n                let after_section = &trimmed[section_start..];\n                if after_section.contains('{') {\n                    in_section_object = true;\n                    section_brace_depth = 1;\n\n                    // Handle inline dependencies on the same line as section header\n                    // e.g., {\"dependencies\": {\"pkg\": \"1.0.0\"}}\n                    if let Some(brace_pos) = after_section.find('{') {\n                        let deps_content = &after_section[brace_pos + 1..];\n                        // Try to parse dependencies from this content\n                        for dep in parse_inline_dependencies(deps_content, line_num, section) {\n                            dependencies.push(dep);\n                        }\n                    }\n                }\n                continue;\n            }\n\n            // If we're looking for the opening brace of a section\n            if current_section.is_some()\n                && !in_section_object\n                && (trimmed.starts_with('{') || trimmed == \"{\")\n            {\n                in_section_object = true;\n                section_brace_depth = 1;\n                continue;\n            }\n\n            // Track brace depth within section\n            if in_section_object {\n                for ch in trimmed.chars() {\n                    match ch {\n                        '{' => section_brace_depth += 1,\n                        '}' => {\n                            section_brace_depth -= 1;\n                            if section_brace_depth == 0 {\n                                current_section = None;\n                                in_section_object = false;\n                            }\n                        }\n                        _ => {}\n                    }\n                }\n            }\n\n            // Parse dependency lines within sections\n            if let Some(section) = current_section\n                && in_section_object\n                && let Some(dep) = parse_dependency_line(line, line_num, section)\n            {\n                dependencies.push(dep);\n            }\n        }\n\n        dependencies\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum DependencyType {\n    Normal,\n    Dev,\n    Peer,\n    Optional,\n}\n\n/// Parse inline dependencies from a single line content\n/// e.g., \"pkg\": \"1.0.0\", \"pkg2\": \"2.0.0\"}}\nfn parse_inline_dependencies(\n    content: &str,\n    line_num: u32,\n    dep_type: DependencyType,\n) -> Vec<Dependency> {\n    let mut deps = Vec::new();\n    let mut remaining = content;\n\n    while let Some(first_quote) = remaining.find('\"') {\n        let after_first = &remaining[first_quote + 1..];\n        let Some(name_end) = after_first.find('\"') else {\n            break;\n        };\n        let name = &after_first[..name_end];\n\n        // Skip if it looks like a section header or closing\n        if name.ends_with(\"ependencies\") || name.is_empty() {\n            remaining = &after_first[name_end + 1..];\n            continue;\n        }\n\n        // Find colon and version\n        let after_name = &after_first[name_end + 1..];\n        let Some(colon_pos) = after_name.find(':') else {\n            remaining = after_name;\n            continue;\n        };\n\n        let after_colon = &after_name[colon_pos + 1..];\n        let Some(version_quote_start) = after_colon.find('\"') else {\n            remaining = after_colon;\n            continue;\n        };\n\n        let version_content = &after_colon[version_quote_start + 1..];\n        let Some(version_end) = version_content.find('\"') else {\n            remaining = version_content;\n            continue;\n        };\n\n        let version = &version_content[..version_end];\n\n        deps.push(Dependency {\n            name: name.to_string(),\n            version: version.to_string(),\n            line: line_num,\n            name_start: 0, // Approximate for inline\n            name_end: 0,\n            version_start: 0,\n            version_end: 0,\n            dev: dep_type == DependencyType::Dev,\n            optional: dep_type == DependencyType::Optional || dep_type == DependencyType::Peer,\n        });\n\n        remaining = &version_content[version_end + 1..];\n    }\n\n    deps\n}\n\nfn detect_section(line: &str) -> Option<DependencyType> {\n    let line = line.trim();\n\n    if line.contains(\"\\\"dependencies\\\"\") && !line.contains(\"\\\"devDependencies\\\"\") {\n        Some(DependencyType::Normal)\n    } else if line.contains(\"\\\"devDependencies\\\"\") {\n        Some(DependencyType::Dev)\n    } else if line.contains(\"\\\"peerDependencies\\\"\") {\n        Some(DependencyType::Peer)\n    } else if line.contains(\"\\\"optionalDependencies\\\"\") {\n        Some(DependencyType::Optional)\n    } else {\n        None\n    }\n}\n\nfn parse_dependency_line(\n    line: &str,\n    line_num: u32,\n    dep_type: DependencyType,\n) -> Option<Dependency> {\n    // Match pattern: \"package-name\": \"version\"\n    // Find the first quoted string (package name)\n    let first_quote = line.find('\"')?;\n    let after_first = &line[first_quote + 1..];\n    let name_end = after_first.find('\"')?;\n    let name = &after_first[..name_end];\n\n    // Skip if it looks like a section header\n    if name.ends_with(\"ependencies\") {\n        return None;\n    }\n\n    // Find the colon\n    let colon_pos = line.find(':')?;\n\n    // Find the version string (after the colon)\n    let after_colon = &line[colon_pos + 1..];\n    let version_first_quote = after_colon.find('\"')?;\n    let version_start_in_after = version_first_quote + 1;\n    let after_version_quote = &after_colon[version_start_in_after..];\n    let version_end_in_after = after_version_quote.find('\"')?;\n    let version = &after_version_quote[..version_end_in_after];\n\n    // Calculate absolute positions\n    let name_start = (first_quote + 1) as u32;\n    let name_end_pos = name_start + name.len() as u32;\n\n    let version_abs_start = (colon_pos + 1 + version_start_in_after) as u32;\n    let version_abs_end = version_abs_start + version.len() as u32;\n\n    Some(Dependency {\n        name: name.to_string(),\n        version: version.to_string(),\n        line: line_num,\n        name_start,\n        name_end: name_end_pos,\n        version_start: version_abs_start,\n        version_end: version_abs_end,\n        dev: dep_type == DependencyType::Dev,\n        optional: dep_type == DependencyType::Optional || dep_type == DependencyType::Peer,\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_dependencies() {\n        let parser = NpmParser::new();\n        let content = r#\"{\n  \"name\": \"my-app\",\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"lodash\": \"4.17.21\"\n  }\n}\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 2);\n\n        let react = deps.iter().find(|d| d.name == \"react\").unwrap();\n        assert_eq!(react.version, \"^18.2.0\");\n        assert!(!react.dev);\n\n        let lodash = deps.iter().find(|d| d.name == \"lodash\").unwrap();\n        assert_eq!(lodash.version, \"4.17.21\");\n    }\n\n    #[test]\n    fn test_dev_dependencies() {\n        let parser = NpmParser::new();\n        let content = r#\"{\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\",\n    \"jest\": \"^29.0.0\"\n  }\n}\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 2);\n\n        for dep in &deps {\n            assert!(dep.dev);\n        }\n    }\n\n    #[test]\n    fn test_multiple_sections() {\n        let parser = NpmParser::new();\n        let content = r#\"{\n  \"name\": \"test\",\n  \"dependencies\": {\n    \"express\": \"^4.18.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.0\"\n  },\n  \"peerDependencies\": {\n    \"react\": \"^18.0.0\"\n  }\n}\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 3);\n\n        let express = deps.iter().find(|d| d.name == \"express\").unwrap();\n        assert!(!express.dev);\n        assert!(!express.optional);\n\n        let nodemon = deps.iter().find(|d| d.name == \"nodemon\").unwrap();\n        assert!(nodemon.dev);\n\n        let react = deps.iter().find(|d| d.name == \"react\").unwrap();\n        assert!(react.optional); // peer deps marked as optional\n    }\n\n    #[test]\n    fn test_scoped_packages() {\n        let parser = NpmParser::new();\n        let content = r#\"{\n  \"dependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"@babel/core\": \"^7.22.0\"\n  }\n}\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 2);\n\n        let types_node = deps.iter().find(|d| d.name == \"@types/node\").unwrap();\n        assert_eq!(types_node.version, \"^20.0.0\");\n\n        let babel = deps.iter().find(|d| d.name == \"@babel/core\").unwrap();\n        assert_eq!(babel.version, \"^7.22.0\");\n    }\n\n    #[test]\n    fn test_version_ranges() {\n        let parser = NpmParser::new();\n        let content = r#\"{\n  \"dependencies\": {\n    \"pkg1\": \"^1.0.0\",\n    \"pkg2\": \"~2.0.0\",\n    \"pkg3\": \">=3.0.0 <4.0.0\",\n    \"pkg4\": \"1.0.0 - 2.0.0\",\n    \"pkg5\": \"*\"\n  }\n}\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 5);\n\n        assert_eq!(\n            deps.iter().find(|d| d.name == \"pkg1\").unwrap().version,\n            \"^1.0.0\"\n        );\n        assert_eq!(\n            deps.iter().find(|d| d.name == \"pkg3\").unwrap().version,\n            \">=3.0.0 <4.0.0\"\n        );\n        assert_eq!(deps.iter().find(|d| d.name == \"pkg5\").unwrap().version, \"*\");\n    }\n\n    #[test]\n    fn test_inline_format() {\n        let parser = NpmParser::new();\n        let content = r#\"{\"dependencies\": {\"pkg\": \"1.0.0\"}}\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"pkg\");\n        assert_eq!(deps[0].version, \"1.0.0\");\n    }\n}\n","traces":[{"line":16,"address":[19965494,19966258,19963088],"length":1,"stats":{"Line":4}},{"line":17,"address":[14177935],"length":1,"stats":{"Line":3}},{"line":20,"address":[14697932],"length":1,"stats":{"Line":4}},{"line":21,"address":[14196264],"length":1,"stats":{"Line":4}},{"line":22,"address":[14697951],"length":1,"stats":{"Line":3}},{"line":24,"address":[14178054,14178003],"length":1,"stats":{"Line":9}},{"line":25,"address":[14698223],"length":1,"stats":{"Line":6}},{"line":26,"address":[14698328,14698230],"length":1,"stats":{"Line":9}},{"line":29,"address":[14196672],"length":1,"stats":{"Line":3}},{"line":30,"address":[14178476],"length":1,"stats":{"Line":3}},{"line":32,"address":[14698443,14698521,14699565],"length":1,"stats":{"Line":10}},{"line":33,"address":[14197902,14196905,14197793],"length":1,"stats":{"Line":6}},{"line":34,"address":[14196859,14196970,14197751],"length":1,"stats":{"Line":10}},{"line":35,"address":[14699424,14699315,14698690],"length":1,"stats":{"Line":6}},{"line":36,"address":[19964521,19963892,19964003],"length":1,"stats":{"Line":9}},{"line":37,"address":[14197501,14197139,14197610],"length":1,"stats":{"Line":0}},{"line":38,"address":[14698890,14698872,14698761,14699128],"length":1,"stats":{"Line":13}},{"line":39,"address":[14699024,14699133,14698892],"length":1,"stats":{"Line":11}},{"line":41,"address":[14178922],"length":1,"stats":{"Line":0}},{"line":44,"address":[14178991,14179651],"length":1,"stats":{"Line":12}},{"line":45,"address":[19964887],"length":1,"stats":{"Line":8}},{"line":46,"address":[14198020],"length":1,"stats":{"Line":5}},{"line":47,"address":[14198028],"length":1,"stats":{"Line":8}},{"line":51,"address":[14198039],"length":1,"stats":{"Line":5}},{"line":52,"address":[19965041],"length":1,"stats":{"Line":8}},{"line":54,"address":[14198246,14198427],"length":1,"stats":{"Line":12}},{"line":55,"address":[14180256,14180305],"length":1,"stats":{"Line":4}},{"line":63,"address":[14196817,14198611],"length":1,"stats":{"Line":10}},{"line":64,"address":[14700281],"length":1,"stats":{"Line":5}},{"line":65,"address":[14180355,14180459],"length":1,"stats":{"Line":0}},{"line":67,"address":[14180431],"length":1,"stats":{"Line":0}},{"line":68,"address":[14198727],"length":1,"stats":{"Line":0}},{"line":73,"address":[14198617],"length":1,"stats":{"Line":5}},{"line":74,"address":[14180504],"length":1,"stats":{"Line":7}},{"line":75,"address":[19965860],"length":1,"stats":{"Line":5}},{"line":76,"address":[14199221,14199265],"length":1,"stats":{"Line":0}},{"line":78,"address":[14700968,14700885,14700946],"length":1,"stats":{"Line":12}},{"line":79,"address":[19966201,19966253],"length":1,"stats":{"Line":12}},{"line":80,"address":[14700989],"length":1,"stats":{"Line":7}},{"line":81,"address":[14700997],"length":1,"stats":{"Line":5}},{"line":90,"address":[14198756,14198990],"length":1,"stats":{"Line":12}},{"line":91,"address":[14180720],"length":1,"stats":{"Line":5}},{"line":92,"address":[19965945],"length":1,"stats":{"Line":7}},{"line":94,"address":[14199189],"length":1,"stats":{"Line":8}},{"line":98,"address":[14178309],"length":1,"stats":{"Line":7}},{"line":112,"address":[14697376,14697484,14695056],"length":1,"stats":{"Line":9}},{"line":117,"address":[14175151],"length":1,"stats":{"Line":5}},{"line":118,"address":[14175181],"length":1,"stats":{"Line":9}},{"line":120,"address":[14175305,14177396,14175197],"length":1,"stats":{"Line":16}},{"line":121,"address":[14695330,14695467],"length":1,"stats":{"Line":4}},{"line":122,"address":[14175596],"length":1,"stats":{"Line":2}},{"line":125,"address":[14175718],"length":1,"stats":{"Line":2}},{"line":128,"address":[14194094,14194211],"length":1,"stats":{"Line":4}},{"line":129,"address":[19961114,19962654],"length":1,"stats":{"Line":0}},{"line":134,"address":[14194225],"length":1,"stats":{"Line":2}},{"line":135,"address":[14176090],"length":1,"stats":{"Line":2}},{"line":136,"address":[14696201],"length":1,"stats":{"Line":0}},{"line":137,"address":[14176238],"length":1,"stats":{"Line":0}},{"line":140,"address":[14194555,14194472],"length":1,"stats":{"Line":4}},{"line":141,"address":[19961603],"length":1,"stats":{"Line":2}},{"line":142,"address":[14176508],"length":1,"stats":{"Line":0}},{"line":143,"address":[14696503],"length":1,"stats":{"Line":0}},{"line":146,"address":[19961780,19961697],"length":1,"stats":{"Line":4}},{"line":147,"address":[14696629],"length":1,"stats":{"Line":2}},{"line":148,"address":[19962012],"length":1,"stats":{"Line":0}},{"line":152,"address":[19962059,19961974],"length":1,"stats":{"Line":4}},{"line":154,"address":[14697098],"length":1,"stats":{"Line":2}},{"line":155,"address":[14195152],"length":1,"stats":{"Line":2}},{"line":156,"address":[19962120],"length":1,"stats":{"Line":2}},{"line":162,"address":[14696935],"length":1,"stats":{"Line":2}},{"line":163,"address":[14177023],"length":1,"stats":{"Line":2}},{"line":166,"address":[14177289],"length":1,"stats":{"Line":2}},{"line":169,"address":[14193709],"length":1,"stats":{"Line":5}},{"line":172,"address":[14191280],"length":1,"stats":{"Line":5}},{"line":173,"address":[14173006],"length":1,"stats":{"Line":4}},{"line":175,"address":[14693084,14693020],"length":1,"stats":{"Line":8}},{"line":176,"address":[14173122],"length":1,"stats":{"Line":3}},{"line":177,"address":[14173067,14173174],"length":1,"stats":{"Line":7}},{"line":178,"address":[14173169],"length":1,"stats":{"Line":3}},{"line":179,"address":[14191502,14191433],"length":1,"stats":{"Line":8}},{"line":180,"address":[19958441],"length":1,"stats":{"Line":3}},{"line":181,"address":[19958460,19958417,19958453],"length":1,"stats":{"Line":8}},{"line":182,"address":[14173223],"length":1,"stats":{"Line":0}},{"line":184,"address":[14693200],"length":1,"stats":{"Line":5}},{"line":188,"address":[14191520,14193336,14193342],"length":1,"stats":{"Line":5}},{"line":195,"address":[14191621],"length":1,"stats":{"Line":7}},{"line":196,"address":[14191717,14191871],"length":1,"stats":{"Line":5}},{"line":197,"address":[14693511,14693587],"length":1,"stats":{"Line":7}},{"line":198,"address":[14191935],"length":1,"stats":{"Line":5}},{"line":201,"address":[14173698],"length":1,"stats":{"Line":7}},{"line":202,"address":[14192087],"length":1,"stats":{"Line":0}},{"line":206,"address":[14192113,14192024],"length":1,"stats":{"Line":5}},{"line":209,"address":[14173857,14174001],"length":1,"stats":{"Line":8}},{"line":210,"address":[14173946,14174022],"length":1,"stats":{"Line":6}},{"line":211,"address":[14174049,14174189],"length":1,"stats":{"Line":8}},{"line":212,"address":[14694069],"length":1,"stats":{"Line":6}},{"line":213,"address":[19959362,19959438],"length":1,"stats":{"Line":8}},{"line":214,"address":[14174247],"length":1,"stats":{"Line":6}},{"line":217,"address":[14174294,14174368],"length":1,"stats":{"Line":8}},{"line":218,"address":[14192704,14192678,14192631],"length":1,"stats":{"Line":14}},{"line":220,"address":[14174521,14174439,14174397],"length":1,"stats":{"Line":14}},{"line":221,"address":[19959723,19959781,19959837],"length":1,"stats":{"Line":14}},{"line":223,"address":[14694835],"length":1,"stats":{"Line":6}},{"line":224,"address":[14174561],"length":1,"stats":{"Line":6}},{"line":225,"address":[14174606],"length":1,"stats":{"Line":8}},{"line":231,"address":[14174667],"length":1,"stats":{"Line":6}},{"line":232,"address":[14174734],"length":1,"stats":{"Line":8}}],"covered":93,"coverable":107},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","php.rs"],"content":"//! Parser for PHP Composer files (composer.json)\n\nuse super::{Dependency, Parser};\n\n/// Parser for PHP composer.json dependency files\n#[derive(Debug, Default)]\npub struct PhpParser;\n\nimpl PhpParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for PhpParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        let mut dependencies = Vec::new();\n        let mut current_section: Option<DependencyType> = None;\n        let mut section_brace_depth = 0;\n        let mut in_section_object = false;\n\n        for (line_idx, line) in content.lines().enumerate() {\n            let line_num = line_idx as u32;\n            let trimmed = line.trim();\n\n            // Detect section start\n            if let Some(section) = detect_section(trimmed) {\n                current_section = Some(section);\n                // Check if the object starts on the same line\n                if trimmed.contains('{') {\n                    in_section_object = true;\n                    section_brace_depth = 1;\n\n                    // Try to parse inline dependencies on the same line\n                    if let Some(brace_pos) = trimmed.find('{') {\n                        let after_brace = &trimmed[brace_pos + 1..];\n                        if let Some(deps) =\n                            parse_inline_dependencies(after_brace, line_num, section, line)\n                        {\n                            dependencies.extend(deps);\n                        }\n                    }\n                }\n                continue;\n            }\n\n            // Track brace depth for current section\n            if in_section_object {\n                for ch in trimmed.chars() {\n                    match ch {\n                        '{' => section_brace_depth += 1,\n                        '}' => {\n                            section_brace_depth -= 1;\n                            if section_brace_depth == 0 {\n                                current_section = None;\n                                in_section_object = false;\n                            }\n                        }\n                        _ => {}\n                    }\n                }\n            }\n\n            // Skip if not in a dependency section\n            let dep_type = match current_section {\n                Some(dt) => dt,\n                None => continue,\n            };\n\n            // Parse dependency line\n            if let Some(dep) = parse_dependency_line(line, line_num, dep_type) {\n                dependencies.push(dep);\n            }\n        }\n\n        dependencies\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum DependencyType {\n    Normal,\n    Dev,\n}\n\n/// Detect which section we're entering\nfn detect_section(line: &str) -> Option<DependencyType> {\n    if line.contains(\"\\\"require\\\"\") && !line.contains(\"\\\"require-dev\\\"\") {\n        Some(DependencyType::Normal)\n    } else if line.contains(\"\\\"require-dev\\\"\") {\n        Some(DependencyType::Dev)\n    } else {\n        None\n    }\n}\n\n/// Parse inline dependencies (multiple on same line)\nfn parse_inline_dependencies(\n    content: &str,\n    line_num: u32,\n    dep_type: DependencyType,\n    full_line: &str,\n) -> Option<Vec<Dependency>> {\n    let mut deps = Vec::new();\n\n    // Simple parsing for inline format: \"pkg\": \"^1.0\", \"pkg2\": \"^2.0\"\n    let parts: Vec<&str> = content.split(',').collect();\n\n    for part in parts {\n        if let Some(dep) = parse_dependency_from_pair(part.trim(), line_num, dep_type, full_line) {\n            deps.push(dep);\n        }\n    }\n\n    if deps.is_empty() { None } else { Some(deps) }\n}\n\n/// Parse a single dependency line: \"vendor/package\": \"^1.0.0\"\nfn parse_dependency_line(\n    line: &str,\n    line_num: u32,\n    dep_type: DependencyType,\n) -> Option<Dependency> {\n    let trimmed = line.trim();\n\n    // Must contain a colon (key: value)\n    if !trimmed.contains(':') {\n        return None;\n    }\n\n    parse_dependency_from_pair(trimmed, line_num, dep_type, line)\n}\n\n/// Parse a \"name\": \"version\" pair\nfn parse_dependency_from_pair(\n    pair: &str,\n    line_num: u32,\n    dep_type: DependencyType,\n    full_line: &str,\n) -> Option<Dependency> {\n    // Find the colon separator\n    let colon_pos = pair.find(':')?;\n\n    let name_part = &pair[..colon_pos];\n    let version_part = &pair[colon_pos + 1..];\n\n    // Extract name from quotes\n    let name = extract_quoted_string(name_part)?;\n\n    // Skip PHP extensions and PHP itself\n    if name == \"php\" || name.starts_with(\"ext-\") {\n        return None;\n    }\n\n    // Extract version from quotes\n    let version = extract_quoted_string(version_part)?;\n\n    // Calculate positions in the original line\n    let name_start = full_line.find(&name)? as u32;\n    let name_end = name_start + name.len() as u32;\n    let version_start = full_line.rfind(&version)? as u32;\n    let version_end = version_start + version.len() as u32;\n\n    Some(Dependency {\n        name,\n        version,\n        line: line_num,\n        name_start,\n        name_end,\n        version_start,\n        version_end,\n        dev: dep_type == DependencyType::Dev,\n        optional: false,\n    })\n}\n\n/// Extract a string value from a quoted string\nfn extract_quoted_string(s: &str) -> Option<String> {\n    let trimmed = s.trim();\n\n    // Find the first quote\n    let start_quote = trimmed.find('\"')?;\n    let after_quote = &trimmed[start_quote + 1..];\n\n    // Find the closing quote\n    let end_quote = after_quote.find('\"')?;\n\n    Some(after_quote[..end_quote].to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_dependencies() {\n        let parser = PhpParser::new();\n        let content = r#\"\n{\n    \"name\": \"myproject\",\n    \"require\": {\n        \"php\": \">=8.1\",\n        \"laravel/framework\": \"^10.0\",\n        \"guzzlehttp/guzzle\": \"^7.0\"\n    }\n}\n\"#;\n        let deps = parser.parse(content);\n        // Should have laravel and guzzle, not php\n        assert_eq!(deps.len(), 2);\n\n        let laravel = deps.iter().find(|d| d.name.contains(\"laravel\")).unwrap();\n        assert_eq!(laravel.version, \"^10.0\");\n        assert!(!laravel.dev);\n    }\n\n    #[test]\n    fn test_dev_dependencies() {\n        let parser = PhpParser::new();\n        let content = r#\"\n{\n    \"require\": {\n        \"laravel/framework\": \"^10.0\"\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \"^10.0\",\n        \"mockery/mockery\": \"^1.5\"\n    }\n}\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 3);\n\n        let laravel = deps.iter().find(|d| d.name.contains(\"laravel\")).unwrap();\n        assert!(!laravel.dev);\n\n        let phpunit = deps.iter().find(|d| d.name.contains(\"phpunit\")).unwrap();\n        assert!(phpunit.dev);\n\n        let mockery = deps.iter().find(|d| d.name.contains(\"mockery\")).unwrap();\n        assert!(mockery.dev);\n    }\n\n    #[test]\n    fn test_skip_extensions() {\n        let parser = PhpParser::new();\n        let content = r#\"\n{\n    \"require\": {\n        \"php\": \">=8.1\",\n        \"ext-json\": \"*\",\n        \"ext-mbstring\": \"*\",\n        \"laravel/framework\": \"^10.0\"\n    }\n}\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"laravel/framework\");\n    }\n\n    #[test]\n    fn test_version_constraints() {\n        let parser = PhpParser::new();\n        let content = r#\"\n{\n    \"require\": {\n        \"vendor/exact\": \"1.0.0\",\n        \"vendor/caret\": \"^1.0\",\n        \"vendor/tilde\": \"~1.0\",\n        \"vendor/range\": \">=1.0 <2.0\"\n    }\n}\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 4);\n\n        let exact = deps.iter().find(|d| d.name.contains(\"exact\")).unwrap();\n        assert_eq!(exact.version, \"1.0.0\");\n\n        let caret = deps.iter().find(|d| d.name.contains(\"caret\")).unwrap();\n        assert_eq!(caret.version, \"^1.0\");\n    }\n\n    #[test]\n    fn test_version_position() {\n        let parser = PhpParser::new();\n        let content = r#\"{\n    \"require\": {\n        \"vendor/pkg\": \"^1.0.0\"\n    }\n}\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n\n        let dep = &deps[0];\n        assert_eq!(dep.name, \"vendor/pkg\");\n        assert_eq!(dep.version, \"^1.0.0\");\n    }\n}\n","traces":[{"line":16,"address":[12571405,12571411,12569792],"length":1,"stats":{"Line":6}},{"line":17,"address":[13764815],"length":1,"stats":{"Line":7}},{"line":18,"address":[13793776],"length":1,"stats":{"Line":6}},{"line":19,"address":[17302276],"length":1,"stats":{"Line":7}},{"line":20,"address":[12569903],"length":1,"stats":{"Line":7}},{"line":22,"address":[17302350,17302303],"length":1,"stats":{"Line":14}},{"line":23,"address":[12570175],"length":1,"stats":{"Line":5}},{"line":24,"address":[12570182,12570280],"length":1,"stats":{"Line":12}},{"line":27,"address":[12570312],"length":1,"stats":{"Line":7}},{"line":28,"address":[17302773],"length":1,"stats":{"Line":7}},{"line":30,"address":[13765407,13765364],"length":1,"stats":{"Line":9}},{"line":31,"address":[13765426],"length":1,"stats":{"Line":2}},{"line":32,"address":[17302850],"length":1,"stats":{"Line":7}},{"line":35,"address":[13794373],"length":1,"stats":{"Line":2}},{"line":36,"address":[12570563],"length":1,"stats":{"Line":7}},{"line":37,"address":[17303080],"length":1,"stats":{"Line":2}},{"line":40,"address":[12570814],"length":1,"stats":{"Line":0}},{"line":48,"address":[12570416],"length":1,"stats":{"Line":7}},{"line":49,"address":[13765844],"length":1,"stats":{"Line":2}},{"line":50,"address":[12571028],"length":1,"stats":{"Line":7}},{"line":51,"address":[12571260,12571304],"length":1,"stats":{"Line":0}},{"line":53,"address":[13766317,13766339,13766256],"length":1,"stats":{"Line":10}},{"line":54,"address":[12571348,12571400],"length":1,"stats":{"Line":10}},{"line":55,"address":[13795288],"length":1,"stats":{"Line":8}},{"line":56,"address":[13766368],"length":1,"stats":{"Line":2}},{"line":65,"address":[13794726],"length":1,"stats":{"Line":5}},{"line":66,"address":[12571077],"length":1,"stats":{"Line":2}},{"line":71,"address":[12571104],"length":1,"stats":{"Line":7}},{"line":72,"address":[13766204],"length":1,"stats":{"Line":8}},{"line":76,"address":[12570221],"length":1,"stats":{"Line":2}},{"line":87,"address":[17297792],"length":1,"stats":{"Line":5}},{"line":88,"address":[12565783,12565847],"length":1,"stats":{"Line":14}},{"line":89,"address":[13760797],"length":1,"stats":{"Line":2}},{"line":90,"address":[13760823,13760816,13760742],"length":1,"stats":{"Line":12}},{"line":91,"address":[13789746],"length":1,"stats":{"Line":2}},{"line":93,"address":[13789739],"length":1,"stats":{"Line":7}},{"line":98,"address":[13762399,13762405,13761456],"length":1,"stats":{"Line":7}},{"line":104,"address":[17298688],"length":1,"stats":{"Line":2}},{"line":107,"address":[12566692,12566753],"length":1,"stats":{"Line":9}},{"line":109,"address":[17298812,17298986],"length":1,"stats":{"Line":9}},{"line":110,"address":[13761969,13762220],"length":1,"stats":{"Line":9}},{"line":111,"address":[12567442],"length":1,"stats":{"Line":0}},{"line":115,"address":[13790936],"length":1,"stats":{"Line":7}},{"line":119,"address":[17298352],"length":1,"stats":{"Line":2}},{"line":124,"address":[12566391],"length":1,"stats":{"Line":7}},{"line":127,"address":[17298454],"length":1,"stats":{"Line":2}},{"line":128,"address":[13761370],"length":1,"stats":{"Line":0}},{"line":131,"address":[12566490],"length":1,"stats":{"Line":7}},{"line":135,"address":[12567488,12569367,12569476],"length":1,"stats":{"Line":7}},{"line":142,"address":[17299664],"length":1,"stats":{"Line":2}},{"line":144,"address":[13791632],"length":1,"stats":{"Line":2}},{"line":145,"address":[17299844,17300033],"length":1,"stats":{"Line":7}},{"line":148,"address":[17300054,17299959],"length":1,"stats":{"Line":2}},{"line":151,"address":[13792055,13791978,13792128],"length":1,"stats":{"Line":12}},{"line":152,"address":[12568223],"length":1,"stats":{"Line":4}},{"line":156,"address":[17300347,17301482],"length":1,"stats":{"Line":2}},{"line":159,"address":[17301448,17300532,17300600],"length":1,"stats":{"Line":10}},{"line":160,"address":[13792659,13792568],"length":1,"stats":{"Line":8}},{"line":161,"address":[12568752,12568799,12569395],"length":1,"stats":{"Line":10}},{"line":162,"address":[13792959,13792807],"length":1,"stats":{"Line":2}},{"line":164,"address":[13793061],"length":1,"stats":{"Line":2}},{"line":165,"address":[17300991],"length":1,"stats":{"Line":8}},{"line":166,"address":[13763965],"length":1,"stats":{"Line":2}},{"line":172,"address":[13792933],"length":1,"stats":{"Line":8}},{"line":178,"address":[12565904],"length":1,"stats":{"Line":7}},{"line":179,"address":[12565963],"length":1,"stats":{"Line":2}},{"line":182,"address":[12566000],"length":1,"stats":{"Line":7}},{"line":183,"address":[13790051,13789929],"length":1,"stats":{"Line":2}},{"line":186,"address":[13761077,13761141],"length":1,"stats":{"Line":7}},{"line":188,"address":[13761171],"length":1,"stats":{"Line":2}}],"covered":66,"coverable":70},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","python.rs"],"content":"//! Parser for Python dependency files (requirements.txt, pyproject.toml)\n\nuse super::{Dependency, Parser};\n\n/// Parser for Python dependency files\n#[derive(Debug, Default)]\npub struct PythonParser;\n\nimpl PythonParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for PythonParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        // Detect file type based on content\n        if content.trim_start().starts_with('[')\n            || content.contains(\"[project]\")\n            || content.contains(\"[tool.poetry\")\n        {\n            parse_pyproject_toml(content)\n        } else {\n            parse_requirements_txt(content)\n        }\n    }\n}\n\n/// Parse requirements.txt format\n/// Format: package==1.0.0, package>=1.0.0, package~=1.0.0, etc.\nfn parse_requirements_txt(content: &str) -> Vec<Dependency> {\n    let mut dependencies = Vec::new();\n\n    for (line_idx, line) in content.lines().enumerate() {\n        let line_num = line_idx as u32;\n        let trimmed = line.trim();\n\n        // Skip empty lines, comments, and special directives\n        if trimmed.is_empty()\n            || trimmed.starts_with('#')\n            || trimmed.starts_with('-')  // -r, -e, -c, etc.\n            || trimmed.starts_with(\"--\")\n        // --index-url, etc.\n        {\n            continue;\n        }\n\n        // Skip URL dependencies (package @ https://...)\n        if trimmed.contains(\" @ \") {\n            continue;\n        }\n\n        if let Some(dep) = parse_requirement_line(line, line_num, false) {\n            dependencies.push(dep);\n        }\n    }\n\n    dependencies\n}\n\n/// Parse a single requirement line\nfn parse_requirement_line(line: &str, line_num: u32, dev: bool) -> Option<Dependency> {\n    let trimmed = line.trim();\n\n    // Remove inline comments\n    let without_comment = if let Some(pos) = trimmed.find('#') {\n        &trimmed[..pos]\n    } else {\n        trimmed\n    };\n    let without_comment = without_comment.trim();\n\n    if without_comment.is_empty() {\n        return None;\n    }\n\n    // Extract package name (before version specifier or extras)\n    // Operators: ==, >=, <=, !=, ~=, >, <, ===\n    let operators = [\"===\", \"==\", \">=\", \"<=\", \"!=\", \"~=\", \">\", \"<\"];\n\n    let mut name_end_pos = without_comment.len();\n    let mut version_op_pos = None;\n    let mut version_op_len = 0;\n\n    for op in &operators {\n        if let Some(pos) = without_comment.find(op)\n            && pos < name_end_pos\n        {\n            name_end_pos = pos;\n            version_op_pos = Some(pos);\n            version_op_len = op.len();\n        }\n    }\n\n    // Handle extras: package[extra1,extra2]>=1.0\n    let name_part = &without_comment[..name_end_pos];\n    let name = if let Some(bracket_pos) = name_part.find('[') {\n        &name_part[..bracket_pos]\n    } else {\n        name_part\n    };\n    let name = name.trim();\n\n    if name.is_empty() {\n        return None;\n    }\n\n    // Extract version\n    let version = if let Some(op_pos) = version_op_pos {\n        let version_part = &without_comment[op_pos + version_op_len..];\n        // Handle comma-separated version constraints: >=1.0,<2.0\n        let version = if let Some(comma_pos) = version_part.find(',') {\n            &version_part[..comma_pos]\n        } else {\n            version_part\n        };\n        // Remove environment markers: ; python_version >= \"3.8\"\n        let version = if let Some(semi_pos) = version.find(';') {\n            &version[..semi_pos]\n        } else {\n            version\n        };\n        version.trim().to_string()\n    } else {\n        // No version specified\n        return None;\n    };\n\n    if version.is_empty() {\n        return None;\n    }\n\n    // Calculate positions\n    let name_start = line.find(name)? as u32;\n    let name_end = name_start + name.len() as u32;\n\n    // Find version position in the original line\n    let version_start = line.find(&version)? as u32;\n    let version_end = version_start + version.len() as u32;\n\n    Some(Dependency {\n        name: name.to_string(),\n        version,\n        line: line_num,\n        name_start,\n        name_end,\n        version_start,\n        version_end,\n        dev,\n        optional: false,\n    })\n}\n\n/// Parse pyproject.toml format (PEP 621 + Poetry)\nfn parse_pyproject_toml(content: &str) -> Vec<Dependency> {\n    let mut dependencies = Vec::new();\n\n    // Parse using toml crate for structure, but we need line positions\n    // So we'll do a hybrid approach: parse TOML for structure, then find positions manually\n\n    let table: toml::Table = match content.parse() {\n        Ok(t) => t,\n        Err(_) => return dependencies,\n    };\n\n    // PEP 621: [project.dependencies] array of strings\n    if let Some(project) = table.get(\"project\").and_then(|v| v.as_table()) {\n        // [project.dependencies]\n        if let Some(deps) = project.get(\"dependencies\").and_then(|v| v.as_array()) {\n            for dep_str in deps.iter().filter_map(|v| v.as_str()) {\n                if let Some((name, version)) = parse_pep508_dependency(dep_str)\n                    && let Some(dep) = find_dependency_position(content, &name, &version, false)\n                {\n                    dependencies.push(dep);\n                }\n            }\n        }\n\n        // [project.optional-dependencies]\n        if let Some(optional_deps) = project\n            .get(\"optional-dependencies\")\n            .and_then(|v| v.as_table())\n        {\n            for (_group, deps) in optional_deps {\n                if let Some(deps_array) = deps.as_array() {\n                    for dep_str in deps_array.iter().filter_map(|v| v.as_str()) {\n                        if let Some((name, version)) = parse_pep508_dependency(dep_str)\n                            && let Some(dep) =\n                                find_dependency_position(content, &name, &version, true)\n                        {\n                            dependencies.push(dep);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Poetry: [tool.poetry.dependencies] table\n    if let Some(tool) = table.get(\"tool\").and_then(|v| v.as_table())\n        && let Some(poetry) = tool.get(\"poetry\").and_then(|v| v.as_table())\n    {\n        // [tool.poetry.dependencies]\n        if let Some(deps) = poetry.get(\"dependencies\").and_then(|v| v.as_table()) {\n            for (name, value) in deps {\n                // Skip python itself\n                if name == \"python\" {\n                    continue;\n                }\n                if let Some(version) = extract_poetry_version(value)\n                    && let Some(dep) =\n                        find_poetry_dependency_position(content, name, &version, false)\n                {\n                    dependencies.push(dep);\n                }\n            }\n        }\n\n        // [tool.poetry.dev-dependencies] (Poetry < 1.2)\n        if let Some(deps) = poetry.get(\"dev-dependencies\").and_then(|v| v.as_table()) {\n            for (name, value) in deps {\n                if let Some(version) = extract_poetry_version(value)\n                    && let Some(dep) =\n                        find_poetry_dependency_position(content, name, &version, true)\n                {\n                    dependencies.push(dep);\n                }\n            }\n        }\n\n        // [tool.poetry.group.dev.dependencies] (Poetry >= 1.2)\n        if let Some(groups) = poetry.get(\"group\").and_then(|v| v.as_table()) {\n            for (group_name, group_value) in groups {\n                let is_dev = group_name == \"dev\" || group_name == \"test\";\n                if let Some(group_table) = group_value.as_table()\n                    && let Some(deps) = group_table.get(\"dependencies\").and_then(|v| v.as_table())\n                {\n                    for (name, value) in deps {\n                        if let Some(version) = extract_poetry_version(value)\n                            && let Some(dep) =\n                                find_poetry_dependency_position(content, name, &version, is_dev)\n                        {\n                            dependencies.push(dep);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    dependencies\n}\n\n/// Parse PEP 508 dependency string: \"package>=1.0.0\" or \"package[extra]>=1.0.0\"\nfn parse_pep508_dependency(dep_str: &str) -> Option<(String, String)> {\n    let trimmed = dep_str.trim();\n\n    // Remove environment markers\n    let without_markers = if let Some(semi_pos) = trimmed.find(';') {\n        &trimmed[..semi_pos]\n    } else {\n        trimmed\n    };\n    let without_markers = without_markers.trim();\n\n    // Find version operator\n    let operators = [\"===\", \"==\", \">=\", \"<=\", \"!=\", \"~=\", \">\", \"<\"];\n    let mut op_pos = None;\n    let mut op_len = 0;\n\n    for op in &operators {\n        if let Some(pos) = without_markers.find(op)\n            && (op_pos.is_none() || pos < op_pos.unwrap())\n        {\n            op_pos = Some(pos);\n            op_len = op.len();\n        }\n    }\n\n    let op_pos = op_pos?;\n\n    // Extract name (handle extras)\n    let name_part = &without_markers[..op_pos];\n    let name = if let Some(bracket_pos) = name_part.find('[') {\n        &name_part[..bracket_pos]\n    } else {\n        name_part\n    };\n    let name = name.trim();\n\n    // Extract version\n    let version_part = &without_markers[op_pos + op_len..];\n    let version = if let Some(comma_pos) = version_part.find(',') {\n        &version_part[..comma_pos]\n    } else {\n        version_part\n    };\n    let version = version.trim();\n\n    if name.is_empty() || version.is_empty() {\n        return None;\n    }\n\n    Some((name.to_string(), version.to_string()))\n}\n\n/// Extract version from Poetry dependency value\nfn extract_poetry_version(value: &toml::Value) -> Option<String> {\n    match value {\n        toml::Value::String(s) => Some(s.clone()),\n        toml::Value::Table(t) => t\n            .get(\"version\")\n            .and_then(|v| v.as_str())\n            .map(|s| s.to_string()),\n        _ => None,\n    }\n}\n\n/// Find position of a dependency in PEP 621 format (array of strings)\nfn find_dependency_position(\n    content: &str,\n    name: &str,\n    version: &str,\n    dev: bool,\n) -> Option<Dependency> {\n    for (line_idx, line) in content.lines().enumerate() {\n        // Look for the dependency string in an array\n        if line.contains(name) && line.contains(version) {\n            // Check it's likely a dependency line (contains quotes and version operator)\n            if line.contains('\"') || line.contains('\\'') {\n                let line_num = line_idx as u32;\n\n                // Find name position\n                let name_start = line.find(name)? as u32;\n                let name_end = name_start + name.len() as u32;\n\n                // Find version position\n                let version_start = line.find(version)? as u32;\n                let version_end = version_start + version.len() as u32;\n\n                return Some(Dependency {\n                    name: name.to_string(),\n                    version: version.to_string(),\n                    line: line_num,\n                    name_start,\n                    name_end,\n                    version_start,\n                    version_end,\n                    dev,\n                    optional: dev, // optional-dependencies are optional\n                });\n            }\n        }\n    }\n    None\n}\n\n/// Find position of a Poetry dependency (table format)\nfn find_poetry_dependency_position(\n    content: &str,\n    name: &str,\n    version: &str,\n    dev: bool,\n) -> Option<Dependency> {\n    for (line_idx, line) in content.lines().enumerate() {\n        let trimmed = line.trim();\n\n        // Poetry format: name = \"version\" or name = { version = \"...\" }\n        if trimmed.starts_with(name) && trimmed.contains('=') {\n            // Check this line contains the version\n            if line.contains(version) {\n                let line_num = line_idx as u32;\n\n                // Find name position\n                let name_start = line.find(name)? as u32;\n                let name_end = name_start + name.len() as u32;\n\n                // Find version position (inside quotes)\n                let version_start = line.find(version)? as u32;\n                let version_end = version_start + version.len() as u32;\n\n                return Some(Dependency {\n                    name: name.to_string(),\n                    version: version.to_string(),\n                    line: line_num,\n                    name_start,\n                    name_end,\n                    version_start,\n                    version_end,\n                    dev,\n                    optional: false,\n                });\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_requirements_simple() {\n        let parser = PythonParser::new();\n        let content = r#\"\nflask==2.0.0\nrequests>=2.25.0\ndjango~=4.0\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 3);\n\n        let flask = deps.iter().find(|d| d.name == \"flask\").unwrap();\n        assert_eq!(flask.version, \"2.0.0\");\n\n        let requests = deps.iter().find(|d| d.name == \"requests\").unwrap();\n        assert_eq!(requests.version, \"2.25.0\");\n\n        let django = deps.iter().find(|d| d.name == \"django\").unwrap();\n        assert_eq!(django.version, \"4.0\");\n    }\n\n    #[test]\n    fn test_requirements_with_extras() {\n        let parser = PythonParser::new();\n        let content = \"uvicorn[standard]>=0.20.0\";\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"uvicorn\");\n        assert_eq!(deps[0].version, \"0.20.0\");\n    }\n\n    #[test]\n    fn test_requirements_with_comments() {\n        let parser = PythonParser::new();\n        let content = r#\"\n# This is a comment\nflask==2.0.0  # inline comment\n# Another comment\nrequests>=2.25.0\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 2);\n    }\n\n    #[test]\n    fn test_requirements_skip_special() {\n        let parser = PythonParser::new();\n        let content = r#\"\n-r other.txt\n-e git+https://github.com/user/repo.git\n--index-url https://pypi.org/simple\nflask==2.0.0\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"flask\");\n    }\n\n    #[test]\n    fn test_pyproject_pep621() {\n        let parser = PythonParser::new();\n        let content = r#\"\n[project]\nname = \"myproject\"\ndependencies = [\n    \"flask>=2.0.0\",\n    \"requests~=2.25.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.0.0\",\n]\n\"#;\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 3);\n\n        let flask = deps.iter().find(|d| d.name == \"flask\").unwrap();\n        assert_eq!(flask.version, \"2.0.0\");\n        assert!(!flask.dev);\n\n        let pytest = deps.iter().find(|d| d.name == \"pytest\").unwrap();\n        assert_eq!(pytest.version, \"7.0.0\");\n        assert!(pytest.dev);\n    }\n\n    #[test]\n    fn test_pyproject_poetry() {\n        let parser = PythonParser::new();\n        let content = r#\"\n[tool.poetry]\nname = \"myproject\"\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nflask = \"^2.0.0\"\nrequests = { version = \"^2.25.0\", optional = true }\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.0.0\"\n\"#;\n        let deps = parser.parse(content);\n        // Should have flask, requests, pytest (python is skipped)\n        assert_eq!(deps.len(), 3);\n\n        let flask = deps.iter().find(|d| d.name == \"flask\").unwrap();\n        assert_eq!(flask.version, \"^2.0.0\");\n        assert!(!flask.dev);\n\n        let pytest = deps.iter().find(|d| d.name == \"pytest\").unwrap();\n        assert_eq!(pytest.version, \"^7.0.0\");\n        assert!(pytest.dev);\n    }\n\n    #[test]\n    fn test_version_position() {\n        let parser = PythonParser::new();\n        let content = \"flask==2.0.0\";\n        let deps = parser.parse(content);\n        assert_eq!(deps.len(), 1);\n\n        let dep = &deps[0];\n        assert_eq!(dep.name_start, 0);\n        assert_eq!(dep.name_end, 5);\n        assert_eq!(dep.version_start, 7);\n        assert_eq!(dep.version_end, 12);\n    }\n}\n","traces":[{"line":16,"address":[14478640],"length":1,"stats":{"Line":2}},{"line":18,"address":[14449765],"length":1,"stats":{"Line":3}},{"line":19,"address":[14449800],"length":1,"stats":{"Line":2}},{"line":20,"address":[14449854],"length":1,"stats":{"Line":3}},{"line":22,"address":[13433406],"length":1,"stats":{"Line":3}},{"line":24,"address":[14449890],"length":1,"stats":{"Line":3}},{"line":31,"address":[14444672,14445505,14445511],"length":1,"stats":{"Line":3}},{"line":32,"address":[14444715],"length":1,"stats":{"Line":4}},{"line":34,"address":[13428371,13428327],"length":1,"stats":{"Line":6}},{"line":35,"address":[14444995],"length":1,"stats":{"Line":3}},{"line":36,"address":[13428652,13428578],"length":1,"stats":{"Line":8}},{"line":39,"address":[14445108],"length":1,"stats":{"Line":6}},{"line":40,"address":[14474071],"length":1,"stats":{"Line":3}},{"line":41,"address":[13428763],"length":1,"stats":{"Line":6}},{"line":42,"address":[14445231],"length":1,"stats":{"Line":3}},{"line":49,"address":[14445282],"length":1,"stats":{"Line":6}},{"line":53,"address":[13428924],"length":1,"stats":{"Line":3}},{"line":54,"address":[14474404],"length":1,"stats":{"Line":7}},{"line":58,"address":[14473957],"length":1,"stats":{"Line":3}},{"line":62,"address":[19032947,19032953,19030400],"length":1,"stats":{"Line":6}},{"line":63,"address":[19030510],"length":1,"stats":{"Line":3}},{"line":66,"address":[14471065,14471167],"length":1,"stats":{"Line":8}},{"line":67,"address":[14471138],"length":1,"stats":{"Line":2}},{"line":69,"address":[14471185],"length":1,"stats":{"Line":5}},{"line":71,"address":[13425873],"length":1,"stats":{"Line":5}},{"line":73,"address":[19030748],"length":1,"stats":{"Line":3}},{"line":74,"address":[14442654],"length":1,"stats":{"Line":0}},{"line":79,"address":[13425961],"length":1,"stats":{"Line":5}},{"line":81,"address":[14471505],"length":1,"stats":{"Line":3}},{"line":82,"address":[19031006],"length":1,"stats":{"Line":6}},{"line":83,"address":[14471530],"length":1,"stats":{"Line":3}},{"line":85,"address":[13426271,13426214],"length":1,"stats":{"Line":9}},{"line":86,"address":[14473492,14473588,14471693],"length":1,"stats":{"Line":15}},{"line":87,"address":[14473513],"length":1,"stats":{"Line":6}},{"line":89,"address":[14444612],"length":1,"stats":{"Line":3}},{"line":90,"address":[14473548],"length":1,"stats":{"Line":6}},{"line":91,"address":[14473568],"length":1,"stats":{"Line":3}},{"line":96,"address":[14471754],"length":1,"stats":{"Line":3}},{"line":97,"address":[19031299,19031401],"length":1,"stats":{"Line":8}},{"line":98,"address":[13426556],"length":1,"stats":{"Line":2}},{"line":100,"address":[19031419],"length":1,"stats":{"Line":3}},{"line":102,"address":[14471949],"length":1,"stats":{"Line":5}},{"line":104,"address":[14472008],"length":1,"stats":{"Line":3}},{"line":105,"address":[14443113],"length":1,"stats":{"Line":0}},{"line":109,"address":[19031503,19031545],"length":1,"stats":{"Line":8}},{"line":110,"address":[13426825,13426919,13426745],"length":1,"stats":{"Line":10}},{"line":112,"address":[13426993,13426948,13426876],"length":1,"stats":{"Line":7}},{"line":113,"address":[14443366],"length":1,"stats":{"Line":0}},{"line":115,"address":[14443413],"length":1,"stats":{"Line":3}},{"line":118,"address":[13427027,13427145],"length":1,"stats":{"Line":7}},{"line":119,"address":[14472430],"length":1,"stats":{"Line":0}},{"line":121,"address":[13427147],"length":1,"stats":{"Line":3}},{"line":123,"address":[13427179],"length":1,"stats":{"Line":7}},{"line":126,"address":[13426783],"length":1,"stats":{"Line":0}},{"line":129,"address":[14472619,14472560],"length":1,"stats":{"Line":10}},{"line":130,"address":[14472686],"length":1,"stats":{"Line":0}},{"line":134,"address":[14472657,14473471,14472714],"length":1,"stats":{"Line":10}},{"line":135,"address":[19032322,19032409],"length":1,"stats":{"Line":3}},{"line":138,"address":[13427576,13427623,13428111],"length":1,"stats":{"Line":10}},{"line":139,"address":[14444232,14444151],"length":1,"stats":{"Line":7}},{"line":141,"address":[14444341],"length":1,"stats":{"Line":3}},{"line":142,"address":[14473141],"length":1,"stats":{"Line":3}},{"line":143,"address":[13427879],"length":1,"stats":{"Line":7}},{"line":155,"address":[14470664,14464176,14466031],"length":1,"stats":{"Line":3}},{"line":156,"address":[13419015],"length":1,"stats":{"Line":3}},{"line":161,"address":[14435352,14435412],"length":1,"stats":{"Line":6}},{"line":162,"address":[14435528],"length":1,"stats":{"Line":3}},{"line":163,"address":[13419152],"length":1,"stats":{"Line":0}},{"line":167,"address":[14464631,14464722],"length":1,"stats":{"Line":10}},{"line":169,"address":[13508105,13508096],"length":1,"stats":{"Line":8}},{"line":170,"address":[19897129,19897104],"length":1,"stats":{"Line":8}},{"line":171,"address":[14436419],"length":1,"stats":{"Line":2}},{"line":172,"address":[14436688,14436535],"length":1,"stats":{"Line":4}},{"line":174,"address":[14465832],"length":1,"stats":{"Line":2}},{"line":180,"address":[19025628],"length":1,"stats":{"Line":2}},{"line":182,"address":[13420789],"length":1,"stats":{"Line":6}},{"line":184,"address":[14437203],"length":1,"stats":{"Line":2}},{"line":185,"address":[14466310],"length":1,"stats":{"Line":2}},{"line":186,"address":[19897024,19897049],"length":1,"stats":{"Line":6}},{"line":187,"address":[14437798],"length":1,"stats":{"Line":2}},{"line":188,"address":[14467123],"length":1,"stats":{"Line":2}},{"line":189,"address":[19026382,19026535],"length":1,"stats":{"Line":4}},{"line":191,"address":[14467211],"length":1,"stats":{"Line":2}},{"line":200,"address":[13419611,13422138],"length":1,"stats":{"Line":8}},{"line":201,"address":[13537065,13537056],"length":1,"stats":{"Line":8}},{"line":204,"address":[14438766],"length":1,"stats":{"Line":6}},{"line":205,"address":[14438948,14438887],"length":1,"stats":{"Line":4}},{"line":207,"address":[13422752],"length":1,"stats":{"Line":2}},{"line":210,"address":[19027634],"length":1,"stats":{"Line":2}},{"line":211,"address":[14439505],"length":1,"stats":{"Line":2}},{"line":212,"address":[14439262,14439377],"length":1,"stats":{"Line":4}},{"line":214,"address":[19028061],"length":1,"stats":{"Line":2}},{"line":220,"address":[14702937,14702928],"length":1,"stats":{"Line":8}},{"line":221,"address":[13423443,13423382],"length":1,"stats":{"Line":4}},{"line":222,"address":[14468919],"length":1,"stats":{"Line":2}},{"line":223,"address":[13423942],"length":1,"stats":{"Line":2}},{"line":224,"address":[14469114,14469007],"length":1,"stats":{"Line":4}},{"line":226,"address":[14440402],"length":1,"stats":{"Line":2}},{"line":232,"address":[14469409,14468709],"length":1,"stats":{"Line":4}},{"line":233,"address":[14469495],"length":1,"stats":{"Line":0}},{"line":234,"address":[13424374],"length":1,"stats":{"Line":0}},{"line":235,"address":[14469789],"length":1,"stats":{"Line":0}},{"line":236,"address":[14469869],"length":1,"stats":{"Line":0}},{"line":238,"address":[19029486],"length":1,"stats":{"Line":0}},{"line":239,"address":[14470162],"length":1,"stats":{"Line":0}},{"line":240,"address":[13425140],"length":1,"stats":{"Line":0}},{"line":241,"address":[14470336,14470247],"length":1,"stats":{"Line":0}},{"line":243,"address":[14441612],"length":1,"stats":{"Line":0}},{"line":251,"address":[19027071],"length":1,"stats":{"Line":2}},{"line":255,"address":[19035519,19033920,19035513],"length":1,"stats":{"Line":2}},{"line":256,"address":[13429181],"length":1,"stats":{"Line":2}},{"line":259,"address":[13429326,13429224],"length":1,"stats":{"Line":2}},{"line":260,"address":[14445729],"length":1,"stats":{"Line":0}},{"line":262,"address":[14474704],"length":1,"stats":{"Line":2}},{"line":264,"address":[14474720],"length":1,"stats":{"Line":2}},{"line":267,"address":[14445839],"length":1,"stats":{"Line":2}},{"line":268,"address":[19034439],"length":1,"stats":{"Line":2}},{"line":269,"address":[19034451],"length":1,"stats":{"Line":2}},{"line":271,"address":[14446109,14446079],"length":1,"stats":{"Line":4}},{"line":272,"address":[13430851,13429760,13430716],"length":1,"stats":{"Line":6}},{"line":273,"address":[13430737],"length":1,"stats":{"Line":2}},{"line":275,"address":[14447246],"length":1,"stats":{"Line":2}},{"line":276,"address":[14447266],"length":1,"stats":{"Line":2}},{"line":280,"address":[19034617],"length":1,"stats":{"Line":2}},{"line":283,"address":[14446337],"length":1,"stats":{"Line":2}},{"line":284,"address":[14475310,14475406],"length":1,"stats":{"Line":2}},{"line":285,"address":[14446449],"length":1,"stats":{"Line":0}},{"line":287,"address":[14446490],"length":1,"stats":{"Line":2}},{"line":289,"address":[14475434],"length":1,"stats":{"Line":2}},{"line":292,"address":[19034939,19035063],"length":1,"stats":{"Line":2}},{"line":293,"address":[14446750,14446639,14446705],"length":1,"stats":{"Line":2}},{"line":294,"address":[14446721],"length":1,"stats":{"Line":0}},{"line":296,"address":[13430327],"length":1,"stats":{"Line":2}},{"line":298,"address":[14475706],"length":1,"stats":{"Line":2}},{"line":300,"address":[14446835],"length":1,"stats":{"Line":2}},{"line":301,"address":[14475801],"length":1,"stats":{"Line":0}},{"line":304,"address":[14446901],"length":1,"stats":{"Line":2}},{"line":308,"address":[19030192],"length":1,"stats":{"Line":2}},{"line":309,"address":[14441800],"length":1,"stats":{"Line":2}},{"line":310,"address":[14470800],"length":1,"stats":{"Line":2}},{"line":311,"address":[14441926],"length":1,"stats":{"Line":2}},{"line":313,"address":[13537129,13537120],"length":1,"stats":{"Line":6}},{"line":314,"address":[19897334,19897312],"length":1,"stats":{"Line":6}},{"line":315,"address":[19030268],"length":1,"stats":{"Line":0}},{"line":320,"address":[13431987,13431993,13430864],"length":1,"stats":{"Line":2}},{"line":326,"address":[14447494,14447417],"length":1,"stats":{"Line":4}},{"line":328,"address":[14447620,14447686],"length":1,"stats":{"Line":4}},{"line":330,"address":[19036095],"length":1,"stats":{"Line":2}},{"line":331,"address":[14476713],"length":1,"stats":{"Line":2}},{"line":334,"address":[14476720],"length":1,"stats":{"Line":2}},{"line":335,"address":[14476925,14476821],"length":1,"stats":{"Line":2}},{"line":338,"address":[14448015,14447947],"length":1,"stats":{"Line":2}},{"line":339,"address":[14476991,14477084],"length":1,"stats":{"Line":2}},{"line":341,"address":[14477172],"length":1,"stats":{"Line":2}},{"line":342,"address":[13431673],"length":1,"stats":{"Line":2}},{"line":343,"address":[14477080],"length":1,"stats":{"Line":2}},{"line":355,"address":[13431208],"length":1,"stats":{"Line":0}},{"line":359,"address":[14449608,14448448,14449602],"length":1,"stats":{"Line":2}},{"line":365,"address":[13432223,13432140],"length":1,"stats":{"Line":4}},{"line":366,"address":[14448771],"length":1,"stats":{"Line":2}},{"line":369,"address":[14448818,14448874],"length":1,"stats":{"Line":4}},{"line":371,"address":[14477845],"length":1,"stats":{"Line":2}},{"line":372,"address":[14477889],"length":1,"stats":{"Line":2}},{"line":375,"address":[19037352],"length":1,"stats":{"Line":2}},{"line":376,"address":[13432636,13432743],"length":1,"stats":{"Line":2}},{"line":379,"address":[14449194,14449126],"length":1,"stats":{"Line":2}},{"line":380,"address":[14449341,14449245],"length":1,"stats":{"Line":2}},{"line":382,"address":[13432995],"length":1,"stats":{"Line":2}},{"line":383,"address":[13432855],"length":1,"stats":{"Line":2}},{"line":384,"address":[14449337],"length":1,"stats":{"Line":2}},{"line":396,"address":[14448838],"length":1,"stats":{"Line":0}}],"covered":148,"coverable":171},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","parsers","ruby.rs"],"content":"//! Parser for Ruby Gemfile files\n//!\n//! Supports:\n//! - Gemfile format (Bundler)\n//! - gem declarations with version constraints\n//! - group blocks for development dependencies\n\nuse super::{Dependency, Parser};\n\n/// Parser for Ruby Gemfile dependency files\n#[derive(Debug, Default)]\npub struct RubyParser;\n\nimpl RubyParser {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Parser for RubyParser {\n    fn parse(&self, content: &str) -> Vec<Dependency> {\n        let mut dependencies = Vec::new();\n        let mut in_dev_group = false;\n        let mut group_depth = 0;\n\n        for (line_idx, line) in content.lines().enumerate() {\n            let line_num = line_idx as u32;\n            let trimmed = line.trim();\n\n            // Skip comments and empty lines\n            if trimmed.is_empty() || trimmed.starts_with('#') {\n                continue;\n            }\n\n            // Track group blocks for dev dependencies\n            if trimmed.starts_with(\"group\") {\n                let is_dev = trimmed.contains(\":development\")\n                    || trimmed.contains(\":test\")\n                    || trimmed.contains(\"'development'\")\n                    || trimmed.contains(\"\\\"development\\\"\")\n                    || trimmed.contains(\"'test'\")\n                    || trimmed.contains(\"\\\"test\\\"\");\n\n                if trimmed.contains(\"do\") {\n                    group_depth += 1;\n                    if is_dev {\n                        in_dev_group = true;\n                    }\n                }\n                continue;\n            }\n\n            // Track end of blocks\n            if trimmed == \"end\" {\n                if group_depth > 0 {\n                    group_depth -= 1;\n                    if group_depth == 0 {\n                        in_dev_group = false;\n                    }\n                }\n                continue;\n            }\n\n            // Parse gem declarations\n            if let Some(dep) = parse_gem_declaration(line, line_num, in_dev_group) {\n                dependencies.push(dep);\n            }\n        }\n\n        dependencies\n    }\n}\n\n/// Parse a gem declaration from a line\nfn parse_gem_declaration(line: &str, line_num: u32, dev: bool) -> Option<Dependency> {\n    let trimmed = line.trim();\n\n    // Must start with 'gem'\n    if !trimmed.starts_with(\"gem \") && !trimmed.starts_with(\"gem(\") {\n        return None;\n    }\n\n    // Extract the part after 'gem'\n    let after_gem = if trimmed.starts_with(\"gem(\") {\n        trimmed.strip_prefix(\"gem(\")?.trim_end_matches(')')\n    } else {\n        trimmed.strip_prefix(\"gem \")?\n    };\n\n    // Split by comma to get arguments\n    let args: Vec<&str> = split_gem_args(after_gem);\n\n    if args.is_empty() {\n        return None;\n    }\n\n    // First argument is the gem name (quoted)\n    let name = args[0].trim().trim_matches(|c| c == '\\'' || c == '\"');\n\n    // Second argument (if present) is the version constraint\n    let version = if args.len() > 1 {\n        let version_arg = args[1].trim();\n        // Skip if it's a hash option (like require: false, git: ...)\n        if version_arg.contains(':')\n            && !version_arg.starts_with('\\'')\n            && !version_arg.starts_with('\"')\n        {\n            return None; // No version, has options like git: or path:\n        }\n        version_arg\n            .trim_matches(|c| c == '\\'' || c == '\"')\n            .to_string()\n    } else {\n        return None; // No version specified\n    };\n\n    // Skip if version looks like a hash key (path, git, etc.)\n    if version.is_empty() || version.contains(':') {\n        return None;\n    }\n\n    // Calculate positions in the original line\n    let name_start = find_string_position(line, name)? as u32;\n    let name_end = name_start + name.len() as u32;\n    let version_start = find_string_position(line, &version)? as u32;\n    let version_end = version_start + version.len() as u32;\n\n    Some(Dependency {\n        name: name.to_string(),\n        version,\n        line: line_num,\n        name_start,\n        name_end,\n        version_start,\n        version_end,\n        dev,\n        optional: false,\n    })\n}\n\n/// Split gem arguments respecting quotes\nfn split_gem_args(s: &str) -> Vec<&str> {\n    let mut args = Vec::new();\n    let mut start = 0;\n    let mut in_quotes = false;\n    let mut quote_char = ' ';\n\n    for (i, c) in s.char_indices() {\n        match c {\n            '\\'' | '\"' if !in_quotes => {\n                in_quotes = true;\n                quote_char = c;\n            }\n            c if c == quote_char && in_quotes => {\n                in_quotes = false;\n            }\n            ',' if !in_quotes => {\n                let arg = s[start..i].trim();\n                if !arg.is_empty() {\n                    args.push(arg);\n                }\n                start = i + 1;\n            }\n            _ => {}\n        }\n    }\n\n    // Don't forget the last argument\n    let last_arg = s[start..].trim();\n    if !last_arg.is_empty() {\n        // Stop at hash options\n        if let Some(hash_start) = last_arg.find([':', '{']) {\n            let before_hash = last_arg[..hash_start].trim();\n            if !before_hash.is_empty()\n                && (before_hash.starts_with('\\'') || before_hash.starts_with('\"'))\n            {\n                args.push(before_hash);\n            }\n        } else {\n            args.push(last_arg);\n        }\n    }\n\n    args\n}\n\n/// Find the position of a string in a line (accounting for quotes)\nfn find_string_position(line: &str, needle: &str) -> Option<usize> {\n    // Look for the string within quotes\n    for quote in &['\\'', '\"'] {\n        let quoted = format!(\"{}{}{}\", quote, needle, quote);\n        if let Some(pos) = line.find(&quoted) {\n            return Some(pos + 1); // Skip the opening quote\n        }\n    }\n    // Fallback to direct search\n    line.find(needle)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_gem() {\n        let parser = RubyParser::new();\n        let content = r#\"\nsource 'https://rubygems.org'\n\ngem 'rails', '~> 7.0'\ngem 'pg', '~> 1.4'\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 2);\n        assert_eq!(deps[0].name, \"rails\");\n        assert_eq!(deps[0].version, \"~> 7.0\");\n        assert!(!deps[0].dev);\n        assert_eq!(deps[1].name, \"pg\");\n        assert_eq!(deps[1].version, \"~> 1.4\");\n    }\n\n    #[test]\n    fn test_gem_with_version_operators() {\n        let parser = RubyParser::new();\n        let content = r#\"\ngem 'devise', '>= 4.0'\ngem 'rspec', '~> 3.0'\ngem 'rails', '~> 7.0.0'\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 3);\n        assert_eq!(deps[0].name, \"devise\");\n        assert_eq!(deps[0].version, \">= 4.0\");\n        assert_eq!(deps[1].name, \"rspec\");\n        assert_eq!(deps[1].version, \"~> 3.0\");\n        assert_eq!(deps[2].name, \"rails\");\n        assert_eq!(deps[2].version, \"~> 7.0.0\");\n    }\n\n    #[test]\n    fn test_dev_dependencies_in_group() {\n        let parser = RubyParser::new();\n        let content = r#\"\nsource 'https://rubygems.org'\n\ngem 'rails', '~> 7.0'\n\ngroup :development, :test do\n  gem 'rspec-rails', '~> 6.0'\n  gem 'factory_bot_rails', '~> 6.2'\nend\n\ngem 'pg', '~> 1.4'\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 4);\n\n        let rails = deps.iter().find(|d| d.name == \"rails\").unwrap();\n        assert!(!rails.dev);\n\n        let rspec = deps.iter().find(|d| d.name == \"rspec-rails\").unwrap();\n        assert!(rspec.dev);\n\n        let factory_bot = deps.iter().find(|d| d.name == \"factory_bot_rails\").unwrap();\n        assert!(factory_bot.dev);\n\n        let pg = deps.iter().find(|d| d.name == \"pg\").unwrap();\n        assert!(!pg.dev);\n    }\n\n    #[test]\n    fn test_skip_git_and_path_gems() {\n        let parser = RubyParser::new();\n        let content = r#\"\ngem 'rails', '~> 7.0'\ngem 'my_gem', git: 'https://github.com/user/my_gem.git'\ngem 'local_gem', path: '../local_gem'\ngem 'pg', '~> 1.4'\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 2);\n        assert_eq!(deps[0].name, \"rails\");\n        assert_eq!(deps[1].name, \"pg\");\n    }\n\n    #[test]\n    fn test_skip_comments_and_empty_lines() {\n        let parser = RubyParser::new();\n        let content = r#\"\n# This is a comment\nsource 'https://rubygems.org'\n\n# Another comment\ngem 'rails', '~> 7.0'\n\n# gem 'old_gem', '1.0'\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"rails\");\n    }\n\n    #[test]\n    fn test_gem_with_require_option() {\n        let parser = RubyParser::new();\n        let content = r#\"\ngem 'rails', '~> 7.0'\ngem 'bootsnap', '~> 1.16', require: false\ngem 'pg', '~> 1.4'\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 3);\n        assert_eq!(deps[0].name, \"rails\");\n        assert_eq!(deps[1].name, \"bootsnap\");\n        assert_eq!(deps[1].version, \"~> 1.16\");\n        assert_eq!(deps[2].name, \"pg\");\n    }\n\n    #[test]\n    fn test_double_quoted_gems() {\n        let parser = RubyParser::new();\n        let content = r#\"\ngem \"rails\", \"~> 7.0\"\ngem \"pg\", \"~> 1.4\"\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 2);\n        assert_eq!(deps[0].name, \"rails\");\n        assert_eq!(deps[0].version, \"~> 7.0\");\n    }\n\n    #[test]\n    fn test_version_positions() {\n        let parser = RubyParser::new();\n        let content = \"gem 'rails', '~> 7.0'\\n\";\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 1);\n        let dep = &deps[0];\n\n        // Verify positions are valid\n        assert!(dep.name_start < dep.name_end);\n        assert!(dep.version_start < dep.version_end);\n        assert!(dep.name_end < dep.version_start);\n\n        // Verify name position\n        let name_slice = &content[dep.name_start as usize..dep.name_end as usize];\n        assert_eq!(name_slice, \"rails\");\n\n        // Verify version position\n        let version_slice = &content[dep.version_start as usize..dep.version_end as usize];\n        assert_eq!(version_slice, \"~> 7.0\");\n    }\n\n    #[test]\n    fn test_exact_version() {\n        let parser = RubyParser::new();\n        let content = \"gem 'nokogiri', '1.15.4'\\n\";\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 1);\n        assert_eq!(deps[0].name, \"nokogiri\");\n        assert_eq!(deps[0].version, \"1.15.4\");\n    }\n\n    #[test]\n    fn test_test_group() {\n        let parser = RubyParser::new();\n        let content = r#\"\ngem 'rails', '~> 7.0'\n\ngroup :test do\n  gem 'rspec', '~> 3.12'\nend\n\"#;\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 2);\n\n        let rspec = deps.iter().find(|d| d.name == \"rspec\").unwrap();\n        assert!(rspec.dev);\n    }\n}\n","traces":[{"line":21,"address":[14460992,14462344,14462350],"length":1,"stats":{"Line":3}},{"line":22,"address":[14461043],"length":1,"stats":{"Line":5}},{"line":23,"address":[14489995],"length":1,"stats":{"Line":5}},{"line":24,"address":[12657516],"length":1,"stats":{"Line":6}},{"line":26,"address":[14461136,14461088],"length":1,"stats":{"Line":12}},{"line":27,"address":[14490264],"length":1,"stats":{"Line":7}},{"line":28,"address":[14722062,14721991],"length":1,"stats":{"Line":12}},{"line":31,"address":[14490358],"length":1,"stats":{"Line":5}},{"line":36,"address":[12657961],"length":1,"stats":{"Line":7}},{"line":37,"address":[14490907,14490858,14490532],"length":1,"stats":{"Line":9}},{"line":38,"address":[12658432,12658372],"length":1,"stats":{"Line":4}},{"line":39,"address":[14722646],"length":1,"stats":{"Line":0}},{"line":40,"address":[14490983],"length":1,"stats":{"Line":0}},{"line":41,"address":[14722752],"length":1,"stats":{"Line":0}},{"line":42,"address":[12658601],"length":1,"stats":{"Line":0}},{"line":44,"address":[12658657],"length":1,"stats":{"Line":2}},{"line":45,"address":[12658749,12658713],"length":1,"stats":{"Line":2}},{"line":46,"address":[14462339,14462298],"length":1,"stats":{"Line":5}},{"line":47,"address":[14462334],"length":1,"stats":{"Line":2}},{"line":54,"address":[14461574,14461654],"length":1,"stats":{"Line":15}},{"line":55,"address":[14490623],"length":1,"stats":{"Line":3}},{"line":56,"address":[14461896,14461861],"length":1,"stats":{"Line":3}},{"line":57,"address":[14461884,14461921],"length":1,"stats":{"Line":6}},{"line":58,"address":[12658352],"length":1,"stats":{"Line":3}},{"line":65,"address":[12658151,12658114],"length":1,"stats":{"Line":12}},{"line":66,"address":[14722493],"length":1,"stats":{"Line":16}},{"line":70,"address":[14490298],"length":1,"stats":{"Line":11}},{"line":75,"address":[14489819,14487360,14489825],"length":1,"stats":{"Line":10}},{"line":76,"address":[12655006],"length":1,"stats":{"Line":10}},{"line":79,"address":[14458585],"length":1,"stats":{"Line":12}},{"line":80,"address":[14458699],"length":1,"stats":{"Line":4}},{"line":84,"address":[14487591],"length":1,"stats":{"Line":7}},{"line":85,"address":[14458839,14459063],"length":1,"stats":{"Line":0}},{"line":87,"address":[14458933,14458744],"length":1,"stats":{"Line":8}},{"line":91,"address":[14719263],"length":1,"stats":{"Line":10}},{"line":93,"address":[12655647,12655500],"length":1,"stats":{"Line":27}},{"line":94,"address":[14719511],"length":1,"stats":{"Line":0}},{"line":98,"address":[12655725,12655653],"length":1,"stats":{"Line":57}},{"line":101,"address":[12655848],"length":1,"stats":{"Line":16}},{"line":102,"address":[12655978,12655912],"length":1,"stats":{"Line":29}},{"line":104,"address":[14488536],"length":1,"stats":{"Line":13}},{"line":105,"address":[12656156],"length":1,"stats":{"Line":0}},{"line":106,"address":[12656208],"length":1,"stats":{"Line":0}},{"line":108,"address":[14720068],"length":1,"stats":{"Line":0}},{"line":111,"address":[14459660],"length":1,"stats":{"Line":45}},{"line":114,"address":[14488371],"length":1,"stats":{"Line":2}},{"line":118,"address":[14488860,14488939,14488795],"length":1,"stats":{"Line":42}},{"line":119,"address":[14459977],"length":1,"stats":{"Line":0}},{"line":123,"address":[12657331,12656523],"length":1,"stats":{"Line":16}},{"line":124,"address":[14489154,14489225],"length":1,"stats":{"Line":13}},{"line":125,"address":[14460343,14460865,14460280],"length":1,"stats":{"Line":29}},{"line":126,"address":[14460488,14460569],"length":1,"stats":{"Line":16}},{"line":128,"address":[12657120],"length":1,"stats":{"Line":13}},{"line":129,"address":[14489478],"length":1,"stats":{"Line":13}},{"line":130,"address":[12657072],"length":1,"stats":{"Line":16}},{"line":142,"address":[14485152,14486658,14486652],"length":1,"stats":{"Line":11}},{"line":143,"address":[14716551],"length":1,"stats":{"Line":10}},{"line":144,"address":[12652772],"length":1,"stats":{"Line":12}},{"line":145,"address":[14456324],"length":1,"stats":{"Line":10}},{"line":146,"address":[14716604],"length":1,"stats":{"Line":12}},{"line":148,"address":[12652811,12652862],"length":1,"stats":{"Line":22}},{"line":149,"address":[14716877,14717698],"length":1,"stats":{"Line":20}},{"line":150,"address":[12653837,12653881,12653849],"length":1,"stats":{"Line":22}},{"line":151,"address":[14457399],"length":1,"stats":{"Line":10}},{"line":152,"address":[12653867],"length":1,"stats":{"Line":12}},{"line":154,"address":[14717713,14717615],"length":1,"stats":{"Line":24}},{"line":155,"address":[14717723],"length":1,"stats":{"Line":10}},{"line":157,"address":[12653924],"length":1,"stats":{"Line":12}},{"line":158,"address":[14486430],"length":1,"stats":{"Line":10}},{"line":159,"address":[14486535],"length":1,"stats":{"Line":12}},{"line":160,"address":[12654098,12654144],"length":1,"stats":{"Line":22}},{"line":162,"address":[14457704,14457665,14457691],"length":1,"stats":{"Line":22}},{"line":169,"address":[14716939],"length":1,"stats":{"Line":10}},{"line":170,"address":[12653262],"length":1,"stats":{"Line":12}},{"line":172,"address":[14485921,14485773],"length":1,"stats":{"Line":23}},{"line":173,"address":[14457137,14457055],"length":1,"stats":{"Line":8}},{"line":174,"address":[12653656],"length":1,"stats":{"Line":2}},{"line":175,"address":[14457324,14457231],"length":1,"stats":{"Line":4}},{"line":177,"address":[14717573,14717605],"length":1,"stats":{"Line":0}},{"line":180,"address":[14457102,14457338],"length":1,"stats":{"Line":25}},{"line":184,"address":[14485862],"length":1,"stats":{"Line":11}},{"line":188,"address":[14457744,14458405,14458411],"length":1,"stats":{"Line":13}},{"line":190,"address":[12654251,12654273],"length":1,"stats":{"Line":29}},{"line":191,"address":[12654342],"length":1,"stats":{"Line":16}},{"line":192,"address":[14487064,14487193],"length":1,"stats":{"Line":29}},{"line":193,"address":[14458311,14458352,14458385],"length":1,"stats":{"Line":29}},{"line":197,"address":[14458167],"length":1,"stats":{"Line":0}}],"covered":75,"coverable":87},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","providers","code_actions.rs"],"content":"//! Code actions provider for updating dependencies\n\nuse std::collections::HashMap;\n\nuse tower_lsp::lsp_types::*;\n\nuse crate::cache::ReadCache;\nuse crate::file_types::FileType;\nuse crate::parsers::Dependency;\nuse crate::providers::inlay_hints::{VersionStatus, compare_versions};\n\n/// Type of semantic version update\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum VersionUpdateType {\n    Major,\n    Minor,\n    Patch,\n    PreRelease,\n}\n\nimpl VersionUpdateType {\n    pub fn prefix(&self) -> &'static str {\n        match self {\n            VersionUpdateType::Major => \"⚠ MAJOR\",\n            VersionUpdateType::Minor => \"+ minor\",\n            VersionUpdateType::Patch => \"· patch\",\n            VersionUpdateType::PreRelease => \"* prerelease\",\n        }\n    }\n\n    pub fn is_preferred(&self) -> bool {\n        !matches!(self, VersionUpdateType::Major)\n    }\n}\n\n/// Determine the type of version update between current and new version\npub fn compare_update_type(current: &str, new: &str) -> VersionUpdateType {\n    let current_normalized = normalize_version(current);\n    let new_normalized = normalize_version(new);\n\n    match (\n        semver::Version::parse(&current_normalized),\n        semver::Version::parse(&new_normalized),\n    ) {\n        (Ok(current_ver), Ok(new_ver)) => {\n            if !new_ver.pre.is_empty() && current_ver.pre.is_empty() {\n                VersionUpdateType::PreRelease\n            } else if current_ver.major != new_ver.major {\n                VersionUpdateType::Major\n            } else if current_ver.minor != new_ver.minor {\n                VersionUpdateType::Minor\n            } else if current_ver.patch != new_ver.patch {\n                VersionUpdateType::Patch\n            } else {\n                VersionUpdateType::PreRelease\n            }\n        }\n        _ => VersionUpdateType::Patch,\n    }\n}\n\nfn normalize_version(version: &str) -> String {\n    let version = version.trim();\n    let version = version\n        .strip_prefix(\"~>\")\n        .or_else(|| version.strip_prefix('^'))\n        .or_else(|| version.strip_prefix('~'))\n        .or_else(|| version.strip_prefix(\">=\"))\n        .or_else(|| version.strip_prefix(\"<=\"))\n        .or_else(|| version.strip_prefix('>'))\n        .or_else(|| version.strip_prefix('<'))\n        .or_else(|| version.strip_prefix('='))\n        .or_else(|| version.strip_prefix('v'))\n        .unwrap_or(version)\n        .trim();\n\n    let version = version.split(',').next().unwrap_or(version).trim();\n\n    let parts: Vec<&str> = version.split('.').collect();\n    match parts.len() {\n        1 => format!(\"{}.0.0\", parts[0]),\n        2 => format!(\"{}.{}.0\", parts[0], parts[1]),\n        _ => version.to_string(),\n    }\n}\n\n/// Create code actions for dependencies in the given range\npub fn create_code_actions(\n    dependencies: &[Dependency],\n    cache: &impl ReadCache,\n    uri: &Url,\n    range: Range,\n    file_type: FileType,\n    cache_key_fn: impl Fn(&str) -> String,\n) -> Vec<CodeActionOrCommand> {\n    let mut actions: Vec<CodeActionOrCommand> = dependencies\n        .iter()\n        .filter(|dep| dep.line >= range.start.line && dep.line <= range.end.line)\n        .filter_map(|dep| create_update_action(dep, cache, uri, file_type, &cache_key_fn))\n        .collect();\n\n    if let Some(update_all) =\n        create_update_all_action(dependencies, cache, uri, file_type, &cache_key_fn)\n    {\n        actions.insert(0, update_all);\n    }\n\n    actions\n}\n\n/// Create an \"Update to X.Y.Z\" code action for a dependency\nfn create_update_action(\n    dep: &Dependency,\n    cache: &impl ReadCache,\n    uri: &Url,\n    file_type: FileType,\n    cache_key_fn: impl Fn(&str) -> String,\n) -> Option<CodeActionOrCommand> {\n    let cache_key = cache_key_fn(&dep.name);\n    let version_info = cache.get(&cache_key)?;\n\n    match compare_versions(&dep.version, &version_info) {\n        VersionStatus::UpdateAvailable(new_version) => {\n            let update_type = compare_update_type(&dep.version, &new_version);\n            let new_text = format_version(&new_version, file_type);\n\n            let edit = TextEdit {\n                range: Range {\n                    start: Position {\n                        line: dep.line,\n                        character: dep.version_start,\n                    },\n                    end: Position {\n                        line: dep.line,\n                        character: dep.version_end,\n                    },\n                },\n                new_text,\n            };\n\n            let mut changes = HashMap::new();\n            changes.insert(uri.clone(), vec![edit]);\n\n            let title = format!(\n                \"{}: Update {} to {}\",\n                update_type.prefix(),\n                dep.name,\n                new_version\n            );\n\n            Some(CodeActionOrCommand::CodeAction(CodeAction {\n                title,\n                kind: Some(CodeActionKind::QUICKFIX),\n                diagnostics: None,\n                edit: Some(WorkspaceEdit {\n                    changes: Some(changes),\n                    document_changes: None,\n                    change_annotations: None,\n                }),\n                command: None,\n                is_preferred: Some(update_type.is_preferred()),\n                disabled: None,\n                data: None,\n            }))\n        }\n        VersionStatus::UpToDate | VersionStatus::Unknown => None,\n    }\n}\n\n/// Create an \"Update All Dependencies\" code action when 2+ updates are available\nfn create_update_all_action(\n    dependencies: &[Dependency],\n    cache: &impl ReadCache,\n    uri: &Url,\n    file_type: FileType,\n    cache_key_fn: impl Fn(&str) -> String,\n) -> Option<CodeActionOrCommand> {\n    let outdated_deps: Vec<(&Dependency, String)> = dependencies\n        .iter()\n        .filter_map(|dep| {\n            let cache_key = cache_key_fn(&dep.name);\n            let version_info = cache.get(&cache_key)?;\n\n            match compare_versions(&dep.version, &version_info) {\n                VersionStatus::UpdateAvailable(new_version) => Some((dep, new_version)),\n                _ => None,\n            }\n        })\n        .collect();\n\n    if outdated_deps.len() < 2 {\n        return None;\n    }\n\n    let edits: Vec<TextEdit> = outdated_deps\n        .iter()\n        .map(|(dep, new_version)| {\n            let new_text = format_version(new_version, file_type);\n            TextEdit {\n                range: Range {\n                    start: Position {\n                        line: dep.line,\n                        character: dep.version_start,\n                    },\n                    end: Position {\n                        line: dep.line,\n                        character: dep.version_end,\n                    },\n                },\n                new_text,\n            }\n        })\n        .collect();\n\n    let mut changes = HashMap::new();\n    changes.insert(uri.clone(), edits);\n\n    let count = outdated_deps.len();\n    let title = format!(\"Update all {} dependencies\", count);\n\n    Some(CodeActionOrCommand::CodeAction(CodeAction {\n        title,\n        kind: Some(CodeActionKind::QUICKFIX),\n        diagnostics: None,\n        edit: Some(WorkspaceEdit {\n            changes: Some(changes),\n            document_changes: None,\n            change_annotations: None,\n        }),\n        command: None,\n        is_preferred: Some(false),\n        disabled: None,\n        data: None,\n    }))\n}\n\n/// Format version string based on file type\nfn format_version(version: &str, file_type: FileType) -> String {\n    match file_type {\n        FileType::Cargo | FileType::Npm | FileType::Php => {\n            // Keep the version as-is - the range already includes the quotes in these formats\n            version.to_string()\n        }\n        FileType::Python => {\n            // Python uses operators like == or >=\n            // Just replace the version number\n            version.to_string()\n        }\n        FileType::Go => {\n            // Go versions start with 'v'\n            if version.starts_with('v') {\n                version.to_string()\n            } else {\n                format!(\"v{}\", version)\n            }\n        }\n        FileType::Dart => {\n            // Dart pubspec.yaml uses caret syntax (^1.0.0) or simple versions\n            version.to_string()\n        }\n        FileType::Csharp => {\n            // C# .csproj uses simple version strings\n            version.to_string()\n        }\n        FileType::Ruby => {\n            // Ruby Gemfile uses operators like ~> or >=\n            version.to_string()\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cache::{MemoryCache, WriteCache};\n    use crate::registries::VersionInfo;\n\n    fn create_test_dependency(name: &str, version: &str, line: u32) -> Dependency {\n        Dependency {\n            name: name.to_string(),\n            version: version.to_string(),\n            line,\n            name_start: 0,\n            name_end: name.len() as u32,\n            version_start: name.len() as u32 + 4,\n            version_end: name.len() as u32 + 4 + version.len() as u32,\n            dev: false,\n            optional: false,\n        }\n    }\n\n    #[test]\n    fn test_create_update_action() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 1);\n        match &actions[0] {\n            CodeActionOrCommand::CodeAction(action) => {\n                assert!(action.title.contains(\"Update serde to 2.0.0\"));\n                assert_eq!(action.kind, Some(CodeActionKind::QUICKFIX));\n            }\n            _ => panic!(\"Expected CodeAction\"),\n        }\n    }\n\n    #[test]\n    fn test_no_action_when_up_to_date() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 0);\n    }\n\n    #[test]\n    fn test_format_version() {\n        assert_eq!(format_version(\"1.0.0\", FileType::Cargo), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Npm), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Python), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Go), \"v1.0.0\");\n        assert_eq!(format_version(\"v1.0.0\", FileType::Go), \"v1.0.0\");\n    }\n\n    #[test]\n    fn test_update_all_action_with_multiple_outdated() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n        cache.insert(\n            \"test:tokio\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.36.0\".to_string()),\n                ..Default::default()\n            },\n        );\n        cache.insert(\n            \"test:reqwest\".to_string(),\n            VersionInfo {\n                latest: Some(\"0.12.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![\n            create_test_dependency(\"serde\", \"1.0.0\", 5),\n            create_test_dependency(\"tokio\", \"1.35.0\", 6),\n            create_test_dependency(\"reqwest\", \"0.11.0\", 7),\n        ];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 4);\n        match &actions[0] {\n            CodeActionOrCommand::CodeAction(action) => {\n                assert!(action.title.contains(\"Update all 3 dependencies\"));\n                assert_eq!(action.kind, Some(CodeActionKind::QUICKFIX));\n                assert_eq!(action.is_preferred, Some(false));\n\n                if let Some(edit) = &action.edit {\n                    if let Some(changes) = &edit.changes {\n                        let edits = changes.get(&uri).unwrap();\n                        assert_eq!(edits.len(), 3);\n                    } else {\n                        panic!(\"Expected changes in workspace edit\");\n                    }\n                } else {\n                    panic!(\"Expected edit in code action\");\n                }\n            }\n            _ => panic!(\"Expected CodeAction\"),\n        }\n    }\n\n    #[test]\n    fn test_update_all_action_not_shown_for_single_outdated() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n        cache.insert(\n            \"test:tokio\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.35.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![\n            create_test_dependency(\"serde\", \"1.0.0\", 5),\n            create_test_dependency(\"tokio\", \"1.35.0\", 6),\n        ];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 1);\n        match &actions[0] {\n            CodeActionOrCommand::CodeAction(action) => {\n                assert!(!action.title.contains(\"Update all\"));\n                assert!(action.title.contains(\"Update serde to 2.0.0\"));\n            }\n            _ => panic!(\"Expected CodeAction\"),\n        }\n    }\n\n    #[test]\n    fn test_update_all_action_not_shown_when_all_up_to_date() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n        cache.insert(\n            \"test:tokio\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.35.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![\n            create_test_dependency(\"serde\", \"1.0.0\", 5),\n            create_test_dependency(\"tokio\", \"1.35.0\", 6),\n        ];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 0);\n    }\n\n    #[test]\n    fn test_version_update_type_major() {\n        let update_type = compare_update_type(\"1.0.0\", \"2.0.0\");\n        assert_eq!(update_type, VersionUpdateType::Major);\n        assert_eq!(update_type.prefix(), \"⚠ MAJOR\");\n        assert!(!update_type.is_preferred());\n    }\n\n    #[test]\n    fn test_version_update_type_minor() {\n        let update_type = compare_update_type(\"1.5.0\", \"1.6.0\");\n        assert_eq!(update_type, VersionUpdateType::Minor);\n        assert_eq!(update_type.prefix(), \"+ minor\");\n        assert!(update_type.is_preferred());\n    }\n\n    #[test]\n    fn test_version_update_type_patch() {\n        let update_type = compare_update_type(\"1.5.0\", \"1.5.1\");\n        assert_eq!(update_type, VersionUpdateType::Patch);\n        assert_eq!(update_type.prefix(), \"· patch\");\n        assert!(update_type.is_preferred());\n    }\n\n    #[test]\n    fn test_version_update_type_prerelease() {\n        let update_type = compare_update_type(\"1.5.0\", \"1.5.1-alpha.1\");\n        assert_eq!(update_type, VersionUpdateType::PreRelease);\n        assert_eq!(update_type.prefix(), \"* prerelease\");\n        assert!(update_type.is_preferred());\n    }\n\n    #[test]\n    fn test_version_update_type_with_prefixes() {\n        assert_eq!(\n            compare_update_type(\"^1.0.0\", \"2.0.0\"),\n            VersionUpdateType::Major\n        );\n        assert_eq!(\n            compare_update_type(\"~1.5.0\", \"1.6.0\"),\n            VersionUpdateType::Minor\n        );\n        assert_eq!(\n            compare_update_type(\">=1.5.0\", \"1.5.1\"),\n            VersionUpdateType::Patch\n        );\n        // Ruby pessimistic constraint\n        assert_eq!(\n            compare_update_type(\"~> 7.0\", \"8.1.1\"),\n            VersionUpdateType::Major\n        );\n        assert_eq!(\n            compare_update_type(\"~> 4.9\", \"4.9.4\"),\n            VersionUpdateType::Patch\n        );\n    }\n\n    #[test]\n    fn test_version_update_type_invalid_semver() {\n        let update_type = compare_update_type(\"invalid\", \"also-invalid\");\n        assert_eq!(update_type, VersionUpdateType::Patch);\n    }\n\n    #[test]\n    fn test_code_action_title_with_major_update() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 1);\n        match &actions[0] {\n            CodeActionOrCommand::CodeAction(action) => {\n                assert!(action.title.contains(\"⚠ MAJOR\"));\n                assert!(action.title.contains(\"Update serde to 2.0.0\"));\n                assert_eq!(action.is_preferred, Some(false));\n            }\n            _ => panic!(\"Expected CodeAction\"),\n        }\n    }\n\n    #[test]\n    fn test_code_action_title_with_minor_update() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:tokio\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.36.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"tokio\", \"1.35.0\", 5)];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 1);\n        match &actions[0] {\n            CodeActionOrCommand::CodeAction(action) => {\n                assert!(action.title.contains(\"+ minor\"));\n                assert!(action.title.contains(\"Update tokio to 1.36.0\"));\n                assert_eq!(action.is_preferred, Some(true));\n            }\n            _ => panic!(\"Expected CodeAction\"),\n        }\n    }\n\n    #[test]\n    fn test_code_action_title_with_patch_update() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:reqwest\".to_string(),\n            VersionInfo {\n                latest: Some(\"0.12.1\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"reqwest\", \"0.12.0\", 5)];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 1);\n        match &actions[0] {\n            CodeActionOrCommand::CodeAction(action) => {\n                assert!(action.title.contains(\"· patch\"));\n                assert!(action.title.contains(\"Update reqwest to 0.12.1\"));\n                assert_eq!(action.is_preferred, Some(true));\n            }\n            _ => panic!(\"Expected CodeAction\"),\n        }\n    }\n\n    #[test]\n    fn test_format_version_all_file_types() {\n        assert_eq!(format_version(\"1.0.0\", FileType::Cargo), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Npm), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Python), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Go), \"v1.0.0\");\n        assert_eq!(format_version(\"v1.0.0\", FileType::Go), \"v1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Php), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Dart), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Csharp), \"1.0.0\");\n        assert_eq!(format_version(\"1.0.0\", FileType::Ruby), \"1.0.0\");\n    }\n\n    #[test]\n    fn test_normalize_version_with_partial_versions() {\n        let normalized = super::normalize_version(\"1\");\n        assert_eq!(normalized, \"1.0.0\");\n\n        let normalized = super::normalize_version(\"1.2\");\n        assert_eq!(normalized, \"1.2.0\");\n\n        let normalized = super::normalize_version(\"1.2.3\");\n        assert_eq!(normalized, \"1.2.3\");\n    }\n\n    #[test]\n    fn test_normalize_version_with_range_operators() {\n        let normalized = super::normalize_version(\">=1.0.0, <2.0.0\");\n        assert_eq!(normalized, \"1.0.0\");\n\n        let normalized = super::normalize_version(\"<=1.5.0\");\n        assert_eq!(normalized, \"1.5.0\");\n\n        let normalized = super::normalize_version(\">1.0.0\");\n        assert_eq!(normalized, \"1.0.0\");\n\n        let normalized = super::normalize_version(\"<2.0.0\");\n        assert_eq!(normalized, \"2.0.0\");\n\n        let normalized = super::normalize_version(\"=1.0.0\");\n        assert_eq!(normalized, \"1.0.0\");\n    }\n\n    #[test]\n    fn test_filter_deps_outside_range() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 50)];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 0);\n    }\n\n    #[test]\n    fn test_no_action_when_cache_empty() {\n        let cache = MemoryCache::new();\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let uri = Url::parse(\"file:///test/Cargo.toml\").unwrap();\n        let range = Range {\n            start: Position {\n                line: 0,\n                character: 0,\n            },\n            end: Position {\n                line: 10,\n                character: 0,\n            },\n        };\n\n        let actions = create_code_actions(&deps, &cache, &uri, range, FileType::Cargo, |name| {\n            format!(\"test:{}\", name)\n        });\n\n        assert_eq!(actions.len(), 0);\n    }\n}\n","traces":[{"line":22,"address":[13021376],"length":1,"stats":{"Line":2}},{"line":23,"address":[13021381],"length":1,"stats":{"Line":3}},{"line":24,"address":[13050340],"length":1,"stats":{"Line":2}},{"line":25,"address":[13050363],"length":1,"stats":{"Line":2}},{"line":26,"address":[13050386],"length":1,"stats":{"Line":2}},{"line":27,"address":[14554649],"length":1,"stats":{"Line":2}},{"line":31,"address":[13050272],"length":1,"stats":{"Line":3}},{"line":32,"address":[13050277],"length":1,"stats":{"Line":4}},{"line":37,"address":[13051632,13052519,13052763],"length":1,"stats":{"Line":2}},{"line":38,"address":[15112522],"length":1,"stats":{"Line":2}},{"line":39,"address":[13051731],"length":1,"stats":{"Line":2}},{"line":41,"address":[13052064,13051960],"length":1,"stats":{"Line":6}},{"line":42,"address":[13051849,13051784],"length":1,"stats":{"Line":5}},{"line":43,"address":[13051941,13051873],"length":1,"stats":{"Line":7}},{"line":45,"address":[13052095],"length":1,"stats":{"Line":2}},{"line":46,"address":[13052328,13052204,13052275],"length":1,"stats":{"Line":8}},{"line":47,"address":[13023406],"length":1,"stats":{"Line":2}},{"line":48,"address":[13023376,13023455],"length":1,"stats":{"Line":5}},{"line":49,"address":[14556582],"length":1,"stats":{"Line":2}},{"line":50,"address":[14556614,14556562],"length":1,"stats":{"Line":5}},{"line":51,"address":[14556609],"length":1,"stats":{"Line":2}},{"line":52,"address":[13023457,13023496,13023489],"length":1,"stats":{"Line":5}},{"line":53,"address":[14556623],"length":1,"stats":{"Line":2}},{"line":55,"address":[14556616],"length":1,"stats":{"Line":0}},{"line":58,"address":[14556258],"length":1,"stats":{"Line":2}},{"line":62,"address":[15112440,15112446,15111312],"length":1,"stats":{"Line":2}},{"line":63,"address":[13021579],"length":1,"stats":{"Line":2}},{"line":66,"address":[15111445],"length":1,"stats":{"Line":10}},{"line":67,"address":[14539134,14539120],"length":1,"stats":{"Line":12}},{"line":68,"address":[13014014,13014000],"length":1,"stats":{"Line":12}},{"line":69,"address":[13021728],"length":1,"stats":{"Line":8}},{"line":70,"address":[15111529],"length":1,"stats":{"Line":6}},{"line":71,"address":[14456414,14456400],"length":1,"stats":{"Line":6}},{"line":72,"address":[13050731],"length":1,"stats":{"Line":6}},{"line":73,"address":[13013712,13013726],"length":1,"stats":{"Line":6}},{"line":74,"address":[13021853],"length":1,"stats":{"Line":2}},{"line":77,"address":[13050835],"length":1,"stats":{"Line":2}},{"line":79,"address":[15111811],"length":1,"stats":{"Line":2}},{"line":80,"address":[15111925,15111854],"length":1,"stats":{"Line":4}},{"line":81,"address":[15111981,15112059],"length":1,"stats":{"Line":4}},{"line":82,"address":[15112016,15112212],"length":1,"stats":{"Line":4}},{"line":83,"address":[14555811,14555343],"length":1,"stats":{"Line":4}},{"line":88,"address":[13014174,13014048,13014603],"length":1,"stats":{"Line":20}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[13014224,13014624,13014644],"length":1,"stats":{"Line":60}},{"line":99,"address":[14463088,14463043,14463283,14462276,14463808,14462723,14461748,14458036,14463008,14462688,14462803,14463248,14463443,14464128,14460156,14463843,14464323,14463408,14463123,14457508,14464163,14464288,14459620,14462768,14460692,14463488,14456980,14459092,14458564,14463523,14464208,14464243,14461220],"length":1,"stats":{"Line":56}},{"line":102,"address":[14540348,14540878,14541934,14543518,14539806,14544574,14545102,14542990,14541406,14542462,14544046],"length":1,"stats":{"Line":30}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[13014532,13014601],"length":1,"stats":{"Line":4}},{"line":108,"address":[13043495],"length":1,"stats":{"Line":20}},{"line":112,"address":[14565770,14562288,14553200,14559408,14571978,14578032,14562512,14547146,14575082,14571600,14571824,14550250,14568874,14565616,14578186,14568720,14556304,14556458,14574928,14580912,14556080,14559562,14553354,14565392,14568496,14577808,14552976,14546992,14559184,14574704,14549872,14562666,14550096],"length":1,"stats":{"Line":18}},{"line":119,"address":[13043917,13043819],"length":1,"stats":{"Line":36}},{"line":120,"address":[13044040,13043952],"length":1,"stats":{"Line":36}},{"line":122,"address":[14575441,14575540,14578644,14572337,14566129,14556916,14547604,14569233,14550609,14556817,14560020,14553713,14572436,14566228,14569332,14578545,14563025,14547505,14553812,14559921,14563124,14550708],"length":1,"stats":{"Line":32}},{"line":123,"address":[14563230,14560126,14550814,14553918,14572542,14569438,14566334,14578750,14557022,14575646,14547710],"length":1,"stats":{"Line":12}},{"line":124,"address":[13015657,13015558],"length":1,"stats":{"Line":24}},{"line":125,"address":[13015728],"length":1,"stats":{"Line":12}},{"line":128,"address":[13015801],"length":1,"stats":{"Line":12}},{"line":141,"address":[13015885],"length":1,"stats":{"Line":12}},{"line":142,"address":[13015953,13017805,13016014,13016044],"length":1,"stats":{"Line":24}},{"line":144,"address":[13016402],"length":1,"stats":{"Line":12}},{"line":146,"address":[14472087,14468983,14475191,14487607,14484503,14465879,14496919,14490711,14493815,14478295,14481399],"length":1,"stats":{"Line":12}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[13017218],"length":1,"stats":{"Line":12}},{"line":152,"address":[13016647],"length":1,"stats":{"Line":12}},{"line":153,"address":[13016679],"length":1,"stats":{"Line":12}},{"line":154,"address":[14475567,14497295,14484879,14481775,14494191,14491087,14472463,14469359,14478671,14487983,14466255],"length":1,"stats":{"Line":12}},{"line":155,"address":[14481911,14491223,14475703,14485015,14488119,14494327,14497431,14472599,14469495,14466391,14478807],"length":1,"stats":{"Line":12}},{"line":156,"address":[13016727],"length":1,"stats":{"Line":12}},{"line":157,"address":[13045759],"length":1,"stats":{"Line":12}},{"line":158,"address":[14469483,14485003,14491211,14497419,14478795,14481899,14475691,14488107,14494315,14466379,14472587],"length":1,"stats":{"Line":12}},{"line":160,"address":[14558583,14574103,14549271,14580311,14567895,14552375,14577207,14555479,14564791,14570999,14561687],"length":1,"stats":{"Line":12}},{"line":161,"address":[14472930,14469767,14466722,14479079,14485287,14485346,14472871,14482242,14497762,14488450,14469826,14466663,14491495,14475975,14479138,14482183,14491554,14494599,14488391,14476034,14494658,14497703],"length":1,"stats":{"Line":24}},{"line":162,"address":[13017202],"length":1,"stats":{"Line":12}},{"line":163,"address":[14555574,14558678,14567990,14574198,14549366,14552470,14577302,14561782,14564886,14580406,14571094],"length":1,"stats":{"Line":12}},{"line":166,"address":[13044434],"length":1,"stats":{"Line":6}},{"line":171,"address":[14498646,14503893,14507552,14502128,14507686,14502262,14512933,14507509,14509360,14518357,14511125,14513110,14505878,14503936,14498512,14514918,14514741,14516726,14511302,14516592,14516549,14502085,14505701,14512976,14500277,14500454,14500320,14509317,14511168,14514784,14504070,14505744,14509494],"length":1,"stats":{"Line":20}},{"line":178,"address":[14504039,14513079,14514887,14500423,14507655,14509463,14516695,14505847,14511271,14502231,14498615],"length":1,"stats":{"Line":20}},{"line":180,"address":[14603302,14601766,14599422,14604051,14605971,14609811,14609830,14588574,14604070,14610579,14607744,14602560,14603283,14595806,14610816,14583150,14606976,14601747,14606739,14609088,14610598,14608486,14603328,14597614,14609856,14605203,14608467,14607699,14584958,14581342,14605990,14601024,14586766,14593998,14611558,14611539,14605248,14590382,14605222,14604480,14607718,14606016,14606758,14592190],"length":1,"stats":{"Line":40}},{"line":181,"address":[13020035],"length":1,"stats":{"Line":20}},{"line":182,"address":[13020095,13020177],"length":1,"stats":{"Line":40}},{"line":184,"address":[14606455,14605600,14601376,14601463,14603680,14607328,14610295,14602999,14606368,14603767,14607415,14604919,14610208,14611255,14609527,14611168,14608096,14609440,14602912,14605687,14604832,14608183],"length":1,"stats":{"Line":36}},{"line":185,"address":[14606528,14607488,14611328,14601536,14605760,14608256,14610368,14603072,14604992,14609600,14603840],"length":1,"stats":{"Line":14}},{"line":186,"address":[14519070,14521758,14528670,14522718,14523678,14525214,14520030,14524446,14520798,14526558,14527326],"length":1,"stats":{"Line":6}},{"line":191,"address":[13047185,13047112],"length":1,"stats":{"Line":40}},{"line":192,"address":[14511505,14515121,14498849,14502465,14507889,14500657,14504273,14516929,14513313,14509697,14506081],"length":1,"stats":{"Line":18}},{"line":195,"address":[13047191],"length":1,"stats":{"Line":2}},{"line":197,"address":[13018367,13019792,13019833],"length":1,"stats":{"Line":6}},{"line":198,"address":[13048775],"length":1,"stats":{"Line":2}},{"line":199,"address":[13019933],"length":1,"stats":{"Line":2}},{"line":200,"address":[13048844],"length":1,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[14528866,14525602,14525410,14519266,14520994,14525794,14527522,14527714,14521954,14522914,14527906],"length":1,"stats":{"Line":2}},{"line":203,"address":[13048826],"length":1,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[13048832],"length":1,"stats":{"Line":2}},{"line":207,"address":[14602485,14604213,14601909,14604405,14602293,14609013,14610741,14606901,14608821,14602101,14608629],"length":1,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[14599677,14592445,14597869,14583405,14590637,14588829,14581597,14594253,14587021,14596061,14585213],"length":1,"stats":{"Line":2}},{"line":216,"address":[13047478,13047430],"length":1,"stats":{"Line":4}},{"line":218,"address":[14502804,14504612,14515460,14508228,14517268,14513652,14500996,14506420,14510036,14511844,14499188],"length":1,"stats":{"Line":2}},{"line":219,"address":[13018697],"length":1,"stats":{"Line":2}},{"line":221,"address":[14587844,14595076,14589652,14596884,14593268,14598692,14586036,14582420,14600500,14591460,14584228],"length":1,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[14583780,14589204,14585588,14596436,14581972,14598244,14591012,14594628,14592820,14587396,14600052],"length":1,"stats":{"Line":2}},{"line":224,"address":[13018864],"length":1,"stats":{"Line":2}},{"line":225,"address":[13047920],"length":1,"stats":{"Line":2}},{"line":226,"address":[13018872],"length":1,"stats":{"Line":2}},{"line":227,"address":[13018968],"length":1,"stats":{"Line":2}},{"line":228,"address":[14591168,14582128,14589360,14592976,14587552,14585744,14583936,14600208,14596592,14598400,14594784],"length":1,"stats":{"Line":2}},{"line":230,"address":[14499772,14510620,14501580,14514236,14503388,14512428,14516044,14507004,14508812,14505196,14517852],"length":1,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[13019256],"length":1,"stats":{"Line":2}},{"line":233,"address":[13048192],"length":1,"stats":{"Line":2}},{"line":238,"address":[14554128],"length":1,"stats":{"Line":3}},{"line":239,"address":[14554164],"length":1,"stats":{"Line":3}},{"line":242,"address":[14554200],"length":1,"stats":{"Line":3}},{"line":247,"address":[13049983],"length":1,"stats":{"Line":4}},{"line":251,"address":[13021073],"length":1,"stats":{"Line":4}},{"line":252,"address":[13021309],"length":1,"stats":{"Line":4}},{"line":254,"address":[13021184],"length":1,"stats":{"Line":4}},{"line":259,"address":[13050037],"length":1,"stats":{"Line":2}},{"line":263,"address":[13021132],"length":1,"stats":{"Line":2}},{"line":267,"address":[13021155],"length":1,"stats":{"Line":2}}],"covered":115,"coverable":125},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","providers","completion.rs"],"content":"//! Completion provider for version suggestions\n\nuse chrono::{DateTime, Utc};\nuse tower_lsp::lsp_types::*;\n\nuse crate::cache::ReadCache;\nuse crate::parsers::Dependency;\n\n/// Format a release date as a human-readable age string\npub fn format_release_age(released_at: DateTime<Utc>) -> String {\n    let now = Utc::now();\n    let duration = now.signed_duration_since(released_at);\n\n    let days = duration.num_days();\n    if days < 0 {\n        return \"just now\".to_string();\n    }\n\n    if days == 0 {\n        let hours = duration.num_hours();\n        if hours == 0 {\n            let mins = duration.num_minutes();\n            if mins < 1 {\n                return \"just now\".to_string();\n            }\n            return format!(\"{} min{} ago\", mins, if mins == 1 { \"\" } else { \"s\" });\n        }\n        return format!(\"{} hour{} ago\", hours, if hours == 1 { \"\" } else { \"s\" });\n    }\n\n    if days == 1 {\n        return \"yesterday\".to_string();\n    }\n\n    if days < 7 {\n        return format!(\"{} days ago\", days);\n    }\n\n    if days < 30 {\n        let weeks = days / 7;\n        return format!(\"{} week{} ago\", weeks, if weeks == 1 { \"\" } else { \"s\" });\n    }\n\n    if days < 365 {\n        let months = days / 30;\n        return format!(\"{} month{} ago\", months, if months == 1 { \"\" } else { \"s\" });\n    }\n\n    let years = days / 365;\n    format!(\"{} year{} ago\", years, if years == 1 { \"\" } else { \"s\" })\n}\n\n/// Get completions for a position in the document\npub fn get_completions(\n    dependencies: &[Dependency],\n    position: Position,\n    cache: &impl ReadCache,\n    cache_key_fn: impl Fn(&str) -> String,\n) -> Option<Vec<CompletionItem>> {\n    // Find if we're inside a version field\n    let dep = dependencies.iter().find(|d| {\n        d.line == position.line\n            && position.character >= d.version_start\n            && position.character <= d.version_end\n    })?;\n\n    let cache_key = cache_key_fn(&dep.name);\n    let version_info = cache.get(&cache_key)?;\n\n    // Return the last 10 versions as completions\n    let items: Vec<CompletionItem> = version_info\n        .versions\n        .iter()\n        .take(10)\n        .enumerate()\n        .map(|(i, version)| {\n            let is_latest = i == 0;\n            let release_date = version_info.get_release_date(version);\n\n            // Build detail string with version and optional release age\n            let detail = match release_date {\n                Some(dt) => {\n                    let age = format_release_age(dt);\n                    if is_latest {\n                        format!(\"{} [Latest] - {}\", version, age)\n                    } else {\n                        format!(\"{} - {}\", version, age)\n                    }\n                }\n                None => {\n                    if is_latest {\n                        format!(\"{} [Latest]\", version)\n                    } else {\n                        format!(\"Version {}\", version)\n                    }\n                }\n            };\n\n            // Build documentation with more details\n            let documentation = {\n                let mut doc = String::new();\n                if is_latest {\n                    doc.push_str(\"**Latest stable version**\\n\\n\");\n                }\n                if let Some(dt) = release_date {\n                    let date_str = dt.format(\"%Y-%m-%d\").to_string();\n                    let age = format_release_age(dt);\n                    doc.push_str(&format!(\"Released: {} ({})\", date_str, age));\n                }\n                if doc.is_empty() {\n                    None\n                } else {\n                    Some(Documentation::MarkupContent(MarkupContent {\n                        kind: MarkupKind::Markdown,\n                        value: doc,\n                    }))\n                }\n            };\n\n            CompletionItem {\n                label: version.clone(),\n                kind: Some(CompletionItemKind::CONSTANT),\n                detail: Some(detail),\n                documentation,\n                sort_text: Some(format!(\"{:04}\", i)), // Ensures correct ordering\n                insert_text: Some(version.clone()),\n                insert_text_format: Some(InsertTextFormat::PLAIN_TEXT),\n                ..Default::default()\n            }\n        })\n        .collect();\n\n    Some(items)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cache::{MemoryCache, WriteCache};\n    use crate::registries::VersionInfo;\n    use chrono::Duration;\n    use std::collections::HashMap;\n\n    fn create_test_dependency(name: &str, version: &str, line: u32) -> Dependency {\n        Dependency {\n            name: name.to_string(),\n            version: version.to_string(),\n            line,\n            name_start: 0,\n            name_end: name.len() as u32,\n            version_start: name.len() as u32 + 4,\n            version_end: name.len() as u32 + 4 + version.len() as u32,\n            dev: false,\n            optional: false,\n        }\n    }\n\n    #[test]\n    fn test_format_release_age_minutes() {\n        let now = Utc::now();\n        let released = now - Duration::minutes(30);\n        let age = format_release_age(released);\n        assert_eq!(age, \"30 mins ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_hours() {\n        let now = Utc::now();\n        let released = now - Duration::hours(5);\n        let age = format_release_age(released);\n        assert_eq!(age, \"5 hours ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_yesterday() {\n        let now = Utc::now();\n        let released = now - Duration::days(1);\n        let age = format_release_age(released);\n        assert_eq!(age, \"yesterday\");\n    }\n\n    #[test]\n    fn test_format_release_age_days() {\n        let now = Utc::now();\n        let released = now - Duration::days(5);\n        let age = format_release_age(released);\n        assert_eq!(age, \"5 days ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_weeks() {\n        let now = Utc::now();\n        let released = now - Duration::days(14);\n        let age = format_release_age(released);\n        assert_eq!(age, \"2 weeks ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_months() {\n        let now = Utc::now();\n        let released = now - Duration::days(60);\n        let age = format_release_age(released);\n        assert_eq!(age, \"2 months ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_years() {\n        let now = Utc::now();\n        let released = now - Duration::days(400);\n        let age = format_release_age(released);\n        assert_eq!(age, \"1 year ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_just_now() {\n        let now = Utc::now();\n        let age = format_release_age(now);\n        assert_eq!(age, \"just now\");\n    }\n\n    #[test]\n    fn test_get_completions() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.200\".to_string()),\n                versions: vec![\n                    \"1.0.200\".to_string(),\n                    \"1.0.199\".to_string(),\n                    \"1.0.198\".to_string(),\n                ],\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        // Position inside the version field\n        let position = Position {\n            line: 5,\n            character: 13, // Within version_start to version_end\n        };\n\n        let completions = get_completions(&deps, position, &cache, |name| format!(\"test:{}\", name));\n\n        assert!(completions.is_some());\n        let items = completions.unwrap();\n        assert_eq!(items.len(), 3);\n        assert_eq!(items[0].label, \"1.0.200\");\n        assert_eq!(items[1].label, \"1.0.199\");\n    }\n\n    #[test]\n    fn test_get_completions_with_release_dates() {\n        let cache = MemoryCache::new();\n        let now = Utc::now();\n        let mut release_dates = HashMap::new();\n        release_dates.insert(\"1.0.200\".to_string(), now - Duration::days(2));\n        release_dates.insert(\"1.0.199\".to_string(), now - Duration::days(10));\n\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.200\".to_string()),\n                versions: vec![\n                    \"1.0.200\".to_string(),\n                    \"1.0.199\".to_string(),\n                    \"1.0.198\".to_string(),\n                ],\n                release_dates,\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let position = Position {\n            line: 5,\n            character: 13,\n        };\n\n        let completions = get_completions(&deps, position, &cache, |name| format!(\"test:{}\", name));\n\n        assert!(completions.is_some());\n        let items = completions.unwrap();\n        assert_eq!(items.len(), 3);\n\n        // First item should have [Latest] and release date\n        assert!(items[0].detail.as_ref().unwrap().contains(\"[Latest]\"));\n        assert!(items[0].detail.as_ref().unwrap().contains(\"2 days ago\"));\n\n        // Second item should have release date but not [Latest]\n        assert!(!items[1].detail.as_ref().unwrap().contains(\"[Latest]\"));\n        assert!(items[1].detail.as_ref().unwrap().contains(\"1 week ago\"));\n\n        // Third item has no release date\n        assert!(!items[2].detail.as_ref().unwrap().contains(\"[Latest]\"));\n        assert_eq!(items[2].detail.as_ref().unwrap(), \"Version 1.0.198\");\n    }\n\n    #[test]\n    fn test_no_completions_outside_version() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.200\".to_string()),\n                versions: vec![\"1.0.200\".to_string()],\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        // Position outside the version field\n        let position = Position {\n            line: 5,\n            character: 0, // At the start, not in version\n        };\n\n        let completions = get_completions(&deps, position, &cache, |name| format!(\"test:{}\", name));\n\n        assert!(completions.is_none());\n    }\n\n    #[test]\n    fn test_no_completions_wrong_line() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.200\".to_string()),\n                versions: vec![\"1.0.200\".to_string()],\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let position = Position {\n            line: 10, // Wrong line\n            character: 13,\n        };\n\n        let completions = get_completions(&deps, position, &cache, |name| format!(\"test:{}\", name));\n\n        assert!(completions.is_none());\n    }\n\n    #[test]\n    fn test_no_completions_no_cache() {\n        let cache = MemoryCache::new();\n        let deps = vec![create_test_dependency(\"unknown\", \"1.0.0\", 5)];\n        let position = Position {\n            line: 5,\n            character: 13,\n        };\n\n        let completions = get_completions(&deps, position, &cache, |name| format!(\"test:{}\", name));\n\n        assert!(completions.is_none());\n    }\n\n    #[test]\n    fn test_format_release_age_1_hour() {\n        let now = Utc::now();\n        let released = now - Duration::hours(1);\n        let age = format_release_age(released);\n        assert_eq!(age, \"1 hour ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_1_minute() {\n        let now = Utc::now();\n        let released = now - Duration::minutes(1);\n        let age = format_release_age(released);\n        assert_eq!(age, \"1 min ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_1_week() {\n        let now = Utc::now();\n        let released = now - Duration::days(7);\n        let age = format_release_age(released);\n        assert_eq!(age, \"1 week ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_1_month() {\n        let now = Utc::now();\n        let released = now - Duration::days(30);\n        let age = format_release_age(released);\n        assert_eq!(age, \"1 month ago\");\n    }\n\n    #[test]\n    fn test_format_release_age_future_date() {\n        let now = Utc::now();\n        let released = now + Duration::days(5);\n        let age = format_release_age(released);\n        assert_eq!(age, \"just now\");\n    }\n\n    #[test]\n    fn test_completions_many_versions() {\n        let cache = MemoryCache::new();\n        let versions: Vec<String> = (0..20).map(|i| format!(\"1.0.{}\", 20 - i)).collect();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.20\".to_string()),\n                versions,\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let position = Position {\n            line: 5,\n            character: 13,\n        };\n\n        let completions = get_completions(&deps, position, &cache, |name| format!(\"test:{}\", name));\n\n        assert!(completions.is_some());\n        let items = completions.unwrap();\n        assert_eq!(items.len(), 10);\n    }\n}\n","traces":[{"line":10,"address":[15525632],"length":1,"stats":{"Line":2}},{"line":11,"address":[14187445],"length":1,"stats":{"Line":2}},{"line":12,"address":[14169173],"length":1,"stats":{"Line":4}},{"line":14,"address":[14187537],"length":1,"stats":{"Line":3}},{"line":15,"address":[14187552],"length":1,"stats":{"Line":4}},{"line":16,"address":[15525781],"length":1,"stats":{"Line":2}},{"line":19,"address":[14187560],"length":1,"stats":{"Line":3}},{"line":20,"address":[14169309],"length":1,"stats":{"Line":4}},{"line":21,"address":[14187612],"length":1,"stats":{"Line":4}},{"line":22,"address":[14169351],"length":1,"stats":{"Line":2}},{"line":23,"address":[12939173],"length":1,"stats":{"Line":2}},{"line":24,"address":[14169407],"length":1,"stats":{"Line":2}},{"line":26,"address":[14169430,14169393],"length":1,"stats":{"Line":4}},{"line":28,"address":[15526182,15525871],"length":1,"stats":{"Line":4}},{"line":31,"address":[12939141],"length":1,"stats":{"Line":2}},{"line":32,"address":[14169952],"length":1,"stats":{"Line":2}},{"line":35,"address":[15526470],"length":1,"stats":{"Line":2}},{"line":36,"address":[14188288],"length":1,"stats":{"Line":2}},{"line":39,"address":[15526478],"length":1,"stats":{"Line":2}},{"line":40,"address":[14170874,14170150,14170910],"length":1,"stats":{"Line":5}},{"line":41,"address":[14170923,14170897],"length":1,"stats":{"Line":5}},{"line":44,"address":[15526632],"length":1,"stats":{"Line":2}},{"line":45,"address":[14170558,14170594,14170209],"length":1,"stats":{"Line":4}},{"line":46,"address":[12940414,12940388],"length":1,"stats":{"Line":4}},{"line":49,"address":[14170183,14170242,14170278],"length":1,"stats":{"Line":4}},{"line":50,"address":[14188579,14188553],"length":1,"stats":{"Line":4}},{"line":54,"address":[14906187,14900544,14903339,14903498,14906346,14904320,14901488,14907131,14906224,14902432,14904283,14905280,14902395,14904456,14901451,14902554,14905243,14903376,14901610,14905402,14900666],"length":1,"stats":{"Line":12}},{"line":61,"address":[14900717,14903475,14904310,14905270,14905453,14902422,14906397,14905379,14901587,14903366,14904507,14919152,14919040,14907158,14919376,14919488,14935280,14919264,14904433,14902605,14903549,14906323,14901661,14911088,14906214,14900643,14901478,14902531],"length":1,"stats":{"Line":40}},{"line":62,"address":[14919409,14919060,14919396,14919521,14919073,14935300,14919172,14911121,14935313,14919508,14919284,14919185,14911108,14919297],"length":1,"stats":{"Line":16}},{"line":63,"address":[14187362],"length":1,"stats":{"Line":10}},{"line":64,"address":[14919226,14919562,14919338,14935354,14911162,14919114,14919450],"length":1,"stats":{"Line":8}},{"line":67,"address":[14182718],"length":1,"stats":{"Line":8}},{"line":68,"address":[14906602,14906686,14901950,14901866,14903754,14905742,14901006,14902810,14904712,14902894,14903838,14904796,14900922,14905658],"length":1,"stats":{"Line":16}},{"line":71,"address":[14183037],"length":1,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[14911241,14905130,14907018,14913088,14933248,14919600,14927481,14907209,14935236,14915161,14917008,14902282,14901338,14923561,14925408,14919641,14923520,14918996,14909056,14904170,14927396,14927440,14929328,14906074,14921488,14907168,14931316,14931360,14903226,14915120,14915076,14911044,14923476,14931401,14911200],"length":1,"stats":{"Line":18}},{"line":77,"address":[14165203],"length":1,"stats":{"Line":6}},{"line":78,"address":[19062745,19066777,19079097,19083017,19086937,19075065,19070697],"length":1,"stats":{"Line":6}},{"line":81,"address":[14183560],"length":1,"stats":{"Line":6}},{"line":82,"address":[14923727,14919807,14911407,14927647,14907375,14931567,14915327],"length":1,"stats":{"Line":2}},{"line":83,"address":[14919831,14923751,14931591,14927671,14907399,14911431,14915351],"length":1,"stats":{"Line":2}},{"line":84,"address":[19080036,19083166,19083956,19063684,19062894,19067716,19087086,19087876,19076004,19079246,19066926,19070846,19071636,19075214],"length":1,"stats":{"Line":4}},{"line":85,"address":[19067311,19079631,19063279,19071231,19075599,19063536,19071488,19067568,19075856,19079888,19083551,19087471,19083808,19087728],"length":1,"stats":{"Line":4}},{"line":87,"address":[14184001,14184139],"length":1,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[14165393,14165544],"length":1,"stats":{"Line":12}},{"line":92,"address":[14165549],"length":1,"stats":{"Line":4}},{"line":94,"address":[19087113,19062921,19079273,19083193,19066953,19075241,19070873],"length":1,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[14931968,14920208,14907776,14924128,14911808,14915728,14928048],"length":1,"stats":{"Line":6}},{"line":102,"address":[14928566,14912326,14908294,14916246,14924646,14932486,14920726],"length":1,"stats":{"Line":6}},{"line":103,"address":[14916287,14928607,14932527,14912438,14932598,14928678,14916358,14908406,14924687,14908335,14920838,14920767,14912367,14924758],"length":1,"stats":{"Line":12}},{"line":105,"address":[14166330,14166228],"length":1,"stats":{"Line":8}},{"line":106,"address":[19067977,19063872,19084217,19084144,19088064,19076265,19080224,19080297,19063945,19071824,19071897,19088137,19067904,19076192],"length":1,"stats":{"Line":4}},{"line":107,"address":[14166549],"length":1,"stats":{"Line":2}},{"line":108,"address":[19080464,19080551,19068231,19084384,19088304,19072151,19088391,19076519,19076432,19068144,19072064,19064112,19064199,19084471],"length":1,"stats":{"Line":4}},{"line":110,"address":[14167008,14167266,14166401],"length":1,"stats":{"Line":18}},{"line":111,"address":[14185556],"length":1,"stats":{"Line":6}},{"line":113,"address":[14909132,14925484,14933324,14913164,14921564,14929404,14917084],"length":1,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[14167018],"length":1,"stats":{"Line":6}},{"line":120,"address":[14930254,14909982,14917934,14914014,14934174,14926334,14922414],"length":1,"stats":{"Line":6}},{"line":121,"address":[14913402,14933562,14929726,14909370,14913486,14917322,14929642,14933646,14921802,14909454,14917406,14925722,14921886,14925806],"length":1,"stats":{"Line":12}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[14925814,14909462,14917414,14929734,14913494,14921894,14933654],"length":1,"stats":{"Line":6}},{"line":124,"address":[14185766],"length":1,"stats":{"Line":6}},{"line":125,"address":[14185819,14185887],"length":1,"stats":{"Line":12}},{"line":126,"address":[14186049,14186114],"length":1,"stats":{"Line":12}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[14167874],"length":1,"stats":{"Line":6}},{"line":133,"address":[14164976],"length":1,"stats":{"Line":6}}],"covered":65,"coverable":71},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","providers","diagnostics.rs"],"content":"//! Diagnostics provider for outdated dependencies and vulnerabilities\n\nuse tower_lsp::lsp_types::*;\n\nuse crate::cache::ReadCache;\nuse crate::parsers::Dependency;\nuse crate::providers::inlay_hints::{VersionStatus, compare_versions, is_local_dependency};\nuse crate::registries::{VersionInfo, Vulnerability, VulnerabilitySeverity};\nuse crate::utils::truncate_string;\n\n/// Create diagnostics for a list of dependencies\n///\n/// The `min_severity` parameter filters vulnerabilities to only show those\n/// at or above the specified severity level.\npub fn create_diagnostics(\n    dependencies: &[Dependency],\n    cache: &impl ReadCache,\n    cache_key_fn: impl Fn(&str) -> String,\n    min_severity: Option<VulnerabilitySeverity>,\n) -> Vec<Diagnostic> {\n    let mut diagnostics = Vec::new();\n\n    for dep in dependencies {\n        // Show informational diagnostic for local/path dependencies\n        if is_local_dependency(&dep.version) {\n            diagnostics.push(create_local_dependency_diagnostic(dep));\n            continue;\n        }\n\n        // Add outdated version diagnostic\n        if let Some(diag) = create_outdated_diagnostic(dep, cache, &cache_key_fn) {\n            diagnostics.push(diag);\n        }\n\n        let cache_key = cache_key_fn(&dep.name);\n        if let Some(version_info) = cache.get(&cache_key) {\n            // Add yanked version diagnostic (highest priority)\n            if version_info.is_version_yanked(&dep.version) {\n                tracing::debug!(\n                    \"Package {} {} is yanked, creating diagnostic\",\n                    dep.name,\n                    dep.version\n                );\n                diagnostics.push(create_yanked_diagnostic(dep, &version_info));\n            } else if version_info.deprecated {\n                // Add deprecation diagnostic\n                tracing::debug!(\n                    \"Package {} {} is deprecated, creating diagnostic\",\n                    dep.name,\n                    dep.version\n                );\n                diagnostics.push(create_deprecation_diagnostic(dep, &version_info));\n            } else {\n                // Add vulnerability diagnostic (summary) only if not deprecated or yanked\n                let filtered_vulns: Vec<_> = version_info\n                    .vulnerabilities\n                    .iter()\n                    .filter(|vuln| {\n                        min_severity\n                            .as_ref()\n                            .map(|min| meets_severity_threshold(&vuln.severity, min))\n                            .unwrap_or(true)\n                    })\n                    .collect();\n\n                if !filtered_vulns.is_empty() {\n                    diagnostics.push(create_vulnerability_summary_diagnostic(\n                        dep,\n                        &filtered_vulns,\n                    ));\n                }\n            }\n        }\n    }\n\n    diagnostics\n}\n\n/// Check if a vulnerability severity meets the minimum threshold\nfn meets_severity_threshold(severity: &VulnerabilitySeverity, min: &VulnerabilitySeverity) -> bool {\n    severity.meets_threshold(min)\n}\n\n/// Create a diagnostic for an outdated dependency\nfn create_outdated_diagnostic(\n    dep: &Dependency,\n    cache: &impl ReadCache,\n    cache_key_fn: impl Fn(&str) -> String,\n) -> Option<Diagnostic> {\n    let cache_key = cache_key_fn(&dep.name);\n    let version_info = cache.get(&cache_key)?;\n\n    match compare_versions(&dep.version, &version_info) {\n        VersionStatus::UpdateAvailable(new_version) => Some(Diagnostic {\n            range: Range {\n                start: Position {\n                    line: dep.line,\n                    character: dep.version_start,\n                },\n                end: Position {\n                    line: dep.line,\n                    character: dep.version_end,\n                },\n            },\n            severity: Some(DiagnosticSeverity::HINT),\n            code: Some(NumberOrString::String(\"outdated\".to_string())),\n            source: Some(\"dependi\".to_string()),\n            message: format!(\"Update available: {} -> {}\", dep.version, new_version),\n            related_information: None,\n            tags: None,\n            code_description: None,\n            data: None,\n        }),\n        VersionStatus::UpToDate | VersionStatus::Unknown => None,\n    }\n}\n\n/// Create a diagnostic for a local/path dependency\nfn create_local_dependency_diagnostic(dep: &Dependency) -> Diagnostic {\n    Diagnostic {\n        range: Range {\n            start: Position {\n                line: dep.line,\n                character: dep.version_start,\n            },\n            end: Position {\n                line: dep.line,\n                character: dep.version_end,\n            },\n        },\n        severity: Some(DiagnosticSeverity::HINT),\n        code: Some(NumberOrString::String(\"local\".to_string())),\n        source: Some(\"dependi\".to_string()),\n        message: \"→ Local\".to_string(),\n        related_information: None,\n        tags: None,\n        code_description: None,\n        data: None,\n    }\n}\n\n/// Create a diagnostic for a deprecated package\nfn create_deprecation_diagnostic(dep: &Dependency, version_info: &VersionInfo) -> Diagnostic {\n    let mut message = format!(\n        \"The package '{}' is deprecated. Consider migrating to an alternative.\",\n        dep.name\n    );\n\n    if let Some(latest) = &version_info.latest {\n        message.push_str(&format!(\n            \" Latest version: {} (may not be deprecated).\",\n            latest\n        ));\n    }\n\n    let mut related_info = Vec::new();\n\n    if let Some(homepage) = &version_info.homepage {\n        related_info.push(DiagnosticRelatedInformation {\n            location: Location {\n                uri: Url::parse(homepage).unwrap_or_else(|_| {\n                    Url::parse(\"https://example.com\").expect(\"Invalid fallback URL\")\n                }),\n                range: Range::default(),\n            },\n            message: \"Visit package homepage\".to_string(),\n        });\n    }\n\n    if let Some(repo) = &version_info.repository {\n        related_info.push(DiagnosticRelatedInformation {\n            location: Location {\n                uri: Url::parse(repo).unwrap_or_else(|_| {\n                    Url::parse(\"https://github.com\").expect(\"Invalid fallback URL\")\n                }),\n                range: Range::default(),\n            },\n            message: \"View repository for migration guide\".to_string(),\n        });\n    }\n\n    Diagnostic {\n        range: Range {\n            start: Position {\n                line: dep.line,\n                character: dep.version_start,\n            },\n            end: Position {\n                line: dep.line,\n                character: dep.version_end,\n            },\n        },\n        severity: Some(DiagnosticSeverity::WARNING),\n        code: Some(NumberOrString::String(\"deprecated-package\".to_string())),\n        source: Some(\"dependi\".to_string()),\n        message,\n        related_information: if related_info.is_empty() {\n            None\n        } else {\n            Some(related_info)\n        },\n        tags: None,\n        code_description: None,\n        data: None,\n    }\n}\n\n/// Create a diagnostic for a yanked version\nfn create_yanked_diagnostic(dep: &Dependency, version_info: &VersionInfo) -> Diagnostic {\n    let mut message = format!(\n        \"The version '{}' of '{}' has been yanked from crates.io and should not be used.\",\n        dep.version, dep.name\n    );\n\n    if let Some(latest) = &version_info.latest {\n        message.push_str(&format!(\" Update to {}.\", latest));\n    }\n\n    let crates_io_url = format!(\"https://crates.io/crates/{}\", dep.name);\n    let mut related_info = vec![DiagnosticRelatedInformation {\n        location: Location {\n            uri: Url::parse(&crates_io_url)\n                .unwrap_or_else(|_| Url::parse(\"https://crates.io\").expect(\"Invalid fallback URL\")),\n            range: Range::default(),\n        },\n        message: \"View package on crates.io\".to_string(),\n    }];\n\n    if let Some(repo) = &version_info.repository {\n        related_info.push(DiagnosticRelatedInformation {\n            location: Location {\n                uri: Url::parse(repo).unwrap_or_else(|_| {\n                    Url::parse(\"https://github.com\").expect(\"Invalid fallback URL\")\n                }),\n                range: Range::default(),\n            },\n            message: \"View repository for more information\".to_string(),\n        });\n    }\n\n    Diagnostic {\n        range: Range {\n            start: Position {\n                line: dep.line,\n                character: dep.version_start,\n            },\n            end: Position {\n                line: dep.line,\n                character: dep.version_end,\n            },\n        },\n        severity: Some(DiagnosticSeverity::WARNING),\n        code: Some(NumberOrString::String(\"yanked-version\".to_string())),\n        source: Some(\"dependi\".to_string()),\n        message,\n        related_information: Some(related_info),\n        tags: None,\n        code_description: Some(CodeDescription {\n            href: Url::parse(&crates_io_url)\n                .unwrap_or_else(|_| Url::parse(\"https://crates.io\").expect(\"Invalid fallback URL\")),\n        }),\n        data: None,\n    }\n}\n\n/// Create a summary diagnostic for multiple vulnerabilities\nfn create_vulnerability_summary_diagnostic(\n    dep: &Dependency,\n    vulns: &[&Vulnerability],\n) -> Diagnostic {\n    let count = vulns.len();\n\n    // Use the highest severity among all vulnerabilities\n    let severity_to_num = |s: &VulnerabilitySeverity| match s {\n        VulnerabilitySeverity::Critical => 4,\n        VulnerabilitySeverity::High => 3,\n        VulnerabilitySeverity::Medium => 2,\n        VulnerabilitySeverity::Low => 1,\n    };\n    let max_severity = vulns\n        .iter()\n        .map(|v| &v.severity)\n        .max_by_key(|s| severity_to_num(s))\n        .unwrap_or(&VulnerabilitySeverity::Low);\n\n    let diagnostic_severity = match max_severity {\n        VulnerabilitySeverity::Critical | VulnerabilitySeverity::High => DiagnosticSeverity::ERROR,\n        VulnerabilitySeverity::Medium => DiagnosticSeverity::WARNING,\n        VulnerabilitySeverity::Low => DiagnosticSeverity::HINT,\n    };\n\n    // Build summary message\n    let vuln_word = if count == 1 { \"vuln\" } else { \"vulns\" };\n    let vuln_ids: Vec<_> = vulns.iter().map(|v| v.id.as_str()).collect();\n    let message = format!(\"⚠ {} {}: {}\", count, vuln_word, vuln_ids.join(\", \"));\n\n    // Collect related information for all vulnerabilities\n    let related_info: Vec<_> = vulns\n        .iter()\n        .filter_map(|vuln| {\n            vuln.url.as_ref().map(|url| DiagnosticRelatedInformation {\n                location: Location {\n                    uri: Url::parse(url).unwrap_or_else(|_| {\n                        Url::parse(\"https://osv.dev\").expect(\"Invalid fallback URL\")\n                    }),\n                    range: Range::default(),\n                },\n                message: format!(\"{}: {}\", vuln.id, truncate_string(&vuln.description, 80)),\n            })\n        })\n        .collect();\n\n    Diagnostic {\n        range: Range {\n            start: Position {\n                line: dep.line,\n                character: dep.version_start,\n            },\n            end: Position {\n                line: dep.line,\n                character: dep.version_end,\n            },\n        },\n        severity: Some(diagnostic_severity),\n        code: Some(NumberOrString::String(format!(\"{}-vulns\", count))),\n        source: Some(\"dependi-security\".to_string()),\n        message,\n        related_information: if related_info.is_empty() {\n            None\n        } else {\n            Some(related_info)\n        },\n        tags: None,\n        code_description: vulns.first().and_then(|v| {\n            v.url\n                .as_ref()\n                .and_then(|url| Url::parse(url).ok().map(|href| CodeDescription { href }))\n        }),\n        data: None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cache::{MemoryCache, WriteCache};\n    use crate::registries::VersionInfo;\n\n    fn create_test_dependency(name: &str, version: &str, line: u32) -> Dependency {\n        Dependency {\n            name: name.to_string(),\n            version: version.to_string(),\n            line,\n            name_start: 0,\n            name_end: name.len() as u32,\n            version_start: name.len() as u32 + 4,\n            version_end: name.len() as u32 + 4 + version.len() as u32,\n            dev: false,\n            optional: false,\n        }\n    }\n\n    #[test]\n    fn test_create_diagnostic_outdated() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        assert_eq!(diagnostics.len(), 1);\n        assert!(diagnostics[0].message.contains(\"2.0.0\"));\n        assert_eq!(diagnostics[0].severity, Some(DiagnosticSeverity::HINT));\n    }\n\n    #[test]\n    fn test_no_diagnostic_up_to_date() {\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        assert_eq!(diagnostics.len(), 0);\n    }\n\n    #[test]\n    fn test_no_diagnostic_no_cache() {\n        let cache = MemoryCache::new();\n        let deps = vec![create_test_dependency(\"unknown\", \"1.0.0\", 5)];\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        assert_eq!(diagnostics.len(), 0);\n    }\n\n    #[test]\n    fn test_severity_filtering() {\n        assert!(meets_severity_threshold(\n            &VulnerabilitySeverity::Critical,\n            &VulnerabilitySeverity::Low\n        ));\n        assert!(meets_severity_threshold(\n            &VulnerabilitySeverity::High,\n            &VulnerabilitySeverity::Medium\n        ));\n        assert!(!meets_severity_threshold(\n            &VulnerabilitySeverity::Low,\n            &VulnerabilitySeverity::High\n        ));\n        assert!(meets_severity_threshold(\n            &VulnerabilitySeverity::Medium,\n            &VulnerabilitySeverity::Medium\n        ));\n    }\n\n    #[test]\n    fn test_deprecated_diagnostic() {\n        let deps = vec![create_test_dependency(\"old-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:old-dep\".to_string(),\n            VersionInfo {\n                deprecated: true,\n                latest: Some(\"2.0.0\".to_string()),\n                homepage: Some(\"https://example.com\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let deprecation_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"deprecated\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        assert_eq!(deprecation_diags.len(), 1);\n        assert!(deprecation_diags[0].message.contains(\"deprecated\"));\n        assert_eq!(\n            deprecation_diags[0].severity,\n            Some(DiagnosticSeverity::WARNING)\n        );\n        assert!(deprecation_diags[0].related_information.is_some());\n    }\n\n    #[test]\n    fn test_no_deprecated_diagnostic_for_active() {\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                deprecated: false,\n                latest: Some(\"1.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let deprecation_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"deprecated\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        assert_eq!(deprecation_diags.len(), 0);\n    }\n\n    #[test]\n    fn test_deprecated_with_vulnerabilities() {\n        let deps = vec![create_test_dependency(\"vuln-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:vuln-dep\".to_string(),\n            VersionInfo {\n                deprecated: true,\n                vulnerabilities: vec![Vulnerability {\n                    id: \"CVE-2024-1234\".to_string(),\n                    severity: VulnerabilitySeverity::High,\n                    description: \"Test vulnerability\".to_string(),\n                    url: None,\n                }],\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let deprecation_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"deprecated\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        let vuln_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.starts_with(\"CVE\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        assert_eq!(deprecation_diags.len(), 1);\n        assert_eq!(\n            vuln_diags.len(),\n            0,\n            \"Deprecated packages should not show individual vulnerability diagnostics\"\n        );\n    }\n\n    #[test]\n    fn test_yanked_diagnostic() {\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                yanked_versions: vec![\"1.0.0\".to_string()],\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let yanked_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"yanked\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        assert_eq!(yanked_diags.len(), 1);\n        assert!(yanked_diags[0].message.contains(\"yanked\"));\n        assert_eq!(yanked_diags[0].severity, Some(DiagnosticSeverity::WARNING));\n    }\n\n    #[test]\n    fn test_no_yanked_diagnostic_for_non_yanked() {\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                yanked_versions: vec![\"0.9.0\".to_string()],\n                latest: Some(\"1.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let yanked_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"yanked\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        assert_eq!(yanked_diags.len(), 0);\n    }\n\n    #[test]\n    fn test_yanked_priority_over_deprecated_diagnostic() {\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                yanked_versions: vec![\"1.0.0\".to_string()],\n                deprecated: true,\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let yanked_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"yanked\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        let deprecated_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"deprecated\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        assert_eq!(yanked_diags.len(), 1, \"Should show yanked diagnostic\");\n        assert_eq!(\n            deprecated_diags.len(),\n            0,\n            \"Yanked packages should not show deprecated diagnostic\"\n        );\n    }\n\n    #[test]\n    fn test_yanked_priority_over_vulnerabilities_diagnostic() {\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                yanked_versions: vec![\"1.0.0\".to_string()],\n                vulnerabilities: vec![Vulnerability {\n                    id: \"CVE-2024-1234\".to_string(),\n                    severity: VulnerabilitySeverity::High,\n                    description: \"Test vulnerability\".to_string(),\n                    url: None,\n                }],\n                latest: Some(\"2.0.0\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let yanked_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.contains(\"yanked\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        let vuln_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .and_then(|c| match c {\n                        NumberOrString::String(s) => Some(s.starts_with(\"CVE\")),\n                        _ => None,\n                    })\n                    .unwrap_or(false)\n            })\n            .collect();\n\n        assert_eq!(yanked_diags.len(), 1, \"Should show yanked diagnostic\");\n        assert_eq!(\n            vuln_diags.len(),\n            0,\n            \"Yanked packages should not show vulnerability diagnostics\"\n        );\n    }\n\n    #[test]\n    fn test_local_dependency_diagnostic() {\n        let deps = vec![create_test_dependency(\"local-crate\", \"../local\", 5)];\n        let cache = MemoryCache::new();\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        assert_eq!(diagnostics.len(), 1);\n        assert!(diagnostics[0].message.contains(\"Local\"));\n        assert_eq!(diagnostics[0].severity, Some(DiagnosticSeverity::HINT));\n    }\n\n    #[test]\n    fn test_vulnerability_summary_diagnostic() {\n        let deps = vec![create_test_dependency(\"vuln-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:vuln-dep\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                vulnerabilities: vec![\n                    Vulnerability {\n                        id: \"CVE-2024-1234\".to_string(),\n                        severity: VulnerabilitySeverity::High,\n                        description: \"High severity vulnerability\".to_string(),\n                        url: Some(\"https://osv.dev/CVE-2024-1234\".to_string()),\n                    },\n                    Vulnerability {\n                        id: \"CVE-2024-5678\".to_string(),\n                        severity: VulnerabilitySeverity::Medium,\n                        description: \"Medium severity vulnerability\".to_string(),\n                        url: None,\n                    },\n                ],\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let vuln_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .is_some_and(|c| matches!(c, NumberOrString::String(s) if s.contains(\"vulns\")))\n            })\n            .collect();\n\n        assert_eq!(vuln_diags.len(), 1);\n        assert!(vuln_diags[0].message.contains(\"2 vulns\"));\n        assert_eq!(vuln_diags[0].severity, Some(DiagnosticSeverity::ERROR));\n        assert!(vuln_diags[0].related_information.is_some());\n    }\n\n    #[test]\n    fn test_vulnerability_severity_filtering() {\n        let deps = vec![create_test_dependency(\"vuln-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:vuln-dep\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                vulnerabilities: vec![\n                    Vulnerability {\n                        id: \"CVE-2024-LOW\".to_string(),\n                        severity: VulnerabilitySeverity::Low,\n                        description: \"Low severity\".to_string(),\n                        url: None,\n                    },\n                    Vulnerability {\n                        id: \"CVE-2024-HIGH\".to_string(),\n                        severity: VulnerabilitySeverity::High,\n                        description: \"High severity\".to_string(),\n                        url: None,\n                    },\n                ],\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(\n            &deps,\n            &cache,\n            |name| format!(\"test:{}\", name),\n            Some(VulnerabilitySeverity::High),\n        );\n\n        let vuln_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .is_some_and(|c| matches!(c, NumberOrString::String(s) if s.contains(\"vulns\")))\n            })\n            .collect();\n\n        assert_eq!(vuln_diags.len(), 1);\n        assert!(vuln_diags[0].message.contains(\"1 vuln\"));\n    }\n\n    #[test]\n    fn test_deprecation_diagnostic_with_repository() {\n        let deps = vec![create_test_dependency(\"old-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:old-dep\".to_string(),\n            VersionInfo {\n                deprecated: true,\n                latest: Some(\"2.0.0\".to_string()),\n                repository: Some(\"https://github.com/user/old-dep\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let deprecation_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .is_some_and(|c| matches!(c, NumberOrString::String(s) if s.contains(\"deprecated\")))\n            })\n            .collect();\n\n        assert_eq!(deprecation_diags.len(), 1);\n        assert!(deprecation_diags[0].related_information.is_some());\n        let related = deprecation_diags[0].related_information.as_ref().unwrap();\n        assert!(!related.is_empty());\n    }\n\n    #[test]\n    fn test_yanked_diagnostic_with_repository() {\n        let deps = vec![create_test_dependency(\"serde\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:serde\".to_string(),\n            VersionInfo {\n                yanked_versions: vec![\"1.0.0\".to_string()],\n                latest: Some(\"2.0.0\".to_string()),\n                repository: Some(\"https://github.com/serde-rs/serde\".to_string()),\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let yanked_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .is_some_and(|c| matches!(c, NumberOrString::String(s) if s.contains(\"yanked\")))\n            })\n            .collect();\n\n        assert_eq!(yanked_diags.len(), 1);\n        assert!(yanked_diags[0].related_information.is_some());\n        let related = yanked_diags[0].related_information.as_ref().unwrap();\n        assert_eq!(related.len(), 2);\n    }\n\n    #[test]\n    fn test_vulnerability_low_severity_hint() {\n        let deps = vec![create_test_dependency(\"vuln-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:vuln-dep\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                vulnerabilities: vec![Vulnerability {\n                    id: \"CVE-2024-LOW\".to_string(),\n                    severity: VulnerabilitySeverity::Low,\n                    description: \"Low severity\".to_string(),\n                    url: None,\n                }],\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let vuln_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .is_some_and(|c| matches!(c, NumberOrString::String(s) if s.contains(\"vulns\")))\n            })\n            .collect();\n\n        assert_eq!(vuln_diags.len(), 1);\n        assert_eq!(vuln_diags[0].severity, Some(DiagnosticSeverity::HINT));\n    }\n\n    #[test]\n    fn test_vulnerability_medium_severity_warning() {\n        let deps = vec![create_test_dependency(\"vuln-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:vuln-dep\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                vulnerabilities: vec![Vulnerability {\n                    id: \"CVE-2024-MED\".to_string(),\n                    severity: VulnerabilitySeverity::Medium,\n                    description: \"Medium severity\".to_string(),\n                    url: None,\n                }],\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let vuln_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .is_some_and(|c| matches!(c, NumberOrString::String(s) if s.contains(\"vulns\")))\n            })\n            .collect();\n\n        assert_eq!(vuln_diags.len(), 1);\n        assert_eq!(vuln_diags[0].severity, Some(DiagnosticSeverity::WARNING));\n    }\n\n    #[test]\n    fn test_vulnerability_critical_severity_error() {\n        let deps = vec![create_test_dependency(\"vuln-dep\", \"1.0.0\", 5)];\n        let cache = MemoryCache::new();\n        cache.insert(\n            \"test:vuln-dep\".to_string(),\n            VersionInfo {\n                latest: Some(\"1.0.0\".to_string()),\n                vulnerabilities: vec![Vulnerability {\n                    id: \"CVE-2024-CRIT\".to_string(),\n                    severity: VulnerabilitySeverity::Critical,\n                    description: \"Critical severity\".to_string(),\n                    url: None,\n                }],\n                ..Default::default()\n            },\n        );\n\n        let diagnostics = create_diagnostics(&deps, &cache, |name| format!(\"test:{}\", name), None);\n\n        let vuln_diags: Vec<_> = diagnostics\n            .iter()\n            .filter(|d| {\n                d.code\n                    .as_ref()\n                    .is_some_and(|c| matches!(c, NumberOrString::String(s) if s.contains(\"vulns\")))\n            })\n            .collect();\n\n        assert_eq!(vuln_diags.len(), 1);\n        assert_eq!(vuln_diags[0].severity, Some(DiagnosticSeverity::ERROR));\n    }\n}\n","traces":[{"line":15,"address":[13061648,13061756,13063177],"length":1,"stats":{"Line":36}},{"line":21,"address":[18717177,18735769,18762345,18757033,18741097,18722489,18749065,18733113,18743753,18746409,18725145,18751721,18754377,18759689,18727801,18719833,18730457,18714521,18738433],"length":1,"stats":{"Line":36}},{"line":23,"address":[13061807,13061891],"length":1,"stats":{"Line":72}},{"line":25,"address":[13090933,13091035],"length":1,"stats":{"Line":72}},{"line":26,"address":[13062189,13064403],"length":1,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[13062211,13062154],"length":1,"stats":{"Line":68}},{"line":32,"address":[18752254,18746942,18736302,18738966,18754948,18720366,18728334,18728372,18760222,18754910,18762878,18715054,18725716,18741630,18752292,18717748,18757566,18733684,18717710,18736340,18762916,18723022,18744286,18723060,18720404,18733646,18715092,18749636,18757604,18741668,18725678,18739004,18746980,18749598,18744324,18730990,18731028,18760260],"length":1,"stats":{"Line":28}},{"line":35,"address":[13607693,13626358,13591757,13591814,13613005,13620989,13615726,13597069,13594470,13615669,13618333,13628957,13599725,13607750,13634326,13631613,13626301,13586502,13605037,13629014,13631670,13613062,13621046,13623645,13594413,13634269,13602438,13623702,13602381,13610349,13618390,13589158,13586445,13589101,13599782,13605094,13610406,13597126],"length":1,"stats":{"Line":68}},{"line":36,"address":[13591829,13621160,13631685,13613077,13602453,13613176,13618405,13629128,13586517,13589272,13634341,13615840,13615741,13626373,13594584,13594485,13605208,13631784,13597240,13589173,13634440,13599797,13591928,13605109,13602552,13618504,13607864,13623717,13610421,13599896,13629029,13607765,13586616,13623816,13621061,13626472,13597141,13610520],"length":1,"stats":{"Line":68}},{"line":38,"address":[13091510,13091619],"length":1,"stats":{"Line":64}},{"line":39,"address":[13064061,13062742,13063800],"length":1,"stats":{"Line":16}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[13614653,13607015,13604029,13628279,13633591,13620311,13604359,13609341,13612327,13635917,13601703,13606685,13593405,13627949,13590749,13591079,13588423,13596061,13630935,13636247,13599047,13617655,13611997,13625293,13614983,13609671,13622967,13598717,13617323,13625623,13630605,13633261,13601373,13622637,13596391,13588093,13593735,13619981],"length":1,"stats":{"Line":16}},{"line":45,"address":[13062730],"length":1,"stats":{"Line":24}},{"line":47,"address":[13063190,13063451,13062808],"length":1,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[13590483,13603431,13611731,13606419,13601107,13609075,13627351,13619383,13624695,13600775,13590151,13619715,13635319,13625027,13611399,13603763,13622371,13592807,13587827,13630007,13630339,13627683,13608743,13632663,13593139,13617057,13587495,13614387,13622039,13632995,13635651,13598451,13606087,13614055,13595463,13595795,13598119,13616725],"length":1,"stats":{"Line":12}},{"line":55,"address":[13062773],"length":1,"stats":{"Line":18}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[18758150,18715638,18726262,18752838,18765232,18765808,18766128,18720950,18765392,18766288,18766640,18767616,18723606,18767104,18767888,18742214,18747526,18765680,18766016,18765504,18755494,18731574,18750182,18736886,18765568,18765120,18763462,18728918,18767680,18767264,18744870,18718294,18765056,18765744,18766800,18734230,18760806,18739550],"length":1,"stats":{"Line":28}},{"line":59,"address":[13639186,13636482,13636658,13636834,13638690,13638434,13637394,13638226,13639074,13637874,13638754,13636546,13636306,13637714,13636770,13637090,13637602,13636418,13638962],"length":1,"stats":{"Line":10}},{"line":60,"address":[13093493],"length":1,"stats":{"Line":10}},{"line":61,"address":[13093536,13093550,13093506],"length":1,"stats":{"Line":14}},{"line":62,"address":[13093515],"length":1,"stats":{"Line":10}},{"line":66,"address":[13063029,13062952],"length":1,"stats":{"Line":36}},{"line":67,"address":[13629697,13632353,13635009,13621729,13587185,13597809,13613745,13627041,13619073,13595153,13624385,13592497,13600465,13611089,13608433,13616415,13589841,13603121,13605777],"length":1,"stats":{"Line":10}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[13063035],"length":1,"stats":{"Line":10}},{"line":76,"address":[13062048],"length":1,"stats":{"Line":36}},{"line":80,"address":[13030832],"length":1,"stats":{"Line":2}},{"line":81,"address":[13071454],"length":1,"stats":{"Line":2}},{"line":85,"address":[13653225,13666018,13648242,13669385,13667769,13664402,13646761,13648377,13658073,13661305,13659616,13649993,13654841,13643394,13666153,13651474,13648304,13646626,13649858,13654706,13640297,13661170,13664537,13645145,13653152,13659554,13641913,13658000,13656457,13659689,13667634,13669312,13670866,13640224,13662921,13643456,13653090,13656384,13651536,13651609,13669250,13643529,13666080,13649920,13645010,13662848,13662786,13646688,13656322,13641840,13667696,13641778,13645072,13661232,13664464,13657938,13654768],"length":1,"stats":{"Line":34}},{"line":90,"address":[13649976,13648435,13662904,13640280,13640355,13651592,13643587,13646744,13646819,13659747,13643512,13664595,13667752,13662979,13653208,13661288,13656440,13648360,13654899,13658056,13658131,13666136,13653283,13664520,13641896,13645128,13667827,13661363,13651667,13656515,13659672,13666211,13645203,13669368,13669443,13650051,13641971,13654824],"length":1,"stats":{"Line":68}},{"line":91,"address":[13640370,13651763,13646834,13653379,13654995,13664610,13658227,13663075,13645218,13653298,13667923,13650147,13656611,13659843,13643683,13645299,13654914,13662994,13658146,13641986,13640451,13669539,13643602,13661378,13664691,13666226,13650066,13656530,13669458,13646915,13651682,13666307,13661459,13667842,13642067,13659762,13648450,13648531],"length":1,"stats":{"Line":68}},{"line":93,"address":[18782160,18775783,18772464,18782247,18783776,18783863,18770935,18775696,18769232,18780631,18793559,18795088,18796791,18798407,18795175,18796704,18774167,18788624,18770848,18785479,18769319,18772551,18779015,18787008,18778928,18777312,18793472,18777399,18788711,18780544,18790240,18798320,18785392,18791856,18791943,18787095,18790327,18774080],"length":1,"stats":{"Line":64}},{"line":94,"address":[13094451,13095052],"length":1,"stats":{"Line":28}},{"line":95,"address":[13094492],"length":1,"stats":{"Line":14}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[13065555],"length":1,"stats":{"Line":14}},{"line":98,"address":[13094486],"length":1,"stats":{"Line":14}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[13661841,13660225,13668305,13644065,13640833,13669921,13663457,13652145,13653761,13665073,13656993,13655377,13642449,13650529,13645681,13647297,13666689,13658609,13648913],"length":1,"stats":{"Line":14}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[13660331,13647328,13652251,13666720,13644171,13665179,13645712,13647403,13668411,13644096,13649019,13642480,13666795,13658640,13658715,13640939,13640864,13660256,13669952,13653867,13650635,13665104,13663488,13655483,13668336,13661947,13657024,13661872,13642555,13655408,13663563,13648944,13650560,13645787,13652176,13670027,13657099,13653792],"length":1,"stats":{"Line":28}},{"line":107,"address":[13668555,13655627,13650699,13652315,13662091,13644235,13647467,13645931,13663707,13642619,13649163,13653931,13662011,13663627,13670091,13665243,13645851,13657163,13649083,13658859,13644315,13666939,13654011,13652395,13642699,13655547,13660475,13658779,13665323,13657243,13668475,13670171,13647547,13641003,13650779,13641083,13666859,13660395],"length":1,"stats":{"Line":28}},{"line":108,"address":[13652518,13650811,13645963,13657366,13647579,13654043,13670203,13649286,13646054,13662214,13650902,13642822,13668678,13658891,13655750,13660598,13663830,13644347,13665355,13665446,13641206,13660507,13642731,13652427,13670294,13644438,13641115,13647670,13649195,13654134,13657275,13663739,13658982,13666971,13655659,13662123,13668587,13667062],"length":1,"stats":{"Line":28}},{"line":109,"address":[13095020],"length":1,"stats":{"Line":14}},{"line":110,"address":[13659148,13655916,13660764,13644604,13652684,13662380,13667228,13668844,13657532,13670460,13642988,13641372,13649452,13646220,13651068,13647836,13654300,13663996,13665612],"length":1,"stats":{"Line":14}},{"line":111,"address":[18781316,18779700,18795860,18797476,18773236,18770004,18786164,18782932,18784548,18799092,18794244,18791012,18789396,18787780,18774852,18778084,18771620,18776468,18792628],"length":1,"stats":{"Line":14}},{"line":112,"address":[18786172,18789404,18779708,18784556,18770012,18774860,18776476,18773244,18791020,18794252,18782940,18787788,18771628,18795868,18778092,18792636,18781324,18797484,18799100],"length":1,"stats":{"Line":14}},{"line":114,"address":[13094428],"length":1,"stats":{"Line":18}},{"line":119,"address":[13033600,13034306,13034312],"length":1,"stats":{"Line":2}},{"line":121,"address":[13074258],"length":1,"stats":{"Line":2}},{"line":132,"address":[13074274],"length":1,"stats":{"Line":2}},{"line":133,"address":[13103343,13103278],"length":1,"stats":{"Line":4}},{"line":134,"address":[13033823],"length":1,"stats":{"Line":2}},{"line":143,"address":[13074195,13072036,13071472],"length":1,"stats":{"Line":4}},{"line":144,"address":[13100443],"length":1,"stats":{"Line":4}},{"line":149,"address":[13100595],"length":1,"stats":{"Line":4}},{"line":150,"address":[15093413,15093499,15093683],"length":1,"stats":{"Line":12}},{"line":156,"address":[13100688],"length":1,"stats":{"Line":2}},{"line":158,"address":[13072047],"length":1,"stats":{"Line":2}},{"line":159,"address":[13031932],"length":1,"stats":{"Line":2}},{"line":160,"address":[13031745],"length":1,"stats":{"Line":2}},{"line":161,"address":[18799648],"length":1,"stats":{"Line":4}},{"line":162,"address":[13095621],"length":1,"stats":{"Line":0}},{"line":164,"address":[13072310],"length":1,"stats":{"Line":2}},{"line":166,"address":[13031857],"length":1,"stats":{"Line":2}},{"line":170,"address":[15094397,15093816],"length":1,"stats":{"Line":4}},{"line":171,"address":[15094799],"length":1,"stats":{"Line":2}},{"line":172,"address":[13101876],"length":1,"stats":{"Line":2}},{"line":173,"address":[13095504],"length":1,"stats":{"Line":4}},{"line":174,"address":[13066597],"length":1,"stats":{"Line":0}},{"line":176,"address":[13072897],"length":1,"stats":{"Line":2}},{"line":178,"address":[13073060],"length":1,"stats":{"Line":2}},{"line":183,"address":[13072768],"length":1,"stats":{"Line":2}},{"line":194,"address":[13102239,13101724],"length":1,"stats":{"Line":4}},{"line":195,"address":[15095110,15095035],"length":1,"stats":{"Line":4}},{"line":197,"address":[15095187,15095246,15095356],"length":1,"stats":{"Line":9}},{"line":209,"address":[13100332,13097088,13097746],"length":1,"stats":{"Line":2}},{"line":210,"address":[13068206],"length":1,"stats":{"Line":4}},{"line":215,"address":[13068427],"length":1,"stats":{"Line":5}},{"line":216,"address":[15090195,15090298],"length":1,"stats":{"Line":14}},{"line":219,"address":[13027939,13028232],"length":1,"stats":{"Line":15}},{"line":220,"address":[13069028,13068934,13069377,13071399,13068995],"length":1,"stats":{"Line":24}},{"line":221,"address":[13098118],"length":1,"stats":{"Line":8}},{"line":222,"address":[13069090,13069011],"length":1,"stats":{"Line":16}},{"line":223,"address":[13028501],"length":1,"stats":{"Line":8}},{"line":224,"address":[13069139],"length":1,"stats":{"Line":8}},{"line":226,"address":[13069302],"length":1,"stats":{"Line":8}},{"line":229,"address":[13029076],"length":1,"stats":{"Line":8}},{"line":230,"address":[13070182],"length":1,"stats":{"Line":2}},{"line":231,"address":[13098923],"length":1,"stats":{"Line":2}},{"line":232,"address":[13093568],"length":1,"stats":{"Line":4}},{"line":233,"address":[13093589],"length":1,"stats":{"Line":0}},{"line":235,"address":[13029336],"length":1,"stats":{"Line":2}},{"line":237,"address":[15091787],"length":1,"stats":{"Line":2}},{"line":242,"address":[13069774],"length":1,"stats":{"Line":6}},{"line":253,"address":[13070358,13069802],"length":1,"stats":{"Line":12}},{"line":254,"address":[13099350,13099425],"length":1,"stats":{"Line":12}},{"line":256,"address":[13099497],"length":1,"stats":{"Line":6}},{"line":258,"address":[15092464],"length":1,"stats":{"Line":8}},{"line":267,"address":[13036403,13034336,13036497],"length":1,"stats":{"Line":4}},{"line":271,"address":[13075032],"length":1,"stats":{"Line":4}},{"line":274,"address":[13066858,13066848],"length":1,"stats":{"Line":15}},{"line":275,"address":[13066919],"length":1,"stats":{"Line":2}},{"line":276,"address":[13671389],"length":1,"stats":{"Line":3}},{"line":277,"address":[13671379],"length":1,"stats":{"Line":2}},{"line":278,"address":[13066889],"length":1,"stats":{"Line":2}},{"line":282,"address":[13096010,13096000],"length":1,"stats":{"Line":16}},{"line":283,"address":[13671200,13671213],"length":1,"stats":{"Line":19}},{"line":284,"address":[15096755],"length":1,"stats":{"Line":8}},{"line":286,"address":[15096775],"length":1,"stats":{"Line":8}},{"line":287,"address":[13104113],"length":1,"stats":{"Line":5}},{"line":288,"address":[15096820],"length":1,"stats":{"Line":2}},{"line":289,"address":[13034519],"length":1,"stats":{"Line":2}},{"line":293,"address":[13104124],"length":1,"stats":{"Line":9}},{"line":294,"address":[13034630],"length":1,"stats":{"Line":24}},{"line":295,"address":[13075399,13075324],"length":1,"stats":{"Line":15}},{"line":300,"address":[13066768],"length":1,"stats":{"Line":15}},{"line":301,"address":[13067104,13066796,13067804,13067729,13067798],"length":1,"stats":{"Line":13}},{"line":302,"address":[18800358],"length":1,"stats":{"Line":2}},{"line":303,"address":[13067936,13067155],"length":1,"stats":{"Line":2}},{"line":304,"address":[13067957],"length":1,"stats":{"Line":0}},{"line":306,"address":[13096146],"length":1,"stats":{"Line":2}},{"line":308,"address":[13671807,13671722],"length":1,"stats":{"Line":4}},{"line":314,"address":[13075914],"length":1,"stats":{"Line":8}},{"line":324,"address":[13035278],"length":1,"stats":{"Line":8}},{"line":325,"address":[13104954,13104886],"length":1,"stats":{"Line":16}},{"line":326,"address":[13035526,13035601],"length":1,"stats":{"Line":16}},{"line":328,"address":[13076408,13076518,13076337],"length":1,"stats":{"Line":18}},{"line":334,"address":[13067008],"length":1,"stats":{"Line":24}}],"covered":121,"coverable":138},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","providers","inlay_hints.rs"],"content":"//! Inlay hints provider for dependency versions\n\nuse tower_lsp::lsp_types::{InlayHint, InlayHintKind, InlayHintLabel, Position};\n\nuse crate::parsers::Dependency;\nuse crate::registries::{VersionInfo, VulnerabilitySeverity};\nuse crate::utils::truncate_string;\n\n/// Result of comparing a dependency version with the latest available\n#[derive(Debug, Clone)]\npub enum VersionStatus {\n    /// Version is up to date\n    UpToDate,\n    /// Update available to the given version\n    UpdateAvailable(String),\n    /// Could not determine version status\n    Unknown,\n}\n\n/// Generate an inlay hint for a dependency\npub fn create_inlay_hint(dep: &Dependency, version_info: Option<&VersionInfo>) -> InlayHint {\n    let status = match version_info {\n        Some(info) => compare_versions(&dep.version, info),\n        None => VersionStatus::Unknown,\n    };\n\n    // Check for vulnerabilities and deprecation\n    let vuln_count = version_info\n        .map(|info| info.vulnerabilities.len())\n        .unwrap_or(0);\n\n    let is_deprecated = version_info.map(|info| info.deprecated).unwrap_or(false);\n\n    if is_deprecated {\n        tracing::debug!(\"Package {} {} is deprecated\", dep.name, dep.version);\n    }\n\n    let (label, tooltip) = create_hint_label_and_tooltip(&status, vuln_count, dep, version_info);\n\n    InlayHint {\n        position: Position {\n            line: dep.line,\n            character: dep.version_end + 1,\n        },\n        label: InlayHintLabel::String(format!(\" {}\", label)),\n        kind: Some(InlayHintKind::PARAMETER),\n        text_edits: None,\n        tooltip: tooltip.map(tower_lsp::lsp_types::InlayHintTooltip::String),\n        padding_left: Some(true),\n        padding_right: None,\n        data: None,\n    }\n}\n\n/// Create label and tooltip based on version status and vulnerabilities\nfn create_hint_label_and_tooltip(\n    status: &VersionStatus,\n    vuln_count: usize,\n    dep: &Dependency,\n    version_info: Option<&VersionInfo>,\n) -> (String, Option<String>) {\n    // Handle local dependencies first (highest priority - no registry lookup needed)\n    if is_local_dependency(&dep.version) {\n        let tooltip = format!(\n            \"**Local Dependency**\\n\\n\\\n            \\\"{}\\\" is a local/path dependency.\\n\\n\\\n            Version info is not available for local packages.\\n\\n\\\n            This is expected for dependencies using:\\n\\\n            • path = \\\"./...\\\"\\n\\\n            • git = \\\"https://...\\\"\\n\\\n            • git = \\\"git@...\\\"\\n\\\n            • github:owner/repo\",\n            dep.name\n        );\n        return (\"→ Local\".to_string(), Some(tooltip));\n    }\n\n    tracing::debug!(\n        \"Not a local dependency: {} with version '{}'\",\n        dep.name,\n        dep.version\n    );\n\n    // Handle yanked versions (highest priority - critical issue)\n    if let Some(info) = version_info\n        && info.is_version_yanked(&dep.version)\n    {\n        let yanked_label = \"⊘ Yanked\".to_string();\n        let yanked_tooltip = format_yanked_tooltip(dep, info);\n\n        return match status {\n            VersionStatus::UpdateAvailable(latest) => {\n                let label = format!(\"{} -> {}\", yanked_label, latest);\n                let tooltip = format!(\n                    \"{}\\n\\n---\\n**Update available:** {} -> {}\",\n                    yanked_tooltip, dep.version, latest\n                );\n                (label, Some(tooltip))\n            }\n            _ => (yanked_label, Some(yanked_tooltip)),\n        };\n    }\n\n    // Handle deprecation (second highest priority)\n    if let Some(info) = version_info\n        && info.deprecated\n    {\n        let dep_label = \"⚠ Deprecated\".to_string();\n        let dep_tooltip = format_deprecation_tooltip(dep, info);\n\n        // Combine with update info if available\n        return match status {\n            VersionStatus::UpdateAvailable(latest) => {\n                let label = format!(\"{} -> {}\", dep_label, latest);\n                let tooltip = format!(\n                    \"{}\\n\\n---\\n**Update available:** {} -> {}\",\n                    dep_tooltip, dep.version, latest\n                );\n                (label, Some(tooltip))\n            }\n            _ => (dep_label, Some(dep_tooltip)),\n        };\n    }\n\n    // Handle vulnerabilities\n    if vuln_count > 0 {\n        let vuln_label = format!(\n            \"⚠ {} {}\",\n            vuln_count,\n            if vuln_count == 1 { \"vuln\" } else { \"vulns\" }\n        );\n        let vuln_tooltip = format_vulnerability_tooltip(version_info.unwrap());\n\n        // Combine with update info if available\n        return match status {\n            VersionStatus::UpdateAvailable(latest) => {\n                let label = format!(\"{} -> {}\", vuln_label, latest);\n                let tooltip = format!(\n                    \"{}\\n\\n---\\n**Update available:** {} -> {}\",\n                    vuln_tooltip, dep.version, latest\n                );\n                (label, Some(tooltip))\n            }\n            _ => (vuln_label, Some(vuln_tooltip)),\n        };\n    }\n\n    // No vulnerabilities - show version status\n    match status {\n        VersionStatus::UpToDate => (\"✓\".to_string(), Some(\"Up to date\".to_string())),\n        VersionStatus::UpdateAvailable(latest) => {\n            let label = format!(\"-> {}\", latest);\n            let tooltip = format!(\"Update available: {} -> {}\", dep.version, latest);\n            (label, Some(tooltip))\n        }\n        VersionStatus::Unknown => {\n            let tooltip = format!(\n                \"**Could not fetch version info**\\n\\n\\\n                Possible causes:\\n\\\n                • Network error - check internet connection\\n\\\n                • Package not found - verify spelling\\n\\\n                • Rate limiting - wait and retry\\n\\\n                • Registry down - try again later\\n\\n\\\n                **Troubleshooting:**\\n\\\n                1. Check your network connection\\n\\\n                2. Verify the package name \\\"{}\\\" is spelled correctly\\n\\\n                3. Search for the package on the registry\\n\\\n                4. If recently published, wait a few minutes for indexing\",\n                dep.name\n            );\n            (\"? Unknown\".to_string(), Some(tooltip))\n        }\n    }\n}\n\n/// Format vulnerability details for tooltip\nfn format_vulnerability_tooltip(info: &VersionInfo) -> String {\n    let count = info.vulnerabilities.len();\n    let mut lines = vec![format!(\n        \"**⚠ {} {} Found**\\n\",\n        count,\n        if count == 1 {\n            \"Vulnerability\"\n        } else {\n            \"Vulnerabilities\"\n        }\n    )];\n\n    for (i, vuln) in info.vulnerabilities.iter().take(5).enumerate() {\n        let severity_icon = match vuln.severity {\n            VulnerabilitySeverity::Critical => \"⚠ CRITICAL\",\n            VulnerabilitySeverity::High => \"▲ HIGH\",\n            VulnerabilitySeverity::Medium => \"● MEDIUM\",\n            VulnerabilitySeverity::Low => \"○ LOW\",\n        };\n\n        lines.push(format!(\n            \"{}. **{}** ({})\\n   {}\",\n            i + 1,\n            vuln.id,\n            severity_icon,\n            truncate_string(&vuln.description, 100)\n        ));\n\n        if let Some(url) = &vuln.url {\n            lines.push(format!(\"   [View Advisory]({})\", url));\n        }\n    }\n\n    if info.vulnerabilities.len() > 5 {\n        lines.push(format!(\n            \"\\n... and {} more vulnerabilities\",\n            info.vulnerabilities.len() - 5\n        ));\n    }\n\n    lines.join(\"\\n\")\n}\n\n/// Format deprecation warning for tooltip\nfn format_deprecation_tooltip(dep: &Dependency, info: &VersionInfo) -> String {\n    let mut lines = vec![\n        format!(\n            \"**⚠ PACKAGE DEPRECATED**\\n\\nThe package \\\"{}\\\" is deprecated.\",\n            dep.name\n        ),\n        \"\".to_string(),\n        \"**Why was it deprecated?**\".to_string(),\n        \"• Superseded by a better alternative\".to_string(),\n        \"• Has unresolved critical bugs\".to_string(),\n        \"• Known security vulnerabilities\".to_string(),\n        \"• No longer maintained\".to_string(),\n        \"• Has been renamed\".to_string(),\n        \"\".to_string(),\n        \"**What should you do?**\".to_string(),\n    ];\n\n    if let Some(homepage) = &info.homepage {\n        lines.push(format!(\"• Check the package homepage: {}\", homepage));\n    }\n\n    if let Some(repo) = &info.repository {\n        lines.push(format!(\n            \"• View the repository for more information: {}\",\n            repo\n        ));\n    }\n\n    lines.push(\"• Search for an alternative package on the registry\".to_string());\n\n    if let Some(latest) = &info.latest {\n        lines.push(format!(\n            \"• Consider the latest version: {} (may not be deprecated)\",\n            latest\n        ));\n    }\n\n    lines.join(\"\\n\")\n}\n\n/// Format yanked version warning for tooltip\nfn format_yanked_tooltip(dep: &Dependency, info: &VersionInfo) -> String {\n    let mut lines = vec![\n        format!(\n            \"**⊘ YANKED VERSION**\\n\\nThe version \\\"{}\\\" of \\\"{}\\\" has been yanked from crates.io.\",\n            dep.version, dep.name\n        ),\n        \"\".to_string(),\n        \"**Why was it yanked?**\".to_string(),\n        \"A yanked version typically has:\".to_string(),\n        \"• Critical bugs that break functionality\".to_string(),\n        \"• Security vulnerabilities\".to_string(),\n        \"• Published by mistake\".to_string(),\n        \"• Corrupted or incomplete package\".to_string(),\n        \"\".to_string(),\n        \"**What should you do?**\".to_string(),\n    ];\n\n    if let Some(latest) = &info.latest {\n        lines.push(format!(\"• Update to the latest version: {}\", latest));\n    }\n\n    if let Some(repo) = &info.repository {\n        lines.push(format!(\"• Check the repository for more info: {}\", repo));\n    }\n\n    lines.push(format!(\n        \"• View on crates.io: https://crates.io/crates/{}\",\n        dep.name\n    ));\n\n    lines.join(\"\\n\")\n}\n\n/// Check if a dependency version string indicates a local/path dependency\npub fn is_local_dependency(version: &str) -> bool {\n    // Path-based dependencies\n    version.starts_with(\"./\")\n        || version.starts_with(\"../\")\n        || version.starts_with('/')\n        // File protocol (npm uses \"file:\" not \"file://\")\n        || version.starts_with(\"file:\")\n        // Git dependencies\n        || version.starts_with(\"git+\")\n        || version.starts_with(\"git@\")\n        || version.starts_with(\"git:\")\n        // URL-based (git repos)\n        || version.starts_with(\"https://\")\n        || version.starts_with(\"http://\")\n        // Platform shortcuts (npm/yarn)\n        || version.starts_with(\"github:\")\n        || version.starts_with(\"gitlab:\")\n        || version.starts_with(\"bitbucket:\")\n        // Yarn/pnpm workspace protocols\n        || version.starts_with(\"workspace:\")\n        || version.starts_with(\"link:\")\n        || version.starts_with(\"portal:\")\n        // npm aliases\n        || version.starts_with(\"npm:\")\n}\n\n/// Compare a dependency version with the latest available\npub fn compare_versions(current: &str, info: &VersionInfo) -> VersionStatus {\n    let Some(latest) = &info.latest else {\n        return VersionStatus::Unknown;\n    };\n\n    // Normalize versions for comparison\n    let current_normalized = normalize_version(current);\n    let latest_normalized = normalize_version(latest);\n\n    // Parse as semver for proper comparison\n    match (\n        semver::Version::parse(&current_normalized),\n        semver::Version::parse(&latest_normalized),\n    ) {\n        (Ok(current_ver), Ok(latest_ver)) => {\n            if current_ver >= latest_ver {\n                VersionStatus::UpToDate\n            } else {\n                VersionStatus::UpdateAvailable(latest.clone())\n            }\n        }\n        _ => {\n            // Fallback to string comparison if semver parsing fails\n            if current_normalized == latest_normalized {\n                VersionStatus::UpToDate\n            } else {\n                VersionStatus::UpdateAvailable(latest.clone())\n            }\n        }\n    }\n}\n\n/// Normalize a version string for comparison\n/// Handles version specifiers like ^, ~, >=, etc.\nfn normalize_version(version: &str) -> String {\n    let version = version.trim();\n\n    // Remove common prefixes\n    let version = version\n        .strip_prefix('^')\n        .or_else(|| version.strip_prefix('~'))\n        .or_else(|| version.strip_prefix(\">=\"))\n        .or_else(|| version.strip_prefix(\"<=\"))\n        .or_else(|| version.strip_prefix('>'))\n        .or_else(|| version.strip_prefix('<'))\n        .or_else(|| version.strip_prefix('='))\n        .unwrap_or(version);\n\n    // Handle version ranges like \">=1.0, <2.0\" - take the first part\n    let version = version.split(',').next().unwrap_or(version).trim();\n\n    // Ensure we have at least major.minor.patch\n    let parts: Vec<&str> = version.split('.').collect();\n    match parts.len() {\n        1 => format!(\"{}.0.0\", parts[0]),\n        2 => format!(\"{}.{}.0\", parts[0], parts[1]),\n        _ => version.to_string(),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::registries::Vulnerability;\n\n    fn make_version_info(latest: &str) -> VersionInfo {\n        VersionInfo {\n            latest: Some(latest.to_string()),\n            ..Default::default()\n        }\n    }\n\n    fn make_test_dep(name: &str, version: &str) -> Dependency {\n        Dependency {\n            name: name.to_string(),\n            version: version.to_string(),\n            line: 5,\n            name_start: 0,\n            name_end: name.len() as u32,\n            version_start: name.len() as u32 + 4,\n            version_end: name.len() as u32 + 4 + version.len() as u32,\n            dev: false,\n            optional: false,\n        }\n    }\n\n    #[test]\n    fn test_compare_versions_up_to_date() {\n        let info = make_version_info(\"1.0.0\");\n        assert!(matches!(\n            compare_versions(\"1.0.0\", &info),\n            VersionStatus::UpToDate\n        ));\n    }\n\n    #[test]\n    fn test_compare_versions_update_available() {\n        let info = make_version_info(\"2.0.0\");\n        match compare_versions(\"1.0.0\", &info) {\n            VersionStatus::UpdateAvailable(v) => assert_eq!(v, \"2.0.0\"),\n            _ => panic!(\"Expected UpdateAvailable\"),\n        }\n    }\n\n    #[test]\n    fn test_compare_versions_with_caret() {\n        let info = make_version_info(\"1.5.0\");\n        match compare_versions(\"^1.0\", &info) {\n            VersionStatus::UpdateAvailable(v) => assert_eq!(v, \"1.5.0\"),\n            _ => panic!(\"Expected UpdateAvailable\"),\n        }\n    }\n\n    #[test]\n    fn test_compare_versions_with_tilde() {\n        let info = make_version_info(\"1.0.5\");\n        match compare_versions(\"~1.0.0\", &info) {\n            VersionStatus::UpdateAvailable(v) => assert_eq!(v, \"1.0.5\"),\n            _ => panic!(\"Expected UpdateAvailable\"),\n        }\n    }\n\n    #[test]\n    fn test_normalize_version() {\n        assert_eq!(normalize_version(\"1.0.0\"), \"1.0.0\");\n        assert_eq!(normalize_version(\"^1.0\"), \"1.0.0\");\n        assert_eq!(normalize_version(\"~1.0.0\"), \"1.0.0\");\n        assert_eq!(normalize_version(\">=1.0, <2.0\"), \"1.0.0\");\n        assert_eq!(normalize_version(\"1\"), \"1.0.0\");\n        assert_eq!(normalize_version(\"1.2\"), \"1.2.0\");\n    }\n\n    #[test]\n    fn test_create_inlay_hint_up_to_date() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = make_version_info(\"1.0.0\");\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        assert_eq!(hint.position.line, 5);\n        match hint.label {\n            InlayHintLabel::String(s) => assert!(s.contains(\"✓\")),\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_create_inlay_hint_update_available() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = make_version_info(\"2.0.0\");\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"->\"));\n                assert!(s.contains(\"2.0.0\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_deprecated_inlay_hint() {\n        let dep = make_test_dep(\"old-dep\", \"1.0.0\");\n        let info = VersionInfo {\n            deprecated: true,\n            latest: Some(\"2.0.0\".to_string()),\n            description: Some(\"Superseded by new-package\".to_string()),\n            homepage: Some(\"https://example.com\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"Deprecated\"));\n                assert!(s.contains(\"⚠\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_deprecated_with_update() {\n        let dep = make_test_dep(\"old-dep\", \"1.0.0\");\n        let info = VersionInfo {\n            deprecated: true,\n            latest: Some(\"2.0.0\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"Deprecated\"));\n                assert!(s.contains(\"2.0.0\"));\n                assert!(s.contains(\"->\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_no_deprecated_warning() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = VersionInfo {\n            deprecated: false,\n            latest: Some(\"1.0.0\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(!s.contains(\"Deprecated\"));\n                assert!(!s.contains(\"⚠\"));\n                assert!(s.contains(\"✓\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_vulnerability_label_singular() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = VersionInfo {\n            latest: Some(\"1.0.0\".to_string()),\n            vulnerabilities: vec![Vulnerability {\n                id: \"CVE-2024-1234\".to_string(),\n                severity: VulnerabilitySeverity::High,\n                description: \"Test vulnerability\".to_string(),\n                url: None,\n            }],\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(\n                    s.contains(\"⚠ 1 vuln\"),\n                    \"Expected '⚠ 1 vuln' in label, got: {}\",\n                    s\n                );\n                assert!(\n                    !s.contains(\"vulns\"),\n                    \"Should use singular 'vuln', got: {}\",\n                    s\n                );\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_vulnerability_label_plural() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = VersionInfo {\n            latest: Some(\"1.0.0\".to_string()),\n            vulnerabilities: vec![\n                Vulnerability {\n                    id: \"CVE-2024-1234\".to_string(),\n                    severity: VulnerabilitySeverity::High,\n                    description: \"Test vulnerability 1\".to_string(),\n                    url: None,\n                },\n                Vulnerability {\n                    id: \"CVE-2024-5678\".to_string(),\n                    severity: VulnerabilitySeverity::Medium,\n                    description: \"Test vulnerability 2\".to_string(),\n                    url: None,\n                },\n            ],\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(\n                    s.contains(\"⚠ 2 vulns\"),\n                    \"Expected '⚠ 2 vulns' in label, got: {}\",\n                    s\n                );\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_vulnerability_with_update_label() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = VersionInfo {\n            latest: Some(\"2.0.0\".to_string()),\n            vulnerabilities: vec![\n                Vulnerability {\n                    id: \"CVE-2024-1234\".to_string(),\n                    severity: VulnerabilitySeverity::High,\n                    description: \"Test vulnerability 1\".to_string(),\n                    url: None,\n                },\n                Vulnerability {\n                    id: \"CVE-2024-5678\".to_string(),\n                    severity: VulnerabilitySeverity::Medium,\n                    description: \"Test vulnerability 2\".to_string(),\n                    url: None,\n                },\n            ],\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(\n                    s.contains(\"⚠ 2 vulns\"),\n                    \"Expected '⚠ 2 vulns' in label, got: {}\",\n                    s\n                );\n                assert!(\n                    s.contains(\"-> 2.0.0\"),\n                    \"Expected '-> 2.0.0' in label, got: {}\",\n                    s\n                );\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_deprecated_priority_over_vulnerabilities() {\n        let dep = make_test_dep(\"dep\", \"1.0.0\");\n        let info = VersionInfo {\n            deprecated: true,\n            latest: None,\n            vulnerabilities: vec![Vulnerability {\n                id: \"CVE-2024-1234\".to_string(),\n                severity: VulnerabilitySeverity::High,\n                description: \"Test vulnerability\".to_string(),\n                url: None,\n            }],\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"Deprecated\"));\n                assert!(!s.contains(\"vuln\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_yanked_inlay_hint() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = VersionInfo {\n            yanked_versions: vec![\"1.0.0\".to_string()],\n            latest: Some(\"2.0.0\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"Yanked\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_yanked_with_update() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = VersionInfo {\n            yanked_versions: vec![\"1.0.0\".to_string()],\n            latest: Some(\"2.0.0\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"Yanked\"));\n                assert!(s.contains(\"2.0.0\"));\n                assert!(s.contains(\"->\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_no_yanked_warning() {\n        let dep = make_test_dep(\"serde\", \"1.0.0\");\n        let info = VersionInfo {\n            yanked_versions: vec![\"0.9.0\".to_string()],\n            latest: Some(\"1.0.0\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(!s.contains(\"Yanked\"));\n                assert!(s.contains(\"✓\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_yanked_priority_over_deprecated() {\n        let dep = make_test_dep(\"dep\", \"1.0.0\");\n        let info = VersionInfo {\n            yanked_versions: vec![\"1.0.0\".to_string()],\n            deprecated: true,\n            latest: Some(\"2.0.0\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"Yanked\"));\n                assert!(!s.contains(\"Deprecated\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_yanked_priority_over_vulnerabilities() {\n        let dep = make_test_dep(\"dep\", \"1.0.0\");\n        let info = VersionInfo {\n            yanked_versions: vec![\"1.0.0\".to_string()],\n            vulnerabilities: vec![Vulnerability {\n                id: \"CVE-2024-1234\".to_string(),\n                severity: VulnerabilitySeverity::High,\n                description: \"Test vulnerability\".to_string(),\n                url: None,\n            }],\n            latest: Some(\"2.0.0\".to_string()),\n            ..Default::default()\n        };\n        let hint = create_inlay_hint(&dep, Some(&info));\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"Yanked\"));\n                assert!(!s.contains(\"⚠\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n\n    #[test]\n    fn test_is_local_dependency() {\n        // Path-based\n        assert!(is_local_dependency(\"./my-lib\"));\n        assert!(is_local_dependency(\"../other-lib\"));\n        assert!(is_local_dependency(\"/absolute/path\"));\n\n        // File protocol (npm style)\n        assert!(is_local_dependency(\"file:./my-local-lib\"));\n        assert!(is_local_dependency(\"file:../shared\"));\n        assert!(is_local_dependency(\"file:///absolute/path\"));\n\n        // Git dependencies\n        assert!(is_local_dependency(\"git+https://github.com/user/repo\"));\n        assert!(is_local_dependency(\"git@github.com:user/repo.git\"));\n        assert!(is_local_dependency(\"git://github.com/user/repo.git\"));\n\n        // URL-based\n        assert!(is_local_dependency(\"https://github.com/user/repo\"));\n        assert!(is_local_dependency(\"http://example.com/repo.tgz\"));\n\n        // Platform shortcuts\n        assert!(is_local_dependency(\"github:user/repo\"));\n        assert!(is_local_dependency(\"gitlab:user/repo\"));\n        assert!(is_local_dependency(\"bitbucket:user/repo\"));\n\n        // Workspace protocols\n        assert!(is_local_dependency(\"workspace:*\"));\n        assert!(is_local_dependency(\"link:./my-lib\"));\n        assert!(is_local_dependency(\"portal:./my-lib\"));\n        assert!(is_local_dependency(\"npm:lodash@^4.0.0\"));\n\n        // Not local - regular versions\n        assert!(!is_local_dependency(\"1.0.0\"));\n        assert!(!is_local_dependency(\"^1.0\"));\n        assert!(!is_local_dependency(\"~1.0.0\"));\n        assert!(!is_local_dependency(\">=1.0, <2.0\"));\n        assert!(!is_local_dependency(\"*\"));\n        assert!(!is_local_dependency(\"latest\"));\n    }\n\n    #[test]\n    fn test_npm_local_deps_detection() {\n        use crate::parsers::{Parser, npm::NpmParser};\n\n        let content = r#\"{\n  \"dependencies\": {\n    \"express\": \"^4.17.0\",\n    \"my-local-lib\": \"file:./my-local-lib\",\n    \"shared-utils\": \"../shared-utils\",\n    \"git-package\": \"git+https://github.com/user/repo.git\",\n    \"github-dep\": \"github:owner/project\"\n  }\n}\"#;\n\n        let parser = NpmParser::new();\n        let deps = parser.parse(content);\n\n        assert_eq!(deps.len(), 5);\n\n        for dep in &deps {\n            println!(\"Dep: {} @ '{}'\", dep.name, dep.version);\n            let is_local = is_local_dependency(&dep.version);\n            println!(\"  -> is_local: {}\", is_local);\n        }\n\n        let my_local = deps.iter().find(|d| d.name == \"my-local-lib\").unwrap();\n        assert!(\n            is_local_dependency(&my_local.version),\n            \"file:./my-local-lib should be local, got version: '{}'\",\n            my_local.version\n        );\n\n        let shared = deps.iter().find(|d| d.name == \"shared-utils\").unwrap();\n        assert!(\n            is_local_dependency(&shared.version),\n            \"../shared-utils should be local, got version: '{}'\",\n            shared.version\n        );\n\n        let git_pkg = deps.iter().find(|d| d.name == \"git-package\").unwrap();\n        assert!(\n            is_local_dependency(&git_pkg.version),\n            \"git+https://... should be local, got version: '{}'\",\n            git_pkg.version\n        );\n\n        let github = deps.iter().find(|d| d.name == \"github-dep\").unwrap();\n        assert!(\n            is_local_dependency(&github.version),\n            \"github:... should be local, got version: '{}'\",\n            github.version\n        );\n\n        let express = deps.iter().find(|d| d.name == \"express\").unwrap();\n        assert!(\n            !is_local_dependency(&express.version),\n            \"^4.17.0 should NOT be local\"\n        );\n    }\n\n    #[test]\n    fn test_unknown_status_local_dependency() {\n        let dep = make_test_dep(\"my-local-lib\", \"./my-local-lib\");\n        let hint = create_inlay_hint(&dep, None);\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(\n                    s.contains(\"→\") || s.contains(\"Local\"),\n                    \"Expected → Local in label, got: {}\",\n                    s\n                );\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n\n        if let Some(tower_lsp::lsp_types::InlayHintTooltip::String(tooltip)) = hint.tooltip {\n            assert!(tooltip.contains(\"Local Dependency\"));\n            assert!(tooltip.contains(\"my-local-lib\"));\n        } else {\n            panic!(\"Expected string tooltip\");\n        }\n    }\n\n    #[test]\n    fn test_unknown_status_network_error() {\n        let dep = make_test_dep(\"unknown-package\", \"1.0.0\");\n        let hint = create_inlay_hint(&dep, None);\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(s.contains(\"?\"), \"Expected ? in label, got: {}\", s);\n                assert!(!s.contains(\"Local\"));\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n\n        if let Some(tower_lsp::lsp_types::InlayHintTooltip::String(tooltip)) = hint.tooltip {\n            assert!(tooltip.contains(\"Could not fetch version info\"));\n            assert!(tooltip.contains(\"unknown-package\"));\n            assert!(tooltip.contains(\"Troubleshooting\"));\n        } else {\n            panic!(\"Expected string tooltip\");\n        }\n    }\n\n    #[test]\n    fn test_unknown_status_git_dependency() {\n        let dep = make_test_dep(\"git-dep\", \"git@github.com:user/repo.git\");\n        let hint = create_inlay_hint(&dep, None);\n\n        match hint.label {\n            InlayHintLabel::String(s) => {\n                assert!(\n                    s.contains(\"→\") || s.contains(\"Local\"),\n                    \"Expected → Local in label, got: {}\",\n                    s\n                );\n            }\n            _ => panic!(\"Expected string label\"),\n        }\n    }\n}\n","traces":[{"line":21,"address":[20390992,20392626,20392695],"length":1,"stats":{"Line":3}},{"line":22,"address":[20391033],"length":1,"stats":{"Line":3}},{"line":23,"address":[14146933],"length":1,"stats":{"Line":4}},{"line":24,"address":[13083722],"length":1,"stats":{"Line":5}},{"line":28,"address":[14147005,14147113],"length":1,"stats":{"Line":11}},{"line":29,"address":[14165301],"length":1,"stats":{"Line":16}},{"line":32,"address":[13530917,13530912],"length":1,"stats":{"Line":16}},{"line":34,"address":[14165472],"length":1,"stats":{"Line":6}},{"line":35,"address":[14147232],"length":1,"stats":{"Line":2}},{"line":38,"address":[13083921,13084514],"length":1,"stats":{"Line":7}},{"line":45,"address":[14147926,14148014],"length":1,"stats":{"Line":6}},{"line":48,"address":[13084899],"length":1,"stats":{"Line":5}},{"line":56,"address":[14159240,14157088,14159327],"length":1,"stats":{"Line":5}},{"line":63,"address":[14157170],"length":1,"stats":{"Line":5}},{"line":64,"address":[20401330],"length":1,"stats":{"Line":4}},{"line":75,"address":[14163505,14157418],"length":1,"stats":{"Line":8}},{"line":78,"address":[14175531,14175740,14175929],"length":1,"stats":{"Line":11}},{"line":85,"address":[13094240,13094625],"length":1,"stats":{"Line":11}},{"line":86,"address":[14158007],"length":1,"stats":{"Line":6}},{"line":88,"address":[13094712],"length":1,"stats":{"Line":4}},{"line":89,"address":[13094770,13094826],"length":1,"stats":{"Line":9}},{"line":91,"address":[14176484],"length":1,"stats":{"Line":7}},{"line":92,"address":[14158251],"length":1,"stats":{"Line":5}},{"line":93,"address":[13094905,13095239],"length":1,"stats":{"Line":12}},{"line":94,"address":[13095390,13095505],"length":1,"stats":{"Line":12}},{"line":98,"address":[13095699],"length":1,"stats":{"Line":7}},{"line":100,"address":[13094959],"length":1,"stats":{"Line":0}},{"line":105,"address":[14176322,14177647],"length":1,"stats":{"Line":11}},{"line":106,"address":[14177668],"length":1,"stats":{"Line":5}},{"line":108,"address":[13096047],"length":1,"stats":{"Line":2}},{"line":109,"address":[14177755,14177811],"length":1,"stats":{"Line":6}},{"line":112,"address":[20403577],"length":1,"stats":{"Line":5}},{"line":113,"address":[13096224],"length":1,"stats":{"Line":3}},{"line":114,"address":[13096240,13096574],"length":1,"stats":{"Line":5}},{"line":115,"address":[20404133,20404248],"length":1,"stats":{"Line":7}},{"line":119,"address":[20404442],"length":1,"stats":{"Line":3}},{"line":121,"address":[14159656],"length":1,"stats":{"Line":2}},{"line":126,"address":[13096027],"length":1,"stats":{"Line":4}},{"line":127,"address":[20406069],"length":1,"stats":{"Line":2}},{"line":130,"address":[14161959,14160732],"length":1,"stats":{"Line":5}},{"line":132,"address":[14180501,14180586],"length":1,"stats":{"Line":9}},{"line":135,"address":[14180609],"length":1,"stats":{"Line":6}},{"line":136,"address":[14180664],"length":1,"stats":{"Line":2}},{"line":137,"address":[20406434,20406768],"length":1,"stats":{"Line":4}},{"line":138,"address":[13099511,13099626],"length":1,"stats":{"Line":4}},{"line":142,"address":[14163186],"length":1,"stats":{"Line":2}},{"line":144,"address":[14162446],"length":1,"stats":{"Line":4}},{"line":149,"address":[14160752,14160671],"length":1,"stats":{"Line":4}},{"line":150,"address":[14179480,14179042],"length":1,"stats":{"Line":3}},{"line":151,"address":[13097466],"length":1,"stats":{"Line":3}},{"line":152,"address":[14179137],"length":1,"stats":{"Line":3}},{"line":153,"address":[14179700,14179273],"length":1,"stats":{"Line":6}},{"line":154,"address":[14161563],"length":1,"stats":{"Line":3}},{"line":157,"address":[13097673],"length":1,"stats":{"Line":3}},{"line":171,"address":[20405204,20405833],"length":1,"stats":{"Line":6}},{"line":177,"address":[13093693,13091488,13093699],"length":1,"stats":{"Line":6}},{"line":178,"address":[20398946],"length":1,"stats":{"Line":6}},{"line":179,"address":[14173270,14173677,14173172,14175373],"length":1,"stats":{"Line":10}},{"line":182,"address":[20398986,20399024],"length":1,"stats":{"Line":8}},{"line":183,"address":[13091589],"length":1,"stats":{"Line":2}},{"line":185,"address":[20399026],"length":1,"stats":{"Line":4}},{"line":189,"address":[14173646,14173750],"length":1,"stats":{"Line":12}},{"line":190,"address":[14155769],"length":1,"stats":{"Line":6}},{"line":191,"address":[14156282],"length":1,"stats":{"Line":0}},{"line":192,"address":[14174541],"length":1,"stats":{"Line":6}},{"line":193,"address":[14174512],"length":1,"stats":{"Line":4}},{"line":194,"address":[14174483],"length":1,"stats":{"Line":0}},{"line":197,"address":[14156438],"length":1,"stats":{"Line":6}},{"line":199,"address":[20400361,20400417],"length":1,"stats":{"Line":6}},{"line":202,"address":[14174637,14174689],"length":1,"stats":{"Line":12}},{"line":205,"address":[20400880],"length":1,"stats":{"Line":6}},{"line":206,"address":[13093534],"length":1,"stats":{"Line":0}},{"line":210,"address":[13092446],"length":1,"stats":{"Line":2}},{"line":211,"address":[14155989,14155942],"length":1,"stats":{"Line":0}},{"line":213,"address":[14155878,14155969],"length":1,"stats":{"Line":0}},{"line":217,"address":[14155838,14156139],"length":1,"stats":{"Line":12}},{"line":221,"address":[14170800,14173068,14173074],"length":1,"stats":{"Line":3}},{"line":222,"address":[14171349,14170853,14172221,14170895,14171205,14171421,14171562,14171675,14173087,14171133,14171061,14171493,14171634,14171277],"length":1,"stats":{"Line":8}},{"line":223,"address":[13089332,13089268],"length":1,"stats":{"Line":8}},{"line":227,"address":[14171033],"length":1,"stats":{"Line":4}},{"line":228,"address":[14152814],"length":1,"stats":{"Line":5}},{"line":229,"address":[13089570],"length":1,"stats":{"Line":4}},{"line":230,"address":[13089642],"length":1,"stats":{"Line":5}},{"line":231,"address":[14171318],"length":1,"stats":{"Line":4}},{"line":232,"address":[20397194],"length":1,"stats":{"Line":5}},{"line":233,"address":[14171462],"length":1,"stats":{"Line":4}},{"line":234,"address":[14171534],"length":1,"stats":{"Line":5}},{"line":235,"address":[14171603],"length":1,"stats":{"Line":4}},{"line":238,"address":[13090564,13090634],"length":1,"stats":{"Line":6}},{"line":239,"address":[14153967,14154099],"length":1,"stats":{"Line":4}},{"line":242,"address":[14154233,14153999],"length":1,"stats":{"Line":3}},{"line":243,"address":[14172598,14172537],"length":1,"stats":{"Line":0}},{"line":249,"address":[14154276,14154439],"length":1,"stats":{"Line":6}},{"line":251,"address":[13091151],"length":1,"stats":{"Line":4}},{"line":252,"address":[14154534,14154589],"length":1,"stats":{"Line":6}},{"line":258,"address":[20398824,20398653],"length":1,"stats":{"Line":4}},{"line":262,"address":[14150288,14152488,14152482],"length":1,"stats":{"Line":3}},{"line":263,"address":[20396593,20395131,20394771,20394699,20395059,20394915,20395272,20394437,20394502,20394843,20394987,20395200,20395313,20395854],"length":1,"stats":{"Line":9}},{"line":264,"address":[13087131,13087047],"length":1,"stats":{"Line":7}},{"line":268,"address":[14168867],"length":1,"stats":{"Line":3}},{"line":269,"address":[14168936],"length":1,"stats":{"Line":5}},{"line":270,"address":[14169008],"length":1,"stats":{"Line":3}},{"line":271,"address":[14169080],"length":1,"stats":{"Line":5}},{"line":272,"address":[20394956],"length":1,"stats":{"Line":3}},{"line":273,"address":[20395028],"length":1,"stats":{"Line":5}},{"line":274,"address":[14151008],"length":1,"stats":{"Line":3}},{"line":275,"address":[20395172],"length":1,"stats":{"Line":5}},{"line":276,"address":[14169437],"length":1,"stats":{"Line":3}},{"line":279,"address":[14151780,14151715],"length":1,"stats":{"Line":10}},{"line":280,"address":[14151796,14151928],"length":1,"stats":{"Line":10}},{"line":283,"address":[20396154,20395920],"length":1,"stats":{"Line":5}},{"line":284,"address":[13088823,13088761],"length":1,"stats":{"Line":0}},{"line":287,"address":[14170398,14170557],"length":1,"stats":{"Line":12}},{"line":292,"address":[20396485],"length":1,"stats":{"Line":7}},{"line":296,"address":[20393808],"length":1,"stats":{"Line":3}},{"line":298,"address":[14168078,14168023],"length":1,"stats":{"Line":6}},{"line":299,"address":[14149766],"length":1,"stats":{"Line":5}},{"line":300,"address":[13086497],"length":1,"stats":{"Line":5}},{"line":302,"address":[14168121],"length":1,"stats":{"Line":5}},{"line":304,"address":[13086552],"length":1,"stats":{"Line":5}},{"line":305,"address":[14168183],"length":1,"stats":{"Line":6}},{"line":306,"address":[20394022],"length":1,"stats":{"Line":6}},{"line":308,"address":[13086649],"length":1,"stats":{"Line":6}},{"line":309,"address":[14149996],"length":1,"stats":{"Line":6}},{"line":311,"address":[20394127],"length":1,"stats":{"Line":6}},{"line":312,"address":[13086754],"length":1,"stats":{"Line":6}},{"line":313,"address":[14150101],"length":1,"stats":{"Line":6}},{"line":315,"address":[13086824],"length":1,"stats":{"Line":6}},{"line":316,"address":[13086859],"length":1,"stats":{"Line":6}},{"line":317,"address":[20394302],"length":1,"stats":{"Line":5}},{"line":319,"address":[13086929],"length":1,"stats":{"Line":6}},{"line":323,"address":[14164673,14165122,14163600],"length":1,"stats":{"Line":7}},{"line":324,"address":[14145376],"length":1,"stats":{"Line":3}},{"line":325,"address":[14145497],"length":1,"stats":{"Line":2}},{"line":329,"address":[14163753],"length":1,"stats":{"Line":7}},{"line":330,"address":[14163862,14163763],"length":1,"stats":{"Line":22}},{"line":333,"address":[14164186,14164056],"length":1,"stats":{"Line":19}},{"line":334,"address":[14163874,14163942],"length":1,"stats":{"Line":20}},{"line":335,"address":[14163969,14164037],"length":1,"stats":{"Line":25}},{"line":337,"address":[14145929],"length":1,"stats":{"Line":14}},{"line":338,"address":[13082773,13082852,13082900],"length":1,"stats":{"Line":23}},{"line":339,"address":[14146155],"length":1,"stats":{"Line":4}},{"line":341,"address":[14146175,14146131],"length":1,"stats":{"Line":20}},{"line":346,"address":[13083175,13083217,13083127,13082616],"length":1,"stats":{"Line":0}},{"line":347,"address":[13083162],"length":1,"stats":{"Line":0}},{"line":349,"address":[14164738,14164694],"length":1,"stats":{"Line":0}},{"line":357,"address":[13085312,13086386,13086380],"length":1,"stats":{"Line":3}},{"line":358,"address":[14148651],"length":1,"stats":{"Line":7}},{"line":363,"address":[12949424,12949438],"length":1,"stats":{"Line":13}},{"line":364,"address":[15959392,15959406],"length":1,"stats":{"Line":17}},{"line":365,"address":[15959454,15959440],"length":1,"stats":{"Line":13}},{"line":366,"address":[14148793],"length":1,"stats":{"Line":18}},{"line":367,"address":[14148818],"length":1,"stats":{"Line":22}},{"line":368,"address":[14148843],"length":1,"stats":{"Line":33}},{"line":369,"address":[14148868],"length":1,"stats":{"Line":9}},{"line":372,"address":[14148911],"length":1,"stats":{"Line":12}},{"line":375,"address":[13085751],"length":1,"stats":{"Line":9}},{"line":376,"address":[13085865,13085794],"length":1,"stats":{"Line":21}},{"line":377,"address":[14149225,14149303],"length":1,"stats":{"Line":4}},{"line":378,"address":[14149260,14149456],"length":1,"stats":{"Line":4}},{"line":379,"address":[14149211,14149679],"length":1,"stats":{"Line":22}}],"covered":150,"coverable":161},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","providers","mod.rs"],"content":"//! LSP feature providers (inlay hints, diagnostics, hover, etc.)\n\npub mod code_actions;\npub mod completion;\npub mod diagnostics;\npub mod inlay_hints;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","crates_io.rs"],"content":"//! # crates.io Registry Client\n//!\n//! This module implements a client for the [crates.io](https://crates.io) registry,\n//! the official Rust package registry managed by the Rust Foundation.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://crates.io/api/v1`\n//! - **API Version**: v1 (stable)\n//!\n//! ## Rate Limiting\n//!\n//! The crates.io API enforces **strict rate limits** to protect the service.\n//! This client implements a built-in rate limiter that enforces **1 request per second**.\n//!\n//! **Exceeding the rate limit may result in IP-based blocking.**\n//!\n//! ## API Endpoints Used\n//!\n//! ### Fetch Crate Info\n//!\n//! - **Endpoint**: `GET /api/v1/crates/{crate_name}`\n//! - **Response**: JSON containing crate metadata and all versions\n//! - **Fields**:\n//!   - `crate.max_stable_version`: Latest stable release\n//!   - `crate.description`: Package description\n//!   - `crate.homepage`: Optional homepage URL\n//!   - `crate.repository`: Optional repository URL\n//!   - `versions[]`: Array of all published versions\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: Semver with optional pre-release tags (`-alpha`, `-beta`, `-rc`)\n//! - **Date format**: RFC 3339 (`2024-01-15T10:30:00Z`)\n//! - **Yanked versions**: Marked with `yanked: true` in versions array\n//! - **License**: Per-version field (SPDX expression)\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **Name normalization**: Underscores and hyphens are equivalent (`foo-bar` = `foo_bar`)\n//! - **Case sensitivity**: Names are case-insensitive but stored lowercase\n//! - **404 responses**: Returned for both \"not found\" and \"private crates\"\n//! - **Yanked versions**: Still available but marked; users are warned\n//! - **Features**: `features` field lists Cargo feature flags (not exposed by this client)\n//!\n//! ## Error Handling\n//!\n//! - **Rate limiting**: Client-side enforcement (1 req/s)\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: Non-success status codes return an error\n//!\n//! ## External References\n//!\n//! - [crates.io Data Access](https://crates.io/data-access)\n//! - [crates.io Policies](https://crates.io/policies)\n//! - [Crate Metadata Schema](https://doc.rust-lang.org/cargo/reference/registry-index.html)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\nuse tokio::sync::Mutex;\n\nuse super::http_client::create_shared_client;\nuse super::version_utils::is_prerelease_rust;\nuse super::{Registry, VersionInfo};\n\n/// Rate limiter to respect crates.io's 1 request/second limit\nstruct RateLimiter {\n    last_request: Instant,\n    min_interval: Duration,\n}\n\nimpl RateLimiter {\n    fn new(requests_per_second: f64) -> Self {\n        Self {\n            last_request: Instant::now() - Duration::from_secs(10),\n            min_interval: Duration::from_secs_f64(1.0 / requests_per_second),\n        }\n    }\n\n    async fn wait(&mut self) {\n        let elapsed = self.last_request.elapsed();\n        if elapsed < self.min_interval {\n            tokio::time::sleep(self.min_interval - elapsed).await;\n        }\n        self.last_request = Instant::now();\n    }\n}\n\n/// Client for the crates.io registry\npub struct CratesIoRegistry {\n    client: Arc<Client>,\n    rate_limiter: Arc<Mutex<RateLimiter>>,\n    base_url: String,\n}\n\nimpl CratesIoRegistry {\n    /// Creates a CratesIoRegistry that uses the provided shared HTTP client.\n    ///\n    /// The registry will use the given `client` for all HTTP requests, enforce a\n    /// default rate limit of 1 request per second, and target the crates.io API\n    /// base URL.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::crates_io::CratesIoRegistry;\n    /// use dependi_lsp::registries::http_client::create_shared_client;\n    ///\n    /// let client = create_shared_client().expect(\"failed to create client\");\n    /// let registry = CratesIoRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            rate_limiter: Arc::new(Mutex::new(RateLimiter::new(1.0))),\n            base_url: \"https://crates.io/api/v1\".to_string(),\n        }\n    }\n}\n\nimpl Default for CratesIoRegistry {\n    /// Creates a `CratesIoRegistry` configured with a shared HTTP client and default rate limiting.\n    ///\n    /// The registry is initialized with a shared `reqwest::Client`, a 1 request/second rate limiter,\n    /// and the default crates.io API base URL.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if creating the shared HTTP client fails.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::crates_io::CratesIoRegistry;\n    ///\n    /// let _registry = CratesIoRegistry::default();\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n// API response structures\n#[derive(Debug, Deserialize)]\nstruct CrateResponse {\n    #[serde(rename = \"crate\")]\n    crate_info: CrateInfo,\n    versions: Vec<VersionEntry>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CrateInfo {\n    description: Option<String>,\n    homepage: Option<String>,\n    repository: Option<String>,\n    max_stable_version: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VersionEntry {\n    num: String,\n    yanked: bool,\n    license: Option<String>,\n    created_at: Option<String>,\n}\n\nimpl Registry for CratesIoRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo> {\n        // Rate limiting\n        {\n            let mut limiter = self.rate_limiter.lock().await;\n            limiter.wait().await;\n        }\n\n        let url = format!(\"{}/crates/{}\", self.base_url, package_name);\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch crate info for {}: {}\",\n                package_name,\n                response.status()\n            );\n        }\n\n        let crate_response: CrateResponse = response.json().await?;\n\n        // Find latest stable version (not yanked, no prerelease)\n        let latest_stable = crate_response\n            .crate_info\n            .max_stable_version\n            .clone()\n            .or_else(|| {\n                crate_response\n                    .versions\n                    .iter()\n                    .find(|v| !v.yanked && !is_prerelease_rust(&v.num))\n                    .map(|v| v.num.clone())\n            });\n\n        // Find latest prerelease\n        let latest_prerelease = crate_response\n            .versions\n            .iter()\n            .find(|v| !v.yanked && is_prerelease_rust(&v.num))\n            .map(|v| v.num.clone());\n\n        // Get all versions (not yanked)\n        let versions: Vec<String> = crate_response\n            .versions\n            .iter()\n            .filter(|v| !v.yanked)\n            .map(|v| v.num.clone())\n            .collect();\n\n        // Get license from latest version\n        let license = crate_response\n            .versions\n            .first()\n            .and_then(|v| v.license.clone());\n\n        // Collect all yanked versions\n        let yanked_versions: Vec<String> = crate_response\n            .versions\n            .iter()\n            .filter(|v| v.yanked)\n            .map(|v| v.num.clone())\n            .collect();\n\n        // Collect release dates for all versions\n        let release_dates: HashMap<String, DateTime<Utc>> = crate_response\n            .versions\n            .iter()\n            .filter_map(|v| {\n                v.created_at.as_ref().and_then(|date_str| {\n                    DateTime::parse_from_rfc3339(date_str)\n                        .ok()\n                        .map(|dt| (v.num.clone(), dt.with_timezone(&Utc)))\n                })\n            })\n            .collect();\n\n        // Check if latest version is yanked (kept for backwards compatibility)\n        let yanked = crate_response.versions.first().is_some_and(|v| v.yanked);\n\n        Ok(VersionInfo {\n            latest: latest_stable,\n            latest_prerelease,\n            versions,\n            description: crate_response.crate_info.description,\n            homepage: crate_response.crate_info.homepage,\n            repository: crate_response.crate_info.repository,\n            license,\n            vulnerabilities: vec![], // Filled by OSV\n            deprecated: false,       // Filled by OSV\n            yanked,\n            yanked_versions,\n            release_dates,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_prerelease() {\n        assert!(is_prerelease_rust(\"1.0.0-alpha\"));\n        assert!(is_prerelease_rust(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_rust(\"1.0.0-rc1\"));\n        assert!(!is_prerelease_rust(\"1.0.0\"));\n        assert!(!is_prerelease_rust(\"2.3.4\"));\n    }\n}\n","traces":[{"line":78,"address":[14044144],"length":1,"stats":{"Line":3}},{"line":80,"address":[14062458],"length":1,"stats":{"Line":3}},{"line":81,"address":[14062523],"length":1,"stats":{"Line":3}},{"line":85,"address":[15034792,15034784],"length":1,"stats":{"Line":0}},{"line":86,"address":[14024552,14024688],"length":1,"stats":{"Line":0}},{"line":87,"address":[13344758],"length":1,"stats":{"Line":0}},{"line":88,"address":[19725044,19725194,19725363],"length":1,"stats":{"Line":0}},{"line":90,"address":[13345161,13344798],"length":1,"stats":{"Line":0}},{"line":118,"address":[15035093,15035099,15034816],"length":1,"stats":{"Line":3}},{"line":121,"address":[15034859,15034903],"length":1,"stats":{"Line":6}},{"line":122,"address":[15034954],"length":1,"stats":{"Line":3}},{"line":144,"address":[14064000],"length":1,"stats":{"Line":2}},{"line":145,"address":[14064014],"length":1,"stats":{"Line":2}},{"line":174,"address":[14044064],"length":1,"stats":{"Line":2}},{"line":175,"address":[14044069],"length":1,"stats":{"Line":2}},{"line":178,"address":[19718196,19717936,19717998,19718153,19718409,19718217,19718819,19718238,19718267],"length":1,"stats":{"Line":0}},{"line":181,"address":[12494415],"length":1,"stats":{"Line":0}},{"line":182,"address":[12494430],"length":1,"stats":{"Line":0}},{"line":185,"address":[13338662],"length":1,"stats":{"Line":0}},{"line":187,"address":[19719475,19718225,19719315,19719224,19720521],"length":1,"stats":{"Line":0}},{"line":189,"address":[14019352,14019284],"length":1,"stats":{"Line":0}},{"line":190,"address":[14019522],"length":1,"stats":{"Line":0}},{"line":197,"address":[12752235],"length":1,"stats":{"Line":0}},{"line":204,"address":[14039048,14042112],"length":1,"stats":{"Line":0}},{"line":205,"address":[14042144],"length":1,"stats":{"Line":0}},{"line":207,"address":[19724027],"length":1,"stats":{"Line":0}},{"line":208,"address":[19724042,19724387,19724368],"length":1,"stats":{"Line":0}},{"line":209,"address":[19724576,19724060,19724560],"length":1,"stats":{"Line":0}},{"line":213,"address":[13341003,13341130],"length":1,"stats":{"Line":0}},{"line":216,"address":[19724275,19724256,19721522],"length":1,"stats":{"Line":0}},{"line":217,"address":[19724224,19724240,19721553],"length":1,"stats":{"Line":0}},{"line":220,"address":[13341208],"length":1,"stats":{"Line":0}},{"line":223,"address":[14021167,14023392,14023402],"length":1,"stats":{"Line":0}},{"line":224,"address":[14023680,14023715,14021210],"length":1,"stats":{"Line":0}},{"line":228,"address":[14021280],"length":1,"stats":{"Line":0}},{"line":231,"address":[14039695,14042032,14042048],"length":1,"stats":{"Line":0}},{"line":234,"address":[19721954],"length":1,"stats":{"Line":0}},{"line":237,"address":[19724090,19722067,19724080],"length":1,"stats":{"Line":0}},{"line":238,"address":[14023459,14021594,14023424],"length":1,"stats":{"Line":0}},{"line":242,"address":[14039932],"length":1,"stats":{"Line":0}},{"line":245,"address":[14040046,14041856],"length":1,"stats":{"Line":0}},{"line":246,"address":[14042256,14041892],"length":1,"stats":{"Line":0}},{"line":247,"address":[13344042],"length":1,"stats":{"Line":0}},{"line":248,"address":[14024029],"length":1,"stats":{"Line":0}},{"line":249,"address":[14042343,14042448,14042471],"length":1,"stats":{"Line":0}},{"line":255,"address":[14042208,14040179,14042213,14040096],"length":1,"stats":{"Line":0}},{"line":257,"address":[13342455],"length":1,"stats":{"Line":0}},{"line":258,"address":[14040228],"length":1,"stats":{"Line":0}},{"line":259,"address":[14040268],"length":1,"stats":{"Line":0}},{"line":260,"address":[19722480],"length":1,"stats":{"Line":0}},{"line":261,"address":[13342152],"length":1,"stats":{"Line":0}},{"line":262,"address":[14040388],"length":1,"stats":{"Line":0}},{"line":263,"address":[14040428],"length":1,"stats":{"Line":0}},{"line":264,"address":[14040468],"length":1,"stats":{"Line":0}},{"line":265,"address":[14022220],"length":1,"stats":{"Line":0}},{"line":268,"address":[14022287],"length":1,"stats":{"Line":0}},{"line":269,"address":[14022319],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":57},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","go_proxy.rs"],"content":"//! # Go Module Proxy Client\n//!\n//! This module implements a client for the [Go Module Proxy](https://proxy.golang.org),\n//! the official module mirror and checksum database for Go modules.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://proxy.golang.org`\n//! - **API Version**: Module Proxy Protocol (stable)\n//! - **Authentication**: Not required for public modules\n//! - **GOPROXY**: Supports custom proxy URLs via environment variable\n//!\n//! ## Rate Limiting\n//!\n//! The Go proxy does not publish official rate limits but implements:\n//!\n//! - **Fair use policy**: No hard limits for normal usage\n//! - **CDN caching**: Most requests are served from cache\n//! - **Best practice**: Respect cache headers\n//!\n//! ## API Endpoints Used\n//!\n//! ### List Versions\n//!\n//! - **Endpoint**: `GET /{module}/@v/list`\n//! - **Response**: Plain text, one version per line\n//! - **Example**: `v1.0.0\\nv1.0.1\\nv1.1.0`\n//!\n//! ### Get Latest Version\n//!\n//! - **Endpoint**: `GET /{module}/@latest`\n//! - **Response**: JSON with version and timestamp\n//! - **Fields**:\n//!   - `Version`: Version string (e.g., `v1.2.3`)\n//!   - `Time`: RFC 3339 timestamp\n//!\n//! ### Get Version Info\n//!\n//! - **Endpoint**: `GET /{module}/@v/{version}.info`\n//! - **Response**: JSON with version metadata\n//! - **Fields**:\n//!   - `Version`: Canonical version string\n//!   - `Time`: RFC 3339 release timestamp\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: Semver with `v` prefix required (`v1.0.0`, `v2.0.0-rc1`)\n//! - **Date format**: RFC 3339 (`2024-01-15T10:30:00Z`)\n//! - **Module paths**: May contain version suffix for v2+ (`/v2`, `/v3`)\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **Module path encoding**: Uppercase letters become `!` + lowercase\n//!   (`github.com/Azure/sdk` → `github.com/!azure/sdk`)\n//! - **Major version suffixes**: v2+ modules have path suffix (`module/v2`)\n//! - **Pseudo-versions**: Auto-generated for commits without tags\n//!   (`v0.0.0-20210101000000-abcdef123456`)\n//! - **Private modules**: Not available on public proxy; require `GOPRIVATE`\n//! - **Checksum database**: `sum.golang.org` verifies module integrity\n//! - **Retracted versions**: Marked in `go.mod` but still listed\n//!\n//! ## Error Handling\n//!\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: 404 for not found, 410 for gone/retracted\n//! - **Timeouts**: 10 second default timeout\n//!\n//! ## External References\n//!\n//! - [Go Module Proxy Protocol](https://go.dev/ref/mod#module-proxy)\n//! - [Module Version Numbering](https://go.dev/ref/mod#versions)\n//! - [Checksum Database](https://sum.golang.org/)\n//! - [GOPROXY Environment Variable](https://go.dev/ref/mod#environment-variables)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\n\nuse super::http_client::create_shared_client;\nuse super::version_utils::is_prerelease_go;\nuse super::{Registry, VersionInfo};\n\n/// Client for the Go module proxy\npub struct GoProxyRegistry {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl GoProxyRegistry {\n    /// Creates a GoProxyRegistry that uses the provided shared HTTP client and the default Go proxy base URL.\n    ///\n    /// `client` is the shared `reqwest::Client` used for all outgoing HTTP requests to the Go proxy.\n    /// The returned registry is configured with `base_url` set to `https://proxy.golang.org`.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::go_proxy::GoProxyRegistry;\n    ///\n    /// let client = Arc::new(reqwest::Client::new());\n    /// let _registry = GoProxyRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            base_url: \"https://proxy.golang.org\".to_string(),\n        }\n    }\n}\n\nimpl Default for GoProxyRegistry {\n    /// Creates a GoProxyRegistry configured with a shared HTTP client.\n    ///\n    /// The registry's HTTP client is produced by `create_shared_client`.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::go_proxy::GoProxyRegistry;\n    ///\n    /// let registry = GoProxyRegistry::default();\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n// Go proxy API response for version info\n#[derive(Debug, Deserialize)]\nstruct VersionInfoResponse {\n    #[serde(rename = \"Version\")]\n    version: String,\n    #[serde(rename = \"Time\")]\n    time: Option<String>,\n}\n\nimpl Registry for GoProxyRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, module_path: &str) -> anyhow::Result<VersionInfo> {\n        // Encode module path for URL\n        // Go proxy requires case-encoding: uppercase letters become ! followed by lowercase\n        let encoded_path = encode_module_path(module_path);\n\n        // Fetch list of versions\n        let versions = self.fetch_versions(&encoded_path).await.unwrap_or_default();\n\n        // Fetch latest version info\n        let latest = self.fetch_latest(&encoded_path).await.ok();\n\n        // Sort versions in descending order\n        let mut sorted_versions = versions.clone();\n        sorted_versions.sort_by(|a, b| compare_go_versions(b, a));\n\n        // Find latest stable version (no prerelease suffix)\n        let latest_stable = latest.as_ref().map(|l| l.version.clone()).or_else(|| {\n            sorted_versions\n                .iter()\n                .find(|v| !is_prerelease_go(v))\n                .cloned()\n        });\n\n        // Find latest prerelease\n        let latest_prerelease = sorted_versions\n            .iter()\n            .find(|v| is_prerelease_go(v))\n            .cloned();\n\n        // Build repository URL for common hosts\n        let repository =\n            if module_path.starts_with(\"github.com/\") || module_path.starts_with(\"gitlab.com/\") {\n                Some(format!(\"https://{}\", module_path))\n            } else {\n                None\n            };\n\n        // Fetch release dates for versions (fetch info for each version in parallel)\n        let release_dates = self\n            .fetch_version_times(&encoded_path, &sorted_versions)\n            .await;\n\n        Ok(VersionInfo {\n            latest: latest_stable,\n            latest_prerelease,\n            versions: sorted_versions,\n            description: None, // Go proxy doesn't provide descriptions\n            homepage: None,\n            repository,\n            license: None,           // Would need to fetch go.mod or LICENSE file\n            vulnerabilities: vec![], // TODO: Integrate vuln.go.dev\n            deprecated: false,\n            yanked: false,\n            yanked_versions: vec![], // Not applicable to Go\n            release_dates,\n        })\n    }\n}\n\nimpl GoProxyRegistry {\n    /// Fetch list of available versions\n    async fn fetch_versions(&self, encoded_path: &str) -> anyhow::Result<Vec<String>> {\n        let url = format!(\"{}/{}/@v/list\", self.base_url, encoded_path);\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch versions for {}: {}\",\n                encoded_path,\n                response.status()\n            );\n        }\n\n        let text = response.text().await?;\n        let versions: Vec<String> = text.lines().map(|s| s.trim().to_string()).collect();\n\n        Ok(versions)\n    }\n\n    /// Fetch latest version info\n    async fn fetch_latest(&self, encoded_path: &str) -> anyhow::Result<VersionInfoResponse> {\n        let url = format!(\"{}/{}/@latest\", self.base_url, encoded_path);\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch latest for {}: {}\",\n                encoded_path,\n                response.status()\n            );\n        }\n\n        let info: VersionInfoResponse = response.json().await?;\n        Ok(info)\n    }\n\n    /// Fetch version info for a specific version\n    async fn fetch_version_info(\n        &self,\n        encoded_path: &str,\n        version: &str,\n    ) -> Option<VersionInfoResponse> {\n        let url = format!(\"{}/{}/@v/{}.info\", self.base_url, encoded_path, version);\n\n        let response = self.client.get(&url).send().await.ok()?;\n\n        if !response.status().is_success() {\n            return None;\n        }\n\n        response.json().await.ok()\n    }\n\n    /// Fetch release times for a list of versions (limited to first 10 for performance)\n    async fn fetch_version_times(\n        &self,\n        encoded_path: &str,\n        versions: &[String],\n    ) -> HashMap<String, DateTime<Utc>> {\n        use futures::future::join_all;\n\n        let futures: Vec<_> = versions\n            .iter()\n            .take(10)\n            .map(|v| async move {\n                self.fetch_version_info(encoded_path, v)\n                    .await\n                    .and_then(|info| {\n                        info.time.as_ref().and_then(|time_str| {\n                            DateTime::parse_from_rfc3339(time_str)\n                                .ok()\n                                .map(|dt| (v.clone(), dt.with_timezone(&Utc)))\n                        })\n                    })\n            })\n            .collect();\n\n        let results = join_all(futures).await;\n        results.into_iter().flatten().collect()\n    }\n}\n\n/// Encode module path for Go proxy URL\n/// Uppercase letters are replaced with ! followed by lowercase\nfn encode_module_path(path: &str) -> String {\n    let mut result = String::with_capacity(path.len() * 2);\n\n    for ch in path.chars() {\n        if ch.is_ascii_uppercase() {\n            result.push('!');\n            result.push(ch.to_ascii_lowercase());\n        } else {\n            result.push(ch);\n        }\n    }\n\n    result\n}\n\n/// Compare Go versions for sorting\nfn compare_go_versions(a: &str, b: &str) -> std::cmp::Ordering {\n    // Strip 'v' prefix if present\n    let a_stripped = a.strip_prefix('v').unwrap_or(a);\n    let b_stripped = b.strip_prefix('v').unwrap_or(b);\n\n    // Try parsing as semver\n    match (\n        semver::Version::parse(a_stripped),\n        semver::Version::parse(b_stripped),\n    ) {\n        (Ok(va), Ok(vb)) => va.cmp(&vb),\n        _ => {\n            // Fallback to string comparison\n            compare_version_strings(a_stripped, b_stripped)\n        }\n    }\n}\n\n/// Simple version string comparison\nfn compare_version_strings(a: &str, b: &str) -> std::cmp::Ordering {\n    let parse_parts = |s: &str| -> Vec<u64> {\n        s.split(|c: char| !c.is_ascii_digit())\n            .filter_map(|p| p.parse().ok())\n            .collect()\n    };\n\n    let parts_a = parse_parts(a);\n    let parts_b = parse_parts(b);\n\n    for (pa, pb) in parts_a.iter().zip(parts_b.iter()) {\n        match pa.cmp(pb) {\n            std::cmp::Ordering::Equal => continue,\n            other => return other,\n        }\n    }\n\n    parts_a.len().cmp(&parts_b.len())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_encode_module_path() {\n        assert_eq!(\n            encode_module_path(\"github.com/Azure/azure-sdk-for-go\"),\n            \"github.com/!azure/azure-sdk-for-go\"\n        );\n        assert_eq!(\n            encode_module_path(\"github.com/gin-gonic/gin\"),\n            \"github.com/gin-gonic/gin\"\n        );\n        assert_eq!(encode_module_path(\"golang.org/x/text\"), \"golang.org/x/text\");\n    }\n\n    #[test]\n    fn test_is_prerelease() {\n        assert!(is_prerelease_go(\"v1.0.0-rc1\"));\n        assert!(is_prerelease_go(\"v2.0.0-beta.1\"));\n        assert!(is_prerelease_go(\"v3.0.0-alpha\"));\n        assert!(!is_prerelease_go(\"v1.0.0\"));\n        assert!(!is_prerelease_go(\"v2.3.4\"));\n    }\n\n    #[test]\n    fn test_compare_go_versions() {\n        use std::cmp::Ordering;\n\n        assert_eq!(compare_go_versions(\"v1.0.0\", \"v2.0.0\"), Ordering::Less);\n        assert_eq!(compare_go_versions(\"v2.0.0\", \"v1.0.0\"), Ordering::Greater);\n        assert_eq!(compare_go_versions(\"v1.0.0\", \"v1.0.0\"), Ordering::Equal);\n        assert_eq!(compare_go_versions(\"v1.10.0\", \"v1.9.0\"), Ordering::Greater);\n    }\n}\n","traces":[{"line":107,"address":[14336394,14336256,14336388],"length":1,"stats":{"Line":2}},{"line":110,"address":[20350199],"length":1,"stats":{"Line":2}},{"line":127,"address":[13009344],"length":1,"stats":{"Line":0}},{"line":128,"address":[14339518],"length":1,"stats":{"Line":0}},{"line":142,"address":[13006080],"length":1,"stats":{"Line":2}},{"line":143,"address":[14336181],"length":1,"stats":{"Line":2}},{"line":146,"address":[14496247,14496297,14497066,14496204,14496559,14496032,14496094,14496268],"length":1,"stats":{"Line":0}},{"line":149,"address":[14496179],"length":1,"stats":{"Line":0}},{"line":152,"address":[12492815],"length":1,"stats":{"Line":0}},{"line":155,"address":[12492830],"length":1,"stats":{"Line":0}},{"line":158,"address":[13108895,13108814],"length":1,"stats":{"Line":0}},{"line":159,"address":[20357043,20357132,20359520,20359557],"length":1,"stats":{"Line":0}},{"line":162,"address":[20357147,20359616,20359632,20359648,20357215],"length":1,"stats":{"Line":0}},{"line":163,"address":[14471120],"length":1,"stats":{"Line":0}},{"line":164,"address":[14500060],"length":1,"stats":{"Line":0}},{"line":165,"address":[20359708,20359744,20359758],"length":1,"stats":{"Line":0}},{"line":166,"address":[13111502],"length":1,"stats":{"Line":0}},{"line":170,"address":[14497684,14497852,14497799],"length":1,"stats":{"Line":0}},{"line":172,"address":[20357407,20359486,20359472],"length":1,"stats":{"Line":0}},{"line":176,"address":[14498289,14497969,14497882,14498056],"length":1,"stats":{"Line":0}},{"line":178,"address":[14498132,14498025],"length":1,"stats":{"Line":0}},{"line":180,"address":[13109502],"length":1,"stats":{"Line":0}},{"line":184,"address":[14498471,14498698,14498099],"length":1,"stats":{"Line":0}},{"line":185,"address":[13109799,13109540],"length":1,"stats":{"Line":0}},{"line":186,"address":[14498436,14496276,14498535,14498794,14498504],"length":1,"stats":{"Line":0}},{"line":188,"address":[14499155],"length":1,"stats":{"Line":0}},{"line":189,"address":[14498820],"length":1,"stats":{"Line":0}},{"line":190,"address":[13110262],"length":1,"stats":{"Line":0}},{"line":191,"address":[14498888],"length":1,"stats":{"Line":0}},{"line":192,"address":[13110334],"length":1,"stats":{"Line":0}},{"line":193,"address":[20358486],"length":1,"stats":{"Line":0}},{"line":194,"address":[13110350],"length":1,"stats":{"Line":0}},{"line":195,"address":[14498976],"length":1,"stats":{"Line":0}},{"line":196,"address":[14470056],"length":1,"stats":{"Line":0}},{"line":199,"address":[14499047],"length":1,"stats":{"Line":0}},{"line":200,"address":[14499107],"length":1,"stats":{"Line":0}},{"line":207,"address":[13006336,13006354],"length":1,"stats":{"Line":0}},{"line":208,"address":[13114036,13114190],"length":1,"stats":{"Line":0}},{"line":210,"address":[15215679],"length":1,"stats":{"Line":0}},{"line":212,"address":[14503661,14503723],"length":1,"stats":{"Line":0}},{"line":213,"address":[13115072,13115171],"length":1,"stats":{"Line":0}},{"line":220,"address":[14473866,14476032,14474864,14475208,14475345],"length":1,"stats":{"Line":0}},{"line":221,"address":[14505024,14504750,14504673,14505077],"length":1,"stats":{"Line":0}},{"line":223,"address":[14504811],"length":1,"stats":{"Line":0}},{"line":227,"address":[20360004,20360473,20359840,20361470,20360076,20359887,20360047],"length":1,"stats":{"Line":0}},{"line":228,"address":[14471659,14471505],"length":1,"stats":{"Line":0}},{"line":230,"address":[13113294,13112123,13111890,13112204,13112363],"length":1,"stats":{"Line":0}},{"line":232,"address":[13112745,13112807],"length":1,"stats":{"Line":0}},{"line":233,"address":[14501583,14501484],"length":1,"stats":{"Line":0}},{"line":240,"address":[14500519,14501508,14501852,14501988,14502508],"length":1,"stats":{"Line":0}},{"line":241,"address":[13113719],"length":1,"stats":{"Line":0}},{"line":245,"address":[14336512],"length":1,"stats":{"Line":0}},{"line":250,"address":[20364674,20364833],"length":1,"stats":{"Line":0}},{"line":252,"address":[13117773,13117106,13116956,13116611,13116881],"length":1,"stats":{"Line":0}},{"line":254,"address":[20365623,20365682],"length":1,"stats":{"Line":0}},{"line":255,"address":[14477426],"length":1,"stats":{"Line":0}},{"line":258,"address":[12471157],"length":1,"stats":{"Line":0}},{"line":262,"address":[14336576],"length":1,"stats":{"Line":0}},{"line":272,"address":[14507811,14508431,14508099,14507712,14507776,14507728,14507898,14507194,14507940],"length":1,"stats":{"Line":0}},{"line":273,"address":[20367560,20367147,20367343,20367311],"length":1,"stats":{"Line":0}},{"line":274,"address":[14479151,14479098,14479202,14479404,14478997],"length":1,"stats":{"Line":0}},{"line":275,"address":[14479520,14479656,14479424],"length":1,"stats":{"Line":0}},{"line":276,"address":[20367856,20367812,20367749],"length":1,"stats":{"Line":0}},{"line":277,"address":[13119754],"length":1,"stats":{"Line":0}},{"line":278,"address":[13119773],"length":1,"stats":{"Line":0}},{"line":279,"address":[14479767,14479815,14479792],"length":1,"stats":{"Line":0}},{"line":285,"address":[14507098,14507250,14507383],"length":1,"stats":{"Line":0}},{"line":286,"address":[20366901],"length":1,"stats":{"Line":0}},{"line":292,"address":[14336640,14337100,14337094],"length":1,"stats":{"Line":2}},{"line":293,"address":[13006571,13006636],"length":1,"stats":{"Line":2}},{"line":295,"address":[13006619,13006700],"length":1,"stats":{"Line":4}},{"line":296,"address":[13006879,13006820],"length":1,"stats":{"Line":4}},{"line":297,"address":[13006914],"length":1,"stats":{"Line":2}},{"line":298,"address":[14318774],"length":1,"stats":{"Line":2}},{"line":300,"address":[14337013,14337049],"length":1,"stats":{"Line":4}},{"line":304,"address":[13006841],"length":1,"stats":{"Line":2}},{"line":308,"address":[14318832,14319740,14319891],"length":1,"stats":{"Line":2}},{"line":310,"address":[20351083],"length":1,"stats":{"Line":2}},{"line":311,"address":[14319027],"length":1,"stats":{"Line":2}},{"line":314,"address":[14337634,14337497],"length":1,"stats":{"Line":4}},{"line":315,"address":[14319110],"length":1,"stats":{"Line":2}},{"line":316,"address":[13007321],"length":1,"stats":{"Line":2}},{"line":318,"address":[14319377],"length":1,"stats":{"Line":2}},{"line":321,"address":[20351938,20351520],"length":1,"stats":{"Line":0}},{"line":327,"address":[13008240,13009050,13009056],"length":1,"stats":{"Line":0}},{"line":328,"address":[14480032],"length":1,"stats":{"Line":0}},{"line":329,"address":[14509025,14509165,14509152],"length":1,"stats":{"Line":0}},{"line":330,"address":[14509088,14509107,14509036],"length":1,"stats":{"Line":0}},{"line":334,"address":[20352376],"length":1,"stats":{"Line":0}},{"line":335,"address":[14320237],"length":1,"stats":{"Line":0}},{"line":337,"address":[13008432,13008512],"length":1,"stats":{"Line":0}},{"line":338,"address":[13008989,13008811],"length":1,"stats":{"Line":0}},{"line":340,"address":[14320876],"length":1,"stats":{"Line":0}},{"line":344,"address":[14320693],"length":1,"stats":{"Line":0}}],"covered":19,"coverable":94},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","http_client.rs"],"content":"//! Shared HTTP client for all registry clients.\n//!\n//! This module provides a shared HTTP client with proper configuration\n//! for connection pooling, HTTP/2, and timeout handling. Sharing a single\n//! client across all registries enables:\n//!\n//! - Connection reuse across different registries\n//! - HTTP/2 multiplexing where supported\n//! - Reduced TLS handshake overhead\n//! - Shared DNS cache\n//! - Lower memory footprint\n\nuse std::sync::Arc;\nuse std::time::Duration;\n\nuse reqwest::Client;\n\nconst USER_AGENT: &str = concat!(\n    \"dependi-lsp/\",\n    env!(\"CARGO_PKG_VERSION\"),\n    \" (https://github.com/mpiton/zed-dependi)\"\n);\n\nconst DEFAULT_TIMEOUT: Duration = Duration::from_secs(10);\nconst POOL_IDLE_TIMEOUT: Duration = Duration::from_secs(90);\nconst CONNECT_TIMEOUT: Duration = Duration::from_secs(5);\n\npub fn create_shared_client() -> anyhow::Result<Arc<Client>> {\n    let client = Client::builder()\n        .user_agent(USER_AGENT)\n        .timeout(DEFAULT_TIMEOUT)\n        .connect_timeout(CONNECT_TIMEOUT)\n        .pool_idle_timeout(POOL_IDLE_TIMEOUT)\n        .pool_max_idle_per_host(10)\n        .tcp_keepalive(Duration::from_secs(60))\n        .build()?;\n\n    Ok(Arc::new(client))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::registries::Registry;\n    use crate::registries::crates_io::CratesIoRegistry;\n    use crate::registries::go_proxy::GoProxyRegistry;\n    use crate::registries::npm::NpmRegistry;\n    use crate::registries::nuget::NuGetRegistry;\n    use crate::registries::packagist::PackagistRegistry;\n    use crate::registries::pub_dev::PubDevRegistry;\n    use crate::registries::pypi::PyPiRegistry;\n    use crate::registries::rubygems::RubyGemsRegistry;\n\n    #[test]\n    fn test_create_shared_client() {\n        let client = create_shared_client().expect(\"Failed to create client\");\n        assert!(Arc::strong_count(&client) == 1);\n    }\n\n    #[test]\n    fn test_client_can_be_cloned() {\n        let client = create_shared_client().expect(\"Failed to create client\");\n        let client2 = Arc::clone(&client);\n        assert!(Arc::strong_count(&client) == 2);\n        drop(client2);\n        assert!(Arc::strong_count(&client) == 1);\n    }\n\n    #[test]\n    fn test_registries_share_client_instance() {\n        let shared_client = create_shared_client().expect(\"Failed to create client\");\n        let client_ptr = Arc::as_ptr(&shared_client);\n\n        let crates_io = CratesIoRegistry::with_client(Arc::clone(&shared_client));\n        let npm = NpmRegistry::with_client(Arc::clone(&shared_client));\n        let pypi = PyPiRegistry::with_client(Arc::clone(&shared_client));\n        let go_proxy = GoProxyRegistry::with_client(Arc::clone(&shared_client));\n        let packagist = PackagistRegistry::with_client(Arc::clone(&shared_client));\n        let pub_dev = PubDevRegistry::with_client(Arc::clone(&shared_client));\n        let nuget = NuGetRegistry::with_client(Arc::clone(&shared_client));\n        let rubygems = RubyGemsRegistry::with_client(Arc::clone(&shared_client));\n\n        assert_eq!(Arc::as_ptr(&crates_io.http_client()), client_ptr);\n        assert_eq!(Arc::as_ptr(&npm.http_client()), client_ptr);\n        assert_eq!(Arc::as_ptr(&pypi.http_client()), client_ptr);\n        assert_eq!(Arc::as_ptr(&go_proxy.http_client()), client_ptr);\n        assert_eq!(Arc::as_ptr(&packagist.http_client()), client_ptr);\n        assert_eq!(Arc::as_ptr(&pub_dev.http_client()), client_ptr);\n        assert_eq!(Arc::as_ptr(&nuget.http_client()), client_ptr);\n        assert_eq!(Arc::as_ptr(&rubygems.http_client()), client_ptr);\n\n        assert_eq!(Arc::strong_count(&shared_client), 9);\n    }\n\n    #[test]\n    fn test_default_registries_create_separate_clients() {\n        let crates_io = CratesIoRegistry::default();\n        let npm = NpmRegistry::default();\n\n        assert_ne!(\n            Arc::as_ptr(&crates_io.http_client()),\n            Arc::as_ptr(&npm.http_client())\n        );\n    }\n}\n","traces":[{"line":28,"address":[13012294,13012323,13011712],"length":1,"stats":{"Line":2}},{"line":29,"address":[13012129,13012162,13011734,13012089,13012032],"length":1,"stats":{"Line":19}},{"line":30,"address":[13332161],"length":1,"stats":{"Line":3}},{"line":31,"address":[13011816],"length":1,"stats":{"Line":3}},{"line":32,"address":[13011863],"length":1,"stats":{"Line":3}},{"line":33,"address":[13011899],"length":1,"stats":{"Line":5}},{"line":35,"address":[13012040,13011966,13012329,13011982],"length":1,"stats":{"Line":10}},{"line":38,"address":[13012254,13012188],"length":1,"stats":{"Line":12}}],"covered":8,"coverable":8},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","mod.rs"],"content":"//! # Package Registry Clients\n//!\n//! This module provides clients for fetching package version information from\n//! various package registries across different programming ecosystems.\n//!\n//! ## Supported Registries\n//!\n//! | Registry | Ecosystem | Module |\n//! |----------|-----------|--------|\n//! | [crates.io](https://crates.io) | Rust | [`crates_io`] |\n//! | [npm](https://www.npmjs.com) | Node.js/JavaScript | [`npm`] |\n//! | [PyPI](https://pypi.org) | Python | [`pypi`] |\n//! | [Go Proxy](https://proxy.golang.org) | Go | [`go_proxy`] |\n//! | [Packagist](https://packagist.org) | PHP/Composer | [`packagist`] |\n//! | [pub.dev](https://pub.dev) | Dart/Flutter | [`pub_dev`] |\n//! | [NuGet](https://www.nuget.org) | .NET | [`nuget`] |\n//! | [RubyGems](https://rubygems.org) | Ruby | [`rubygems`] |\n//!\n//! ## Architecture\n//!\n//! All registry clients implement the [`Registry`] trait, providing a unified\n//! interface for fetching package metadata:\n//!\n//! ```ignore\n//! pub trait Registry: Send + Sync {\n//!     async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo>;\n//!     fn http_client(&self) -> Arc<Client>;\n//! }\n//! ```\n//!\n//! ## Shared HTTP Client\n//!\n//! Registry clients share a single HTTP client via [`http_client::create_shared_client`]\n//! for connection pooling, HTTP/2 multiplexing, and reduced memory footprint.\n//!\n//! ## Common Return Type\n//!\n//! All registries return [`VersionInfo`] containing:\n//!\n//! - **Latest stable version**: The most recent non-prerelease version\n//! - **Latest prerelease**: The most recent prerelease version (if any)\n//! - **All versions**: Complete list of available versions\n//! - **Metadata**: Description, homepage, repository, license\n//! - **Status**: Deprecated, yanked flags\n//! - **Release dates**: Publish timestamps for each version\n//!\n//! ## Vulnerability Detection\n//!\n//! Vulnerability information is populated separately via the OSV API\n//! (see `vulnerabilities` module), not by the registry clients themselves.\n//!\n//! ## Rate Limiting\n//!\n//! Each registry has different rate limiting policies:\n//!\n//! | Registry | Rate Limit | Notes |\n//! |----------|------------|-------|\n//! | crates.io | 1 req/s | **Strict** - client-side enforced |\n//! | npm | ≤1 req/s recommended | No official limit; IP blocking for abuse |\n//! | PyPI | No official limit | CDN-cached; be respectful |\n//! | Go Proxy | Fair use | No hard limit |\n//! | Packagist | ~60/min | CDN-cached |\n//! | pub.dev | ~100/min | CDN-cached |\n//! | NuGet | Fair use | CDN-cached |\n//! | RubyGems | Varies by endpoint | ~10 req/s typical; blocking for abuse |\n//!\n//! ## Usage\n//!\n//! ```ignore\n//! use dependi_lsp::registries::{Registry, crates_io::CratesIoRegistry};\n//!\n//! let registry = CratesIoRegistry::default();\n//! let info = registry.get_version_info(\"serde\").await?;\n//! println!(\"Latest: {:?}\", info.latest);\n//! ```\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\n\n/// Information about a package version from a registry\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct VersionInfo {\n    /// Latest stable version\n    pub latest: Option<String>,\n    /// Latest prerelease version\n    pub latest_prerelease: Option<String>,\n    /// All available versions\n    pub versions: Vec<String>,\n    /// Package description\n    pub description: Option<String>,\n    /// Homepage URL\n    pub homepage: Option<String>,\n    /// Repository URL (GitHub, etc.)\n    pub repository: Option<String>,\n    /// SPDX license identifier\n    pub license: Option<String>,\n    /// Known vulnerabilities\n    pub vulnerabilities: Vec<Vulnerability>,\n    /// Whether the package is deprecated\n    pub deprecated: bool,\n    /// Whether the version is yanked (Rust specific) - deprecated, use yanked_versions instead\n    pub yanked: bool,\n    /// List of yanked version numbers (Rust specific)\n    pub yanked_versions: Vec<String>,\n    /// Release dates for each version (version string -> DateTime)\n    #[serde(default)]\n    pub release_dates: HashMap<String, DateTime<Utc>>,\n}\n\nimpl VersionInfo {\n    /// Check if a specific version is yanked\n    pub fn is_version_yanked(&self, version: &str) -> bool {\n        let normalized = normalize_version_for_yanked_check(version);\n        self.yanked_versions\n            .iter()\n            .any(|v| normalize_version_for_yanked_check(v) == normalized)\n    }\n\n    /// Get the release date for a specific version\n    pub fn get_release_date(&self, version: &str) -> Option<DateTime<Utc>> {\n        self.release_dates.get(version).copied()\n    }\n}\n\n/// Normalize version for yanked check comparison\n/// Removes common prefixes like ^, ~, >=, etc.\nfn normalize_version_for_yanked_check(version: &str) -> String {\n    let version = version.trim();\n    version\n        .strip_prefix('^')\n        .or_else(|| version.strip_prefix('~'))\n        .or_else(|| version.strip_prefix(\">=\"))\n        .or_else(|| version.strip_prefix(\"<=\"))\n        .or_else(|| version.strip_prefix('>'))\n        .or_else(|| version.strip_prefix('<'))\n        .or_else(|| version.strip_prefix('='))\n        .unwrap_or(version)\n        .split(',')\n        .next()\n        .unwrap_or(version)\n        .trim()\n        .to_string()\n}\n\n/// Vulnerability information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Vulnerability {\n    /// CVE or advisory ID\n    pub id: String,\n    /// Severity level\n    pub severity: VulnerabilitySeverity,\n    /// Description of the vulnerability\n    pub description: String,\n    /// URL for more information\n    pub url: Option<String>,\n}\n\n/// Vulnerability severity levels\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\npub enum VulnerabilitySeverity {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\nimpl VulnerabilitySeverity {\n    /// Get numeric rank for severity comparison (higher = more severe)\n    pub fn rank(&self) -> u8 {\n        match self {\n            VulnerabilitySeverity::Low => 1,\n            VulnerabilitySeverity::Medium => 2,\n            VulnerabilitySeverity::High => 3,\n            VulnerabilitySeverity::Critical => 4,\n        }\n    }\n\n    /// Check if this severity meets or exceeds a minimum threshold\n    pub fn meets_threshold(&self, min: &Self) -> bool {\n        self.rank() >= min.rank()\n    }\n\n    /// Parse severity from string (case-insensitive)\n    pub fn from_str_loose(s: &str) -> Self {\n        match s.to_lowercase().as_str() {\n            \"critical\" => VulnerabilitySeverity::Critical,\n            \"high\" => VulnerabilitySeverity::High,\n            \"medium\" => VulnerabilitySeverity::Medium,\n            _ => VulnerabilitySeverity::Low,\n        }\n    }\n\n    /// Get lowercase string representation\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            VulnerabilitySeverity::Low => \"low\",\n            VulnerabilitySeverity::Medium => \"medium\",\n            VulnerabilitySeverity::High => \"high\",\n            VulnerabilitySeverity::Critical => \"critical\",\n        }\n    }\n}\n\n/// Trait for registry clients\n/// Note: async_fn_in_trait is allowed because this trait is internal and already bounds Send + Sync\n#[allow(async_fn_in_trait)]\npub trait Registry: Send + Sync {\n    /// Get version information for a package\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo>;\n\n    /// Get a reference to the HTTP client used by this registry\n    fn http_client(&self) -> Arc<Client>;\n}\n\npub mod crates_io;\npub mod go_proxy;\npub mod http_client;\npub mod npm;\npub mod nuget;\npub mod packagist;\npub mod pub_dev;\npub mod pypi;\npub mod rubygems;\npub mod version_utils;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_severity_rank() {\n        assert_eq!(VulnerabilitySeverity::Low.rank(), 1);\n        assert_eq!(VulnerabilitySeverity::Medium.rank(), 2);\n        assert_eq!(VulnerabilitySeverity::High.rank(), 3);\n        assert_eq!(VulnerabilitySeverity::Critical.rank(), 4);\n    }\n\n    #[test]\n    fn test_severity_meets_threshold() {\n        // Critical meets all thresholds\n        assert!(VulnerabilitySeverity::Critical.meets_threshold(&VulnerabilitySeverity::Low));\n        assert!(VulnerabilitySeverity::Critical.meets_threshold(&VulnerabilitySeverity::Medium));\n        assert!(VulnerabilitySeverity::Critical.meets_threshold(&VulnerabilitySeverity::High));\n        assert!(VulnerabilitySeverity::Critical.meets_threshold(&VulnerabilitySeverity::Critical));\n\n        // Low only meets Low threshold\n        assert!(VulnerabilitySeverity::Low.meets_threshold(&VulnerabilitySeverity::Low));\n        assert!(!VulnerabilitySeverity::Low.meets_threshold(&VulnerabilitySeverity::Medium));\n        assert!(!VulnerabilitySeverity::Low.meets_threshold(&VulnerabilitySeverity::High));\n        assert!(!VulnerabilitySeverity::Low.meets_threshold(&VulnerabilitySeverity::Critical));\n\n        // High meets Low, Medium, and High thresholds\n        assert!(VulnerabilitySeverity::High.meets_threshold(&VulnerabilitySeverity::Low));\n        assert!(VulnerabilitySeverity::High.meets_threshold(&VulnerabilitySeverity::Medium));\n        assert!(VulnerabilitySeverity::High.meets_threshold(&VulnerabilitySeverity::High));\n        assert!(!VulnerabilitySeverity::High.meets_threshold(&VulnerabilitySeverity::Critical));\n    }\n\n    #[test]\n    fn test_severity_from_str_loose() {\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"critical\"),\n            VulnerabilitySeverity::Critical\n        );\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"CRITICAL\"),\n            VulnerabilitySeverity::Critical\n        );\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"high\"),\n            VulnerabilitySeverity::High\n        );\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"HIGH\"),\n            VulnerabilitySeverity::High\n        );\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"medium\"),\n            VulnerabilitySeverity::Medium\n        );\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"low\"),\n            VulnerabilitySeverity::Low\n        );\n        // Unknown strings default to Low\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"unknown\"),\n            VulnerabilitySeverity::Low\n        );\n        assert_eq!(\n            VulnerabilitySeverity::from_str_loose(\"\"),\n            VulnerabilitySeverity::Low\n        );\n    }\n\n    #[test]\n    fn test_severity_as_str() {\n        assert_eq!(VulnerabilitySeverity::Low.as_str(), \"low\");\n        assert_eq!(VulnerabilitySeverity::Medium.as_str(), \"medium\");\n        assert_eq!(VulnerabilitySeverity::High.as_str(), \"high\");\n        assert_eq!(VulnerabilitySeverity::Critical.as_str(), \"critical\");\n    }\n\n    #[test]\n    fn test_is_version_yanked() {\n        let info = VersionInfo {\n            yanked_versions: vec![\"1.0.0\".to_string(), \"1.0.1\".to_string()],\n            ..Default::default()\n        };\n\n        assert!(info.is_version_yanked(\"1.0.0\"));\n        assert!(info.is_version_yanked(\"1.0.1\"));\n        assert!(!info.is_version_yanked(\"1.0.2\"));\n        assert!(!info.is_version_yanked(\"2.0.0\"));\n    }\n\n    #[test]\n    fn test_is_version_yanked_with_prefixes() {\n        let info = VersionInfo {\n            yanked_versions: vec![\"1.0.0\".to_string()],\n            ..Default::default()\n        };\n\n        assert!(info.is_version_yanked(\"^1.0.0\"));\n        assert!(info.is_version_yanked(\"~1.0.0\"));\n        assert!(info.is_version_yanked(\">=1.0.0\"));\n        assert!(info.is_version_yanked(\"=1.0.0\"));\n    }\n\n    #[test]\n    fn test_is_version_yanked_empty() {\n        let info = VersionInfo::default();\n\n        assert!(!info.is_version_yanked(\"1.0.0\"));\n    }\n}\n","traces":[{"line":116,"address":[18576144,18576343,18576349],"length":1,"stats":{"Line":3}},{"line":117,"address":[13055872],"length":1,"stats":{"Line":3}},{"line":118,"address":[18576186,18576287],"length":1,"stats":{"Line":26}},{"line":120,"address":[13716416,13716446],"length":1,"stats":{"Line":16}},{"line":124,"address":[13084656],"length":1,"stats":{"Line":2}},{"line":125,"address":[14834644],"length":1,"stats":{"Line":2}},{"line":131,"address":[13056656],"length":1,"stats":{"Line":4}},{"line":132,"address":[13085638],"length":1,"stats":{"Line":5}},{"line":135,"address":[13692048,13692062],"length":1,"stats":{"Line":16}},{"line":136,"address":[13085724],"length":1,"stats":{"Line":18}},{"line":137,"address":[16552576,16552590],"length":1,"stats":{"Line":19}},{"line":138,"address":[18577141],"length":1,"stats":{"Line":21}},{"line":139,"address":[13692096,13692110],"length":1,"stats":{"Line":30}},{"line":140,"address":[16552528,16552542],"length":1,"stats":{"Line":35}},{"line":141,"address":[13085834],"length":1,"stats":{"Line":12}},{"line":144,"address":[13085886],"length":1,"stats":{"Line":14}},{"line":173,"address":[13085360],"length":1,"stats":{"Line":2}},{"line":174,"address":[14835285],"length":1,"stats":{"Line":2}},{"line":175,"address":[13085396],"length":1,"stats":{"Line":2}},{"line":176,"address":[14835323],"length":1,"stats":{"Line":2}},{"line":177,"address":[13085410],"length":1,"stats":{"Line":2}},{"line":178,"address":[13085417],"length":1,"stats":{"Line":2}},{"line":183,"address":[13085296],"length":1,"stats":{"Line":2}},{"line":184,"address":[13056387],"length":1,"stats":{"Line":2}},{"line":188,"address":[13056064,13056351,13056357],"length":1,"stats":{"Line":2}},{"line":189,"address":[13056170,13056084],"length":1,"stats":{"Line":4}},{"line":190,"address":[13056252,13056186],"length":1,"stats":{"Line":4}},{"line":191,"address":[13085157,13085230,13085191],"length":1,"stats":{"Line":6}},{"line":192,"address":[13056279,13056326,13056313],"length":1,"stats":{"Line":6}},{"line":193,"address":[14835167],"length":1,"stats":{"Line":2}},{"line":198,"address":[14835360],"length":1,"stats":{"Line":2}},{"line":199,"address":[13085445],"length":1,"stats":{"Line":2}},{"line":200,"address":[13085476],"length":1,"stats":{"Line":2}},{"line":201,"address":[13056571],"length":1,"stats":{"Line":2}},{"line":202,"address":[13056594],"length":1,"stats":{"Line":2}},{"line":203,"address":[13056617],"length":1,"stats":{"Line":2}}],"covered":36,"coverable":36},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","npm.rs"],"content":"//! # npm Registry Client\n//!\n//! This module implements a client for the [npm](https://www.npmjs.com) registry,\n//! the default package registry for Node.js and JavaScript packages.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://registry.npmjs.org`\n//! - **API Version**: Registry API (stable)\n//! - **Authentication**: Bearer token from `.npmrc` (optional)\n//! - **CORS**: Enabled for browser-based access\n//!\n//! ## Rate Limiting\n//!\n//! npm does **not** enforce hard rate limits on read operations, but implements:\n//!\n//! - **IP-based blocking**: For abusive behavior patterns\n//! - **Cloudflare protection**: May trigger CAPTCHA for suspicious traffic\n//! - **Best practice**: Keep requests under 100/minute for bulk operations\n//!\n//! ## API Endpoints Used\n//!\n//! ### Fetch Package Info\n//!\n//! - **Endpoint**: `GET /{package-name}`\n//! - **Scoped packages**: `GET /@scope%2fpackage-name` (URL encoded `/`)\n//! - **Response**: JSON with full package metadata\n//! - **Fields**:\n//!   - `dist-tags.latest`: Current stable version\n//!   - `dist-tags.next`: Latest prerelease (if exists)\n//!   - `versions{}`: Map of version string to version metadata\n//!   - `time{}`: Map of version string to publish timestamp\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: Semver with optional prerelease (`-alpha`, `-beta`, `-canary`)\n//! - **Date format**: RFC 3339 (`2024-01-15T10:30:00.000Z`)\n//! - **Deprecated packages**: `deprecated` field in version metadata (string message)\n//! - **License**: Can be string or object with `type` field\n//! - **Repository**: Can be string or object with `url` field\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **Scoped packages**: Must URL-encode the slash (`@scope/pkg` → `@scope%2fpkg`)\n//! - **Repository URL formats**: May include `git+https://`, `git://`, or `.git` suffix\n//! - **Large packages**: May have thousands of versions (e.g., lodash)\n//! - **Unpublished packages**: Return 404 but may have been available previously\n//! - **Private packages**: Require authentication; return 401/403 without token\n//! - **Engines field**: Contains Node.js version constraints (not exposed by this client)\n//!\n//! ## Error Handling\n//!\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: 404 for not found, 401/403 for auth issues\n//! - **Timeouts**: 10 second default timeout\n//!\n//! ## External References\n//!\n//! - [npm Registry API](https://github.com/npm/registry/blob/main/docs/REGISTRY-API.md)\n//! - [Package Metadata Specification](https://github.com/npm/registry/blob/main/docs/responses/package-metadata.md)\n//! - [npm CLI Documentation](https://docs.npmjs.com/cli)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\n\nuse super::http_client::create_shared_client;\nuse super::version_utils::is_prerelease_npm;\nuse super::{Registry, VersionInfo};\n\n/// Client for the npm registry\npub struct NpmRegistry {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl NpmRegistry {\n    /// Constructs an NpmRegistry that uses the provided shared HTTP client and the default npm registry base URL.\n    ///\n    /// The supplied `client` is used for all HTTP requests performed by the registry; the base URL is set to\n    /// `https://registry.npmjs.org`.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::npm::NpmRegistry;\n    ///\n    /// let client = Arc::new(reqwest::Client::new());\n    /// let registry = NpmRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            base_url: \"https://registry.npmjs.org\".to_string(),\n        }\n    }\n}\n\nimpl Default for NpmRegistry {\n    /// Creates a default NpmRegistry configured with a shared HTTP client and the standard npm registry base URL.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::npm::NpmRegistry;\n    ///\n    /// let registry = NpmRegistry::default();\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n// API response structures\n#[derive(Debug, Deserialize)]\nstruct PackageResponse {\n    description: Option<String>,\n    homepage: Option<String>,\n    repository: Option<Repository>,\n    license: Option<LicenseField>,\n    #[serde(rename = \"dist-tags\")]\n    dist_tags: Option<DistTags>,\n    versions: Option<HashMap<String, VersionMetadata>>,\n    time: Option<HashMap<String, String>>,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(untagged)]\nenum Repository {\n    String(String),\n    Object { url: Option<String> },\n}\n\nimpl Repository {\n    fn url(&self) -> Option<String> {\n        match self {\n            Repository::String(s) => Some(normalize_repo_url(s)),\n            Repository::Object { url } => url.as_ref().map(|u| normalize_repo_url(u)),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(untagged)]\nenum LicenseField {\n    String(String),\n    Object { r#type: Option<String> },\n}\n\nimpl LicenseField {\n    fn as_string(&self) -> Option<String> {\n        match self {\n            LicenseField::String(s) => Some(s.clone()),\n            LicenseField::Object { r#type } => r#type.clone(),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\nstruct DistTags {\n    latest: Option<String>,\n    next: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VersionMetadata {\n    deprecated: Option<String>,\n}\n\nfn normalize_repo_url(url: &str) -> String {\n    // Convert git+https://github.com/user/repo.git to https://github.com/user/repo\n    let url = url\n        .strip_prefix(\"git+\")\n        .unwrap_or(url)\n        .strip_suffix(\".git\")\n        .unwrap_or(url);\n\n    // Convert git://github.com to https://github.com\n    if url.starts_with(\"git://\") {\n        return url.replace(\"git://\", \"https://\");\n    }\n\n    url.to_string()\n}\n\nimpl Registry for NpmRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo> {\n        // Handle scoped packages (@scope/name -> @scope%2fname)\n        let encoded_name = if package_name.starts_with('@') {\n            package_name.replace('/', \"%2f\")\n        } else {\n            package_name.to_string()\n        };\n\n        let url = format!(\"{}/{}\", self.base_url, encoded_name);\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch package info for {}: {}\",\n                package_name,\n                response.status()\n            );\n        }\n\n        let pkg: PackageResponse = response.json().await?;\n\n        // Get latest version from dist-tags\n        let latest = pkg.dist_tags.as_ref().and_then(|t| t.latest.clone());\n\n        // Get all versions\n        let versions: Vec<String> = pkg\n            .versions\n            .as_ref()\n            .map(|v| {\n                let mut versions: Vec<String> = v.keys().cloned().collect();\n                // Sort versions in descending order (newest first)\n                versions.sort_by(|a, b| {\n                    match (semver::Version::parse(a), semver::Version::parse(b)) {\n                        (Ok(va), Ok(vb)) => vb.cmp(&va),\n                        _ => b.cmp(a),\n                    }\n                });\n                versions\n            })\n            .unwrap_or_default();\n\n        // Find latest prerelease\n        let latest_prerelease = pkg\n            .dist_tags\n            .as_ref()\n            .and_then(|t| t.next.clone())\n            .or_else(|| versions.iter().find(|v| is_prerelease_npm(v)).cloned());\n\n        // Check if latest version is deprecated\n        let deprecated = pkg\n            .versions\n            .as_ref()\n            .and_then(|v| latest.as_ref().and_then(|l| v.get(l)))\n            .is_some_and(|m| m.deprecated.is_some());\n\n        // Get repository URL\n        let repository = pkg.repository.as_ref().and_then(|r| r.url());\n\n        // Parse release dates from the time field (excluding \"created\" and \"modified\" keys)\n        let release_dates: HashMap<String, DateTime<Utc>> = pkg\n            .time\n            .as_ref()\n            .map(|time_map| {\n                time_map\n                    .iter()\n                    .filter(|(k, _)| *k != \"created\" && *k != \"modified\")\n                    .filter_map(|(version, date_str)| {\n                        DateTime::parse_from_rfc3339(date_str)\n                            .ok()\n                            .map(|dt| (version.clone(), dt.with_timezone(&Utc)))\n                    })\n                    .collect()\n            })\n            .unwrap_or_default();\n\n        Ok(VersionInfo {\n            latest,\n            latest_prerelease,\n            versions,\n            description: pkg.description,\n            homepage: pkg.homepage,\n            repository,\n            license: pkg.license.and_then(|l| l.as_string()),\n            vulnerabilities: vec![], // TODO: Integrate npm audit\n            deprecated,\n            yanked: false,\n            yanked_versions: vec![], // Not applicable to npm\n            release_dates,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_prerelease() {\n        assert!(is_prerelease_npm(\"1.0.0-alpha\"));\n        assert!(is_prerelease_npm(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_npm(\"1.0.0-rc.1\"));\n        assert!(is_prerelease_npm(\"18.3.0-canary\"));\n        assert!(!is_prerelease_npm(\"1.0.0\"));\n        assert!(!is_prerelease_npm(\"2.3.4\"));\n    }\n\n    #[test]\n    fn test_normalize_repo_url() {\n        assert_eq!(\n            normalize_repo_url(\"git+https://github.com/user/repo.git\"),\n            \"https://github.com/user/repo\"\n        );\n        assert_eq!(\n            normalize_repo_url(\"git://github.com/user/repo\"),\n            \"https://github.com/user/repo\"\n        );\n        assert_eq!(\n            normalize_repo_url(\"https://github.com/user/repo\"),\n            \"https://github.com/user/repo\"\n        );\n    }\n\n    #[test]\n    fn test_repository_string_variant() {\n        let repo = Repository::String(\"git+https://github.com/user/repo.git\".to_string());\n        assert_eq!(repo.url(), Some(\"https://github.com/user/repo\".to_string()));\n    }\n\n    #[test]\n    fn test_repository_object_variant() {\n        let repo = Repository::Object {\n            url: Some(\"git://github.com/user/repo\".to_string()),\n        };\n        assert_eq!(repo.url(), Some(\"https://github.com/user/repo\".to_string()));\n    }\n\n    #[test]\n    fn test_repository_object_none() {\n        let repo = Repository::Object { url: None };\n        assert_eq!(repo.url(), None);\n    }\n\n    #[test]\n    fn test_license_field_string() {\n        let license = LicenseField::String(\"MIT\".to_string());\n        assert_eq!(license.as_string(), Some(\"MIT\".to_string()));\n    }\n\n    #[test]\n    fn test_license_field_object() {\n        let license = LicenseField::Object {\n            r#type: Some(\"Apache-2.0\".to_string()),\n        };\n        assert_eq!(license.as_string(), Some(\"Apache-2.0\".to_string()));\n    }\n\n    #[test]\n    fn test_license_field_object_none() {\n        let license = LicenseField::Object { r#type: None };\n        assert_eq!(license.as_string(), None);\n    }\n\n    #[test]\n    fn test_scoped_package_url_encoding() {\n        let package_name = \"@types/node\";\n        let encoded = if package_name.starts_with('@') {\n            package_name.replace('/', \"%2f\")\n        } else {\n            package_name.to_string()\n        };\n        assert_eq!(encoded, \"@types%2fnode\");\n    }\n\n    #[test]\n    fn test_normal_package_no_encoding() {\n        let package_name = \"lodash\";\n        let encoded = if package_name.starts_with('@') {\n            package_name.replace('/', \"%2f\")\n        } else {\n            package_name.to_string()\n        };\n        assert_eq!(encoded, \"lodash\");\n    }\n}\n","traces":[{"line":95,"address":[17972976,17972982,17972848],"length":1,"stats":{"Line":2}},{"line":98,"address":[14230279],"length":1,"stats":{"Line":2}},{"line":113,"address":[14214128],"length":1,"stats":{"Line":2}},{"line":114,"address":[13870158],"length":1,"stats":{"Line":2}},{"line":139,"address":[17972656],"length":1,"stats":{"Line":3}},{"line":140,"address":[13867831],"length":1,"stats":{"Line":4}},{"line":141,"address":[13867878],"length":1,"stats":{"Line":2}},{"line":142,"address":[15975694,15975664],"length":1,"stats":{"Line":8}},{"line":155,"address":[17973040],"length":1,"stats":{"Line":2}},{"line":156,"address":[14212199],"length":1,"stats":{"Line":5}},{"line":157,"address":[17973102],"length":1,"stats":{"Line":2}},{"line":158,"address":[14212217],"length":1,"stats":{"Line":4}},{"line":174,"address":[14212304],"length":1,"stats":{"Line":2}},{"line":178,"address":[14212388],"length":1,"stats":{"Line":2}},{"line":180,"address":[14212434],"length":1,"stats":{"Line":2}},{"line":183,"address":[17973330],"length":1,"stats":{"Line":2}},{"line":184,"address":[14212526],"length":1,"stats":{"Line":3}},{"line":187,"address":[14212503],"length":1,"stats":{"Line":3}},{"line":191,"address":[14232496],"length":1,"stats":{"Line":2}},{"line":192,"address":[14232501],"length":1,"stats":{"Line":2}},{"line":195,"address":[13461312,13461545,13461374,13461588,13461617,13462272,13463381],"length":1,"stats":{"Line":0}},{"line":197,"address":[14371083,14371231],"length":1,"stats":{"Line":0}},{"line":198,"address":[13432779,13432884],"length":1,"stats":{"Line":0}},{"line":200,"address":[13432749,13432819],"length":1,"stats":{"Line":0}},{"line":203,"address":[13432837,13432942],"length":1,"stats":{"Line":0}},{"line":205,"address":[14371143,14371585,14371672,14371858,14372877],"length":1,"stats":{"Line":0}},{"line":207,"address":[14372267,14372335],"length":1,"stats":{"Line":0}},{"line":208,"address":[13462935,13462836],"length":1,"stats":{"Line":0}},{"line":215,"address":[13432668,13434330,13434467,13433932],"length":1,"stats":{"Line":0}},{"line":218,"address":[14376016,14376000,14373387,14373305],"length":1,"stats":{"Line":0}},{"line":221,"address":[14373402],"length":1,"stats":{"Line":0}},{"line":224,"address":[13463980,13466486,13466480,13466256],"length":1,"stats":{"Line":0}},{"line":225,"address":[16004822],"length":1,"stats":{"Line":0}},{"line":227,"address":[14376189,14376448,14376120,14377119,14377254],"length":1,"stats":{"Line":0}},{"line":228,"address":[16005600,16005350],"length":1,"stats":{"Line":0}},{"line":229,"address":[16005628],"length":1,"stats":{"Line":0}},{"line":230,"address":[13467542,13467933],"length":1,"stats":{"Line":0}},{"line":233,"address":[13466446],"length":1,"stats":{"Line":0}},{"line":238,"address":[14373519],"length":1,"stats":{"Line":0}},{"line":241,"address":[16004560,16002497,16004576],"length":1,"stats":{"Line":0}},{"line":242,"address":[13466848,13468254,13468240,13464131,13466880],"length":1,"stats":{"Line":0}},{"line":245,"address":[16002543,16002649],"length":1,"stats":{"Line":0}},{"line":248,"address":[14375746,14377616,14375728,14373721,14377630],"length":1,"stats":{"Line":0}},{"line":249,"address":[14376281,14376272,14373738],"length":1,"stats":{"Line":0}},{"line":252,"address":[16004672,16002666,16002723,16004656],"length":1,"stats":{"Line":0}},{"line":255,"address":[16002738],"length":1,"stats":{"Line":0}},{"line":258,"address":[13466656,13464459],"length":1,"stats":{"Line":0}},{"line":260,"address":[16005176],"length":1,"stats":{"Line":0}},{"line":261,"address":[16005186,16006288,16006320],"length":1,"stats":{"Line":0}},{"line":262,"address":[13467165,13467120,13466707],"length":1,"stats":{"Line":0}},{"line":263,"address":[13438247],"length":1,"stats":{"Line":0}},{"line":264,"address":[13438266],"length":1,"stats":{"Line":0}},{"line":265,"address":[13468311,13467220,13468288],"length":1,"stats":{"Line":0}},{"line":267,"address":[14375700],"length":1,"stats":{"Line":0}},{"line":271,"address":[13436100],"length":1,"stats":{"Line":0}},{"line":272,"address":[14373943],"length":1,"stats":{"Line":0}},{"line":273,"address":[14373983],"length":1,"stats":{"Line":0}},{"line":274,"address":[16002919],"length":1,"stats":{"Line":0}},{"line":275,"address":[13464625],"length":1,"stats":{"Line":0}},{"line":276,"address":[14374103],"length":1,"stats":{"Line":0}},{"line":277,"address":[13435777],"length":1,"stats":{"Line":0}},{"line":278,"address":[14374183,14375904,14375920],"length":1,"stats":{"Line":0}},{"line":279,"address":[13464856],"length":1,"stats":{"Line":0}},{"line":282,"address":[13435988],"length":1,"stats":{"Line":0}},{"line":283,"address":[13436052],"length":1,"stats":{"Line":0}}],"covered":20,"coverable":65},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","nuget.rs"],"content":"//! # NuGet Registry Client\n//!\n//! This module implements a client for [NuGet Gallery](https://www.nuget.org),\n//! the package manager for .NET packages.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://api.nuget.org/v3`\n//! - **API Version**: v3 (NuGet Server API)\n//! - **Authentication**: API key for publishing (not needed for reading)\n//! - **CORS**: Limited support\n//!\n//! ## Rate Limiting\n//!\n//! NuGet does not publish hard rate limits but implements:\n//!\n//! - **Fair use policy**: No hard limits for normal usage\n//! - **CDN caching**: Most responses served from Azure CDN\n//! - **Best practice**: Use conditional requests\n//!\n//! ## API Endpoints Used\n//!\n//! ### Package Registration (Metadata)\n//!\n//! - **Endpoint**: `GET /registration5-semver1/{package-id-lower}/index.json`\n//! - **Response**: JSON with registration pages containing version metadata\n//! - **Fields**:\n//!   - `items[]`: Array of registration pages\n//!   - `items[].items[]`: Array of version entries (may require fetching page)\n//!   - `catalogEntry.version`: Version string\n//!   - `catalogEntry.description`: Package description\n//!   - `catalogEntry.projectUrl`: Project homepage\n//!   - `catalogEntry.licenseExpression`: SPDX license\n//!   - `catalogEntry.listed`: Whether version is listed (unlisted = hidden)\n//!   - `catalogEntry.deprecation`: Deprecation info if deprecated\n//!   - `catalogEntry.published`: RFC 3339 publish timestamp\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: Semver with optional prerelease (`1.0.0`, `2.0.0-preview.1`)\n//! - **Date format**: RFC 3339 (`2024-01-15T10:30:00+00:00`)\n//! - **Unlisted packages**: `listed: false` (hidden from search but downloadable)\n//! - **Deprecated packages**: `deprecation` object present\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **Package ID case**: IDs are case-insensitive but URLs use lowercase\n//! - **Paged responses**: Large packages may have items in separate pages\n//! - **Version ranges**: Uses NuGet version range syntax `[1.0.0,2.0.0)`\n//! - **Framework targeting**: Packages may target multiple .NET versions\n//! - **Dependency groups**: Dependencies organized by target framework\n//! - **Unlisted vs deprecated**: Unlisted hides from search; deprecated shows warning\n//! - **License**: Either `licenseExpression` (SPDX) or `licenseUrl` (legacy)\n//!\n//! ## Error Handling\n//!\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: 404 for not found\n//! - **Timeouts**: 10 second default timeout\n//!\n//! ## External References\n//!\n//! - [NuGet Server API](https://learn.microsoft.com/en-us/nuget/api/overview)\n//! - [Package Metadata Resource](https://learn.microsoft.com/en-us/nuget/api/registration-base-url-resource)\n//! - [NuGet Versioning](https://learn.microsoft.com/en-us/nuget/concepts/package-versioning)\n//! - [Version Ranges](https://learn.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\n\nuse super::http_client::create_shared_client;\nuse super::version_utils::is_prerelease_nuget;\nuse super::{Registry, VersionInfo};\n\n/// Client for the NuGet registry\npub struct NuGetRegistry {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl NuGetRegistry {\n    /// Constructs a NuGetRegistry configured to use the NuGet v3 API with the provided shared HTTP client.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::nuget::NuGetRegistry;\n    ///\n    /// let client = Arc::new(reqwest::Client::new());\n    /// let _registry = NuGetRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            base_url: \"https://api.nuget.org/v3\".to_string(),\n        }\n    }\n}\n\nimpl Default for NuGetRegistry {\n    /// Creates a `NuGetRegistry` configured with a shared HTTP client targeting the NuGet v3 API.\n    ///\n    /// Panics if creating the shared HTTP client fails.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::nuget::NuGetRegistry;\n    ///\n    /// let _reg = NuGetRegistry::default();\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n// NuGet API response structures\n#[derive(Debug, Deserialize)]\nstruct NuGetRegistrationResponse {\n    items: Vec<NuGetRegistrationPage>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct NuGetRegistrationPage {\n    items: Option<Vec<NuGetRegistrationLeaf>>,\n    #[serde(rename = \"@id\")]\n    id: String,\n}\n\n#[derive(Debug, Deserialize, Clone)]\nstruct NuGetRegistrationLeaf {\n    #[serde(rename = \"catalogEntry\")]\n    catalog_entry: NuGetCatalogEntry,\n}\n\n#[derive(Debug, Deserialize, Clone)]\nstruct NuGetCatalogEntry {\n    version: String,\n    description: Option<String>,\n    #[serde(rename = \"projectUrl\")]\n    project_url: Option<String>,\n    #[serde(rename = \"licenseExpression\")]\n    license_expression: Option<String>,\n    #[serde(rename = \"licenseUrl\")]\n    license_url: Option<String>,\n    #[serde(default)]\n    listed: Option<bool>,\n    #[serde(default)]\n    deprecation: Option<NuGetDeprecation>,\n    published: Option<String>,\n}\n\n#[derive(Debug, Deserialize, Clone)]\nstruct NuGetDeprecation {\n    #[serde(rename = \"message\")]\n    _message: Option<String>,\n    #[serde(rename = \"reasons\")]\n    _reasons: Option<Vec<String>>,\n}\n\nimpl Registry for NuGetRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo> {\n        // NuGet uses lowercase package IDs in URLs\n        let package_id = package_name.to_lowercase();\n\n        // Get registration index\n        let url = format!(\n            \"{}/registration5-semver1/{}/index.json\",\n            self.base_url, package_id\n        );\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch package info for {}: {}\",\n                package_name,\n                response.status()\n            );\n        }\n\n        let registration: NuGetRegistrationResponse = response.json().await?;\n\n        // Collect all versions from all pages\n        let mut all_versions: Vec<NuGetCatalogEntry> = Vec::new();\n\n        for page in &registration.items {\n            if let Some(items) = &page.items {\n                for leaf in items {\n                    all_versions.push(leaf.catalog_entry.clone());\n                }\n            } else {\n                // Need to fetch the page content\n                let page_response = self.client.get(&page.id).send().await?;\n                if page_response.status().is_success() {\n                    let page_data: NuGetRegistrationPage = page_response.json().await?;\n                    if let Some(items) = page_data.items {\n                        for leaf in items {\n                            all_versions.push(leaf.catalog_entry.clone());\n                        }\n                    }\n                }\n            }\n        }\n\n        // Sort versions descending\n        all_versions.sort_by(|a, b| {\n            match (\n                semver::Version::parse(&a.version),\n                semver::Version::parse(&b.version),\n            ) {\n                (Ok(va), Ok(vb)) => vb.cmp(&va),\n                _ => b.version.cmp(&a.version),\n            }\n        });\n\n        // Filter listed versions\n        let versions: Vec<String> = all_versions\n            .iter()\n            .filter(|entry| entry.listed.unwrap_or(true))\n            .map(|entry| entry.version.clone())\n            .collect();\n\n        // Find latest stable version\n        let latest_stable = versions.iter().find(|v| !is_prerelease_nuget(v)).cloned();\n\n        // Find latest prerelease\n        let latest_prerelease = versions.iter().find(|v| is_prerelease_nuget(v)).cloned();\n\n        // Get metadata from latest version\n        let latest_entry = all_versions.first();\n\n        // Check deprecation\n        let deprecated = latest_entry.and_then(|e| e.deprecation.as_ref()).is_some();\n\n        // Collect release dates\n        let release_dates: HashMap<String, DateTime<Utc>> = all_versions\n            .iter()\n            .filter_map(|e| {\n                e.published.as_ref().and_then(|time_str| {\n                    DateTime::parse_from_rfc3339(time_str)\n                        .ok()\n                        .map(|dt| (e.version.clone(), dt.with_timezone(&Utc)))\n                })\n            })\n            .collect();\n\n        Ok(VersionInfo {\n            latest: latest_stable,\n            latest_prerelease,\n            versions,\n            description: latest_entry.and_then(|e| e.description.clone()),\n            homepage: latest_entry.and_then(|e| e.project_url.clone()),\n            repository: None, // NuGet doesn't expose repository URL directly\n            license: latest_entry\n                .and_then(|e| e.license_expression.clone().or(e.license_url.clone())),\n            vulnerabilities: vec![], // Will be filled by OSV\n            deprecated,\n            yanked: false,\n            yanked_versions: vec![], // Not applicable to NuGet\n            release_dates,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_prerelease() {\n        assert!(is_prerelease_nuget(\"1.0.0-alpha\"));\n        assert!(is_prerelease_nuget(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_nuget(\"1.0.0-preview\"));\n        assert!(is_prerelease_nuget(\"1.0.0-rc.1\"));\n        assert!(is_prerelease_nuget(\"1.0.0-Alpha\"));\n        assert!(!is_prerelease_nuget(\"1.0.0\"));\n        assert!(!is_prerelease_nuget(\"2.0.0\"));\n    }\n}\n","traces":[{"line":97,"address":[13503412,13503280,13503418],"length":1,"stats":{"Line":2}},{"line":100,"address":[13532231],"length":1,"stats":{"Line":2}},{"line":117,"address":[13534432],"length":1,"stats":{"Line":0}},{"line":118,"address":[14162654],"length":1,"stats":{"Line":0}},{"line":167,"address":[14163136],"length":1,"stats":{"Line":2}},{"line":168,"address":[13506005],"length":1,"stats":{"Line":2}},{"line":171,"address":[14015392,14015600,14017395,14015643,14016289,14015664,14015685,14015454,14015714],"length":1,"stats":{"Line":0}},{"line":173,"address":[13997287],"length":1,"stats":{"Line":0}},{"line":176,"address":[14015764,14015871],"length":1,"stats":{"Line":0}},{"line":181,"address":[12749252],"length":1,"stats":{"Line":0}},{"line":183,"address":[14016752,14016823],"length":1,"stats":{"Line":0}},{"line":184,"address":[14735760,14735650],"length":1,"stats":{"Line":0}},{"line":191,"address":[12749275],"length":1,"stats":{"Line":0}},{"line":194,"address":[19659017],"length":1,"stats":{"Line":0}},{"line":196,"address":[14736622,14737961,14736720,14736736],"length":1,"stats":{"Line":0}},{"line":197,"address":[14019364,14021803,14019220],"length":1,"stats":{"Line":0}},{"line":198,"address":[14003523,14003589],"length":1,"stats":{"Line":0}},{"line":199,"address":[14740529],"length":1,"stats":{"Line":0}},{"line":203,"address":[12799349],"length":1,"stats":{"Line":0}},{"line":204,"address":[14741109,14741174],"length":1,"stats":{"Line":0}},{"line":205,"address":[14734493,14736804,14737114,14736834,14741222],"length":1,"stats":{"Line":0}},{"line":206,"address":[14000279],"length":1,"stats":{"Line":0}},{"line":207,"address":[14018759,14018644,14018894],"length":1,"stats":{"Line":0}},{"line":208,"address":[14737665,14737768],"length":1,"stats":{"Line":0}},{"line":216,"address":[14019429,14024394,14023584,14024259],"length":1,"stats":{"Line":0}},{"line":217,"address":[19664458,19664326,19664576],"length":1,"stats":{"Line":0}},{"line":218,"address":[14023654],"length":1,"stats":{"Line":0}},{"line":219,"address":[19664439,19664372],"length":1,"stats":{"Line":0}},{"line":221,"address":[14742332],"length":1,"stats":{"Line":0}},{"line":222,"address":[14742290,14742681],"length":1,"stats":{"Line":0}},{"line":227,"address":[14001210],"length":1,"stats":{"Line":0}},{"line":229,"address":[14023536,14023550,14019626],"length":1,"stats":{"Line":0}},{"line":230,"address":[14001381,14004803,14004768],"length":1,"stats":{"Line":0}},{"line":234,"address":[14019839,14023182,14023168,14019739],"length":1,"stats":{"Line":0}},{"line":237,"address":[19661148,19665502,19661048,19665488],"length":1,"stats":{"Line":0}},{"line":240,"address":[19661269,19661356],"length":1,"stats":{"Line":0}},{"line":243,"address":[19661387,19665344,19665353],"length":1,"stats":{"Line":0}},{"line":246,"address":[14020400],"length":1,"stats":{"Line":0}},{"line":248,"address":[14020493,14023456],"length":1,"stats":{"Line":0}},{"line":249,"address":[19665300,19665584],"length":1,"stats":{"Line":0}},{"line":250,"address":[14743162],"length":1,"stats":{"Line":0}},{"line":251,"address":[19665645],"length":1,"stats":{"Line":0}},{"line":252,"address":[14743232,14743255,14743206],"length":1,"stats":{"Line":0}},{"line":257,"address":[14002790],"length":1,"stats":{"Line":0}},{"line":258,"address":[14739147],"length":1,"stats":{"Line":0}},{"line":259,"address":[14020603],"length":1,"stats":{"Line":0}},{"line":260,"address":[19661691],"length":1,"stats":{"Line":0}},{"line":261,"address":[19661739,19665536,19665552],"length":1,"stats":{"Line":0}},{"line":262,"address":[14004848,14002466,14004832],"length":1,"stats":{"Line":0}},{"line":263,"address":[14020832],"length":1,"stats":{"Line":0}},{"line":265,"address":[14741792,14741712,14741736,14739424],"length":1,"stats":{"Line":0}},{"line":266,"address":[14020903],"length":1,"stats":{"Line":0}},{"line":269,"address":[14002675],"length":1,"stats":{"Line":0}},{"line":270,"address":[14002742],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":54},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","packagist.rs"],"content":"//! # Packagist Registry Client\n//!\n//! This module implements a client for [Packagist](https://packagist.org),\n//! the main Composer repository for PHP packages.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://repo.packagist.org`\n//! - **API Version**: p2 (Package API v2)\n//! - **Authentication**: Optional API token for private packages\n//! - **CORS**: Enabled for browser-based access\n//!\n//! ## Rate Limiting\n//!\n//! Packagist enforces rate limits to protect the service:\n//!\n//! - **Standard limit**: ~60 requests per minute per IP\n//! - **CDN caching**: Most package data served from CDN\n//! - **Best practice**: Use `If-Modified-Since` headers\n//!\n//! ## API Endpoints Used\n//!\n//! ### Fetch Package Info (p2 API)\n//!\n//! - **Endpoint**: `GET /p2/{vendor}/{package}.json`\n//! - **Response**: JSON with package metadata and all versions\n//! - **Fields**:\n//!   - `packages.{name}[]`: Array of version entries\n//!   - `version`: Version string\n//!   - `description`: Package description\n//!   - `homepage`: Homepage URL\n//!   - `license[]`: Array of license identifiers\n//!   - `source.url`: Repository URL\n//!   - `abandoned`: Deprecation status (bool or replacement package name)\n//!   - `time`: RFC 3339 release timestamp\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: Semver with optional `v` prefix and stability flags\n//! - **Date format**: RFC 3339 (`2024-01-15T10:30:00+00:00`)\n//! - **Dev versions**: `dev-master`, `dev-main`, `1.0.x-dev` (filtered out)\n//! - **Abandoned packages**: `abandoned` field is truthy (bool or string)\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **Package naming**: Must be `vendor/package` format (e.g., `laravel/framework`)\n//! - **Dev branches**: Prefixed with `dev-` or suffixed with `-dev` (excluded)\n//! - **Stability flags**: `@stable`, `@RC`, `@beta`, `@alpha`, `@dev`\n//! - **Version aliases**: May have `branch-alias` in `extra` field\n//! - **Abandoned packages**: Can specify replacement package name as string\n//! - **Multiple licenses**: Array of SPDX identifiers\n//!\n//! ## Error Handling\n//!\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: 404 for not found\n//! - **Invalid names**: Error returned if not `vendor/package` format\n//! - **Timeouts**: 10 second default timeout\n//!\n//! ## External References\n//!\n//! - [Packagist API](https://packagist.org/apidoc)\n//! - [Composer Version Constraints](https://getcomposer.org/doc/articles/versions.md)\n//! - [Composer Repositories](https://getcomposer.org/doc/05-repositories.md)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\n\nuse super::http_client::create_shared_client;\nuse super::version_utils::is_prerelease_php;\nuse super::{Registry, VersionInfo};\n\n/// Client for the Packagist registry\npub struct PackagistRegistry {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl PackagistRegistry {\n    /// Creates a PackagistRegistry configured with the given shared HTTP client and the default Packagist API base URL.\n    ///\n    /// The registry's base URL is set to `https://repo.packagist.org`.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::packagist::PackagistRegistry;\n    ///\n    /// let client = Arc::new(reqwest::Client::new());\n    /// let registry = PackagistRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            base_url: \"https://repo.packagist.org\".to_string(),\n        }\n    }\n}\n\nimpl Default for PackagistRegistry {\n    /// Create a PackagistRegistry configured with a shared HTTP client and the default Packagist API base URL.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::packagist::PackagistRegistry;\n    ///\n    /// let _registry = PackagistRegistry::default();\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n// Packagist API response structures\n#[derive(Debug, Deserialize)]\nstruct PackagistResponse {\n    packages: HashMap<String, Vec<VersionEntry>>,\n}\n\n#[derive(Debug, Clone, Deserialize)]\nstruct VersionEntry {\n    version: String,\n    description: Option<String>,\n    homepage: Option<String>,\n    license: Option<Vec<String>>,\n    source: Option<SourceInfo>,\n    /// Can be bool or string (replacement package name). We only care if it's truthy.\n    abandoned: Option<serde_json::Value>,\n    /// Release time\n    time: Option<String>,\n}\n\n#[derive(Debug, Clone, Deserialize)]\nstruct SourceInfo {\n    url: Option<String>,\n}\n\nimpl Registry for PackagistRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo> {\n        // Package name format: vendor/package\n        if !package_name.contains('/') {\n            anyhow::bail!(\n                \"Invalid package name: {} (expected vendor/package)\",\n                package_name\n            );\n        }\n\n        let url = format!(\"{}/p2/{}.json\", self.base_url, package_name);\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch package info for {}: {}\",\n                package_name,\n                response.status()\n            );\n        }\n\n        let packagist_response: PackagistResponse = response.json().await?;\n\n        // Get versions for this package\n        let entries = packagist_response\n            .packages\n            .get(package_name)\n            .cloned()\n            .unwrap_or_default();\n\n        // Filter out dev versions and sort\n        let mut versions: Vec<String> = entries\n            .iter()\n            .filter(|e| !is_dev_version(&e.version))\n            .map(|e| e.version.clone())\n            .collect();\n\n        // Sort versions in descending order\n        versions.sort_by(|a, b| compare_packagist_versions(b, a));\n\n        // Find latest stable version\n        let latest_stable = versions.iter().find(|v| !is_prerelease_php(v)).cloned();\n\n        // Find latest prerelease\n        let latest_prerelease = versions.iter().find(|v| is_prerelease_php(v)).cloned();\n\n        // Get metadata from first (latest) entry\n        let latest_entry = entries.first();\n\n        let description = latest_entry.and_then(|e| e.description.clone());\n        let homepage = latest_entry.and_then(|e| e.homepage.clone());\n        let license = latest_entry\n            .and_then(|e| e.license.as_ref())\n            .and_then(|l| l.first())\n            .cloned();\n        let repository = latest_entry\n            .and_then(|e| e.source.as_ref())\n            .and_then(|s| s.url.clone())\n            .map(|url| normalize_repo_url(&url));\n\n        // Check if deprecated/abandoned (truthy value = abandoned)\n        let deprecated = latest_entry\n            .and_then(|e| e.abandoned.as_ref())\n            .is_some_and(|v| !matches!(v, serde_json::Value::Bool(false)));\n\n        // Collect release dates\n        let release_dates: HashMap<String, DateTime<Utc>> = entries\n            .iter()\n            .filter_map(|e| {\n                e.time.as_ref().and_then(|time_str| {\n                    DateTime::parse_from_rfc3339(time_str)\n                        .ok()\n                        .map(|dt| (e.version.clone(), dt.with_timezone(&Utc)))\n                })\n            })\n            .collect();\n\n        Ok(VersionInfo {\n            latest: latest_stable,\n            latest_prerelease,\n            versions,\n            description,\n            homepage,\n            repository,\n            license,\n            vulnerabilities: vec![], // TODO: Check PHP Security Advisories\n            deprecated,\n            yanked: false,\n            yanked_versions: vec![], // Not applicable to Packagist\n            release_dates,\n        })\n    }\n}\n\n/// Check if a version is a dev version (e.g., dev-master, dev-main)\nfn is_dev_version(version: &str) -> bool {\n    version.starts_with(\"dev-\") || version.ends_with(\"-dev\")\n}\n\n/// Compare Packagist versions for sorting\nfn compare_packagist_versions(a: &str, b: &str) -> std::cmp::Ordering {\n    // Strip 'v' prefix if present\n    let a_stripped = a.strip_prefix('v').unwrap_or(a);\n    let b_stripped = b.strip_prefix('v').unwrap_or(b);\n\n    // Try parsing as semver\n    match (\n        semver::Version::parse(a_stripped),\n        semver::Version::parse(b_stripped),\n    ) {\n        (Ok(va), Ok(vb)) => va.cmp(&vb),\n        _ => {\n            // Fallback to string comparison\n            compare_version_strings(a_stripped, b_stripped)\n        }\n    }\n}\n\n/// Simple version string comparison\nfn compare_version_strings(a: &str, b: &str) -> std::cmp::Ordering {\n    let parse_parts = |s: &str| -> Vec<u64> {\n        s.split(|c: char| !c.is_ascii_digit())\n            .filter_map(|p| p.parse().ok())\n            .collect()\n    };\n\n    let parts_a = parse_parts(a);\n    let parts_b = parse_parts(b);\n\n    for (pa, pb) in parts_a.iter().zip(parts_b.iter()) {\n        match pa.cmp(pb) {\n            std::cmp::Ordering::Equal => continue,\n            other => return other,\n        }\n    }\n\n    parts_a.len().cmp(&parts_b.len())\n}\n\n/// Normalize repository URL\nfn normalize_repo_url(url: &str) -> String {\n    let url = url\n        .strip_prefix(\"git+\")\n        .unwrap_or(url)\n        .strip_suffix(\".git\")\n        .unwrap_or(url);\n\n    if url.starts_with(\"git://\") {\n        url.replace(\"git://\", \"https://\")\n    } else {\n        url.to_string()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_dev_version() {\n        assert!(is_dev_version(\"dev-master\"));\n        assert!(is_dev_version(\"dev-main\"));\n        assert!(is_dev_version(\"1.0.x-dev\"));\n        assert!(!is_dev_version(\"1.0.0\"));\n        assert!(!is_dev_version(\"v2.3.4\"));\n    }\n\n    #[test]\n    fn test_is_prerelease() {\n        assert!(is_prerelease_php(\"1.0.0-alpha\"));\n        assert!(is_prerelease_php(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_php(\"1.0.0-RC1\"));\n        assert!(is_prerelease_php(\"dev-master\"));\n        assert!(!is_prerelease_php(\"1.0.0\"));\n        assert!(!is_prerelease_php(\"v2.3.4\"));\n    }\n\n    #[test]\n    fn test_compare_packagist_versions() {\n        use std::cmp::Ordering;\n\n        assert_eq!(compare_packagist_versions(\"1.0.0\", \"2.0.0\"), Ordering::Less);\n        assert_eq!(\n            compare_packagist_versions(\"v2.0.0\", \"v1.0.0\"),\n            Ordering::Greater\n        );\n        assert_eq!(\n            compare_packagist_versions(\"1.0.0\", \"1.0.0\"),\n            Ordering::Equal\n        );\n    }\n\n    #[test]\n    fn test_normalize_repo_url() {\n        assert_eq!(\n            normalize_repo_url(\"git+https://github.com/user/repo.git\"),\n            \"https://github.com/user/repo\"\n        );\n        assert_eq!(\n            normalize_repo_url(\"git://github.com/user/repo\"),\n            \"https://github.com/user/repo\"\n        );\n        assert_eq!(\n            normalize_repo_url(\"https://github.com/user/repo\"),\n            \"https://github.com/user/repo\"\n        );\n    }\n}\n","traces":[{"line":97,"address":[14025504,14025636,14025642],"length":1,"stats":{"Line":2}},{"line":100,"address":[14007239],"length":1,"stats":{"Line":2}},{"line":115,"address":[14011472],"length":1,"stats":{"Line":0}},{"line":116,"address":[14011486],"length":1,"stats":{"Line":0}},{"line":145,"address":[14007040],"length":1,"stats":{"Line":2}},{"line":146,"address":[16704053],"length":1,"stats":{"Line":2}},{"line":149,"address":[15564928,15565161,15567041,15565204,15565233,15564990,15565983],"length":1,"stats":{"Line":0}},{"line":151,"address":[13388559,13388411],"length":1,"stats":{"Line":0}},{"line":152,"address":[14405246,14405165],"length":1,"stats":{"Line":0}},{"line":158,"address":[14423496,14423757],"length":1,"stats":{"Line":0}},{"line":160,"address":[15567009,15565831,15565744,15566017,15565191],"length":1,"stats":{"Line":0}},{"line":162,"address":[13389774,13389706],"length":1,"stats":{"Line":0}},{"line":163,"address":[13389932,13389825],"length":1,"stats":{"Line":0}},{"line":170,"address":[14428544,14425115,14424756,14423372,14425255],"length":1,"stats":{"Line":0}},{"line":175,"address":[15567457],"length":1,"stats":{"Line":0}},{"line":180,"address":[14407521],"length":1,"stats":{"Line":0}},{"line":182,"address":[14411086,14411072,14407667],"length":1,"stats":{"Line":0}},{"line":183,"address":[14425998,14429043,14429008],"length":1,"stats":{"Line":0}},{"line":187,"address":[15570885,15567900,15570848,15567808],"length":1,"stats":{"Line":0}},{"line":190,"address":[14426171,14429422,14429408,14426254],"length":1,"stats":{"Line":0}},{"line":193,"address":[14408187,14410798,14410784,14408087],"length":1,"stats":{"Line":0}},{"line":196,"address":[15568312,15568380],"length":1,"stats":{"Line":0}},{"line":198,"address":[14410464,14408405,14408461,14410480],"length":1,"stats":{"Line":0}},{"line":199,"address":[15570320,15568473,15568531,15570336],"length":1,"stats":{"Line":0}},{"line":201,"address":[14411049,14408547,14411040],"length":1,"stats":{"Line":0}},{"line":202,"address":[14410697,14408614,14410688],"length":1,"stats":{"Line":0}},{"line":205,"address":[14410841,14410832,14408667],"length":1,"stats":{"Line":0}},{"line":206,"address":[14427025,14428864,14428880],"length":1,"stats":{"Line":0}},{"line":207,"address":[14428635,14428608,14427044],"length":1,"stats":{"Line":0}},{"line":210,"address":[14427165],"length":1,"stats":{"Line":0}},{"line":211,"address":[14410617,14408796,14410608],"length":1,"stats":{"Line":0}},{"line":212,"address":[15570528,15570538,15568822],"length":1,"stats":{"Line":0}},{"line":215,"address":[13392134],"length":1,"stats":{"Line":0}},{"line":217,"address":[14408956,14410864],"length":1,"stats":{"Line":0}},{"line":218,"address":[14429188,14429456],"length":1,"stats":{"Line":0}},{"line":219,"address":[13394410],"length":1,"stats":{"Line":0}},{"line":220,"address":[14429517],"length":1,"stats":{"Line":0}},{"line":221,"address":[13394454,13394480,13394503],"length":1,"stats":{"Line":0}},{"line":226,"address":[15569395],"length":1,"stats":{"Line":0}},{"line":227,"address":[14427292],"length":1,"stats":{"Line":0}},{"line":228,"address":[13392268],"length":1,"stats":{"Line":0}},{"line":229,"address":[15569028],"length":1,"stats":{"Line":0}},{"line":230,"address":[14427412],"length":1,"stats":{"Line":0}},{"line":231,"address":[14409164],"length":1,"stats":{"Line":0}},{"line":232,"address":[13392428],"length":1,"stats":{"Line":0}},{"line":233,"address":[14409244],"length":1,"stats":{"Line":0}},{"line":234,"address":[14409284],"length":1,"stats":{"Line":0}},{"line":237,"address":[14427635],"length":1,"stats":{"Line":0}},{"line":238,"address":[15569347],"length":1,"stats":{"Line":0}},{"line":244,"address":[16704256],"length":1,"stats":{"Line":2}},{"line":245,"address":[14007143],"length":1,"stats":{"Line":2}},{"line":249,"address":[12580143,12579992,12579088],"length":1,"stats":{"Line":2}},{"line":251,"address":[12579147],"length":1,"stats":{"Line":2}},{"line":252,"address":[16705795],"length":1,"stats":{"Line":2}},{"line":255,"address":[12579461,12579598],"length":1,"stats":{"Line":4}},{"line":256,"address":[14008774],"length":1,"stats":{"Line":2}},{"line":257,"address":[16705929],"length":1,"stats":{"Line":2}},{"line":259,"address":[12579629],"length":1,"stats":{"Line":2}},{"line":262,"address":[14008996,14009414],"length":1,"stats":{"Line":0}},{"line":268,"address":[14008470,14008476,14007648],"length":1,"stats":{"Line":0}},{"line":269,"address":[14411792],"length":1,"stats":{"Line":0}},{"line":270,"address":[13395197,13395057,13395184],"length":1,"stats":{"Line":0}},{"line":271,"address":[14430259,14430156,14430240],"length":1,"stats":{"Line":0}},{"line":275,"address":[14026040],"length":1,"stats":{"Line":0}},{"line":276,"address":[12578397],"length":1,"stats":{"Line":0}},{"line":278,"address":[14007920,14007840],"length":1,"stats":{"Line":0}},{"line":279,"address":[14008231,14008409],"length":1,"stats":{"Line":0}},{"line":281,"address":[16705536],"length":1,"stats":{"Line":0}},{"line":285,"address":[14026533],"length":1,"stats":{"Line":0}},{"line":289,"address":[14007376],"length":1,"stats":{"Line":2}},{"line":292,"address":[14025748],"length":1,"stats":{"Line":2}},{"line":294,"address":[12578114],"length":1,"stats":{"Line":2}},{"line":296,"address":[12578146],"length":1,"stats":{"Line":2}},{"line":297,"address":[14007598],"length":1,"stats":{"Line":2}},{"line":299,"address":[14007575],"length":1,"stats":{"Line":2}}],"covered":19,"coverable":75},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","pub_dev.rs"],"content":"//! # pub.dev Registry Client\n//!\n//! This module implements a client for [pub.dev](https://pub.dev),\n//! the official package repository for Dart and Flutter packages.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://pub.dev/api`\n//! - **API Version**: REST API (stable)\n//! - **Authentication**: OAuth2 for private packages (not implemented)\n//! - **CORS**: Enabled for browser-based access\n//!\n//! ## Rate Limiting\n//!\n//! pub.dev enforces rate limits:\n//!\n//! - **Standard limit**: ~100 requests per minute per IP\n//! - **CDN caching**: Responses cached at edge\n//! - **Best practice**: Respect `Cache-Control` headers\n//!\n//! ## API Endpoints Used\n//!\n//! ### Fetch Package Info\n//!\n//! - **Endpoint**: `GET /api/packages/{package-name}`\n//! - **Response**: JSON with package metadata and all versions\n//! - **Fields**:\n//!   - `name`: Package name\n//!   - `latest`: Latest version info with pubspec\n//!   - `versions[]`: Array of all versions\n//!   - `versions[].version`: Version string\n//!   - `versions[].pubspec`: Parsed pubspec.yaml contents\n//!   - `versions[].retracted`: Whether version is retracted\n//!   - `versions[].published`: RFC 3339 publish timestamp\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: Semver (`1.0.0`, `2.0.0-dev.1`)\n//! - **Date format**: RFC 3339 (`2024-01-15T10:30:00.000Z`)\n//! - **Retracted versions**: `retracted: true` (equivalent to yanked)\n//! - **Discontinued packages**: `discontinued: true` in pubspec\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **SDK constraints**: `environment.sdk` in pubspec specifies Dart version\n//! - **Flutter constraints**: `environment.flutter` for Flutter SDK version\n//! - **Retracted versions**: Similar to yanked; still downloadable with warning\n//! - **Discontinued packages**: Marked in pubspec, may suggest replacement\n//! - **Null safety**: Packages may indicate null-safety migration status\n//! - **Platform support**: Flutter packages may specify platform compatibility\n//!\n//! ## Error Handling\n//!\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: 404 for not found\n//! - **Timeouts**: 10 second default timeout\n//!\n//! ## External References\n//!\n//! - [pub.dev API](https://pub.dev/help/api)\n//! - [Pubspec Format](https://dart.dev/tools/pub/pubspec)\n//! - [Version Constraints](https://dart.dev/tools/pub/dependencies#version-constraints)\n//! - [Package Scoring](https://pub.dev/help/scoring)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\n\nuse super::http_client::create_shared_client;\nuse super::version_utils::is_prerelease_dart;\nuse super::{Registry, VersionInfo};\n\n/// Client for the pub.dev registry\npub struct PubDevRegistry {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl PubDevRegistry {\n    /// Creates a `PubDevRegistry` configured to use the given shared HTTP client.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::pub_dev::PubDevRegistry;\n    ///\n    /// let client = Arc::new(reqwest::Client::new());\n    /// let _registry = PubDevRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            base_url: \"https://pub.dev/api\".to_string(),\n        }\n    }\n}\n\nimpl Default for PubDevRegistry {\n    /// Constructs a PubDevRegistry using a shared HTTP client created by `create_shared_client`.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::pub_dev::PubDevRegistry;\n    ///\n    /// let registry = PubDevRegistry::default();\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n// pub.dev API response structures\n#[derive(Debug, Deserialize)]\nstruct PubPackageResponse {\n    #[serde(rename = \"name\")]\n    _name: String,\n    latest: PubVersionInfo,\n    versions: Vec<PubVersionInfo>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct PubVersionInfo {\n    version: String,\n    pubspec: PubPubspec,\n    #[serde(default)]\n    retracted: bool,\n    published: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct PubPubspec {\n    description: Option<String>,\n    homepage: Option<String>,\n    repository: Option<String>,\n    #[serde(default)]\n    discontinued: bool,\n}\n\nimpl Registry for PubDevRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo> {\n        let url = format!(\"{}/packages/{}\", self.base_url, package_name);\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch package info for {}: {}\",\n                package_name,\n                response.status()\n            );\n        }\n\n        let pkg: PubPackageResponse = response.json().await?;\n\n        // Get all versions (not retracted)\n        let versions: Vec<String> = pkg\n            .versions\n            .iter()\n            .filter(|v| !v.retracted)\n            .map(|v| v.version.clone())\n            .collect();\n\n        // Find latest stable version\n        let latest_stable = versions\n            .iter()\n            .find(|v| !is_prerelease_dart(v))\n            .cloned()\n            .or_else(|| Some(pkg.latest.version.clone()));\n\n        // Find latest prerelease\n        let latest_prerelease = versions.iter().find(|v| is_prerelease_dart(v)).cloned();\n\n        // Collect release dates\n        let release_dates: HashMap<String, DateTime<Utc>> = pkg\n            .versions\n            .iter()\n            .filter_map(|v| {\n                v.published.as_ref().and_then(|time_str| {\n                    DateTime::parse_from_rfc3339(time_str)\n                        .ok()\n                        .map(|dt| (v.version.clone(), dt.with_timezone(&Utc)))\n                })\n            })\n            .collect();\n\n        Ok(VersionInfo {\n            latest: latest_stable,\n            latest_prerelease,\n            versions,\n            description: pkg.latest.pubspec.description,\n            homepage: pkg.latest.pubspec.homepage,\n            repository: pkg.latest.pubspec.repository,\n            license: None,           // pub.dev doesn't expose license in API\n            vulnerabilities: vec![], // Will be filled by OSV\n            deprecated: pkg.latest.pubspec.discontinued,\n            yanked: pkg.latest.retracted,\n            yanked_versions: vec![], // Not applicable to pub.dev\n            release_dates,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_prerelease() {\n        assert!(is_prerelease_dart(\"1.0.0-dev.1\"));\n        assert!(is_prerelease_dart(\"1.0.0-alpha\"));\n        assert!(is_prerelease_dart(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_dart(\"1.0.0-rc.1\"));\n        assert!(!is_prerelease_dart(\"1.0.0\"));\n        assert!(!is_prerelease_dart(\"2.0.0\"));\n    }\n}\n","traces":[{"line":94,"address":[16704112,16704240,16704246],"length":1,"stats":{"Line":2}},{"line":97,"address":[13124535],"length":1,"stats":{"Line":2}},{"line":112,"address":[13402688],"length":1,"stats":{"Line":0}},{"line":113,"address":[13402702],"length":1,"stats":{"Line":0}},{"line":145,"address":[13401344],"length":1,"stats":{"Line":2}},{"line":146,"address":[13401349],"length":1,"stats":{"Line":2}},{"line":149,"address":[13430322,13430304],"length":1,"stats":{"Line":0}},{"line":150,"address":[12585965,12585811],"length":1,"stats":{"Line":0}},{"line":152,"address":[13405968,13407327,13405732,13406257,13406059],"length":1,"stats":{"Line":0}},{"line":154,"address":[13406742,13406674],"length":1,"stats":{"Line":0}},{"line":155,"address":[12587028],"length":1,"stats":{"Line":0}},{"line":162,"address":[15257794],"length":1,"stats":{"Line":0}},{"line":165,"address":[12587898],"length":1,"stats":{"Line":0}},{"line":168,"address":[13410400,13407960,13410410],"length":1,"stats":{"Line":0}},{"line":169,"address":[13379075,13381584,13381619],"length":1,"stats":{"Line":0}},{"line":173,"address":[13408198,13408073],"length":1,"stats":{"Line":0}},{"line":175,"address":[13410304,13410318,13408214],"length":1,"stats":{"Line":0}},{"line":177,"address":[13381648,13381667,13379334],"length":1,"stats":{"Line":0}},{"line":180,"address":[13379377,13381424,13381438,13379465],"length":1,"stats":{"Line":0}},{"line":183,"address":[19221276],"length":1,"stats":{"Line":0}},{"line":186,"address":[13379679,13381504],"length":1,"stats":{"Line":0}},{"line":187,"address":[13410468,13410656],"length":1,"stats":{"Line":0}},{"line":188,"address":[13381770],"length":1,"stats":{"Line":0}},{"line":189,"address":[12590717],"length":1,"stats":{"Line":0}},{"line":190,"address":[13381815,13381863,13381840],"length":1,"stats":{"Line":0}},{"line":195,"address":[12589136],"length":1,"stats":{"Line":0}},{"line":196,"address":[12588685],"length":1,"stats":{"Line":0}},{"line":197,"address":[13379769],"length":1,"stats":{"Line":0}},{"line":198,"address":[13379809],"length":1,"stats":{"Line":0}},{"line":199,"address":[19221541],"length":1,"stats":{"Line":0}},{"line":200,"address":[13408817],"length":1,"stats":{"Line":0}},{"line":201,"address":[13379929],"length":1,"stats":{"Line":0}},{"line":202,"address":[13408907],"length":1,"stats":{"Line":0}},{"line":203,"address":[13379987],"length":1,"stats":{"Line":0}},{"line":204,"address":[12589002],"length":1,"stats":{"Line":0}},{"line":205,"address":[13408989],"length":1,"stats":{"Line":0}},{"line":206,"address":[13380072],"length":1,"stats":{"Line":0}},{"line":207,"address":[13380140],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":38},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","pypi.rs"],"content":"//! # PyPI Registry Client\n//!\n//! This module implements a client for [PyPI](https://pypi.org) (Python Package Index),\n//! the official third-party software repository for Python packages.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://pypi.org/pypi`\n//! - **API Version**: JSON API (stable)\n//! - **Authentication**: Not required for public packages\n//! - **CORS**: Enabled for browser-based access\n//!\n//! ## Rate Limiting\n//!\n//! PyPI enforces rate limits to protect the service:\n//!\n//! - **Standard limit**: ~20 requests per second per IP\n//! - **Blocking**: Aggressive crawlers may be blocked\n//! - **Best practice**: Use `If-Modified-Since` headers for caching\n//! - **CDN**: Responses are served via Fastly CDN\n//!\n//! ## API Endpoints Used\n//!\n//! ### Fetch Package Info\n//!\n//! - **Endpoint**: `GET /pypi/{package-name}/json`\n//! - **Response**: JSON with project metadata and all releases\n//! - **Fields**:\n//!   - `info.version`: Latest version\n//!   - `info.summary`: Package description\n//!   - `info.home_page`: Homepage URL\n//!   - `info.license`: License string\n//!   - `info.project_urls`: Map of URL types to URLs\n//!   - `info.classifiers`: Trove classifiers for categorization\n//!   - `releases{}`: Map of version string to release files\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: PEP 440 compliant (`1.0.0`, `1.0.0a1`, `1.0.0.dev1`)\n//! - **Date format**: ISO 8601 without timezone (`2024-01-15T10:30:00`)\n//! - **Yanked releases**: `yanked: true` in release file info\n//! - **Deprecated projects**: `Development Status :: 7 - Inactive` classifier\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **Name normalization**: Case-insensitive; underscores, hyphens, and dots\n//!   are all equivalent per [PEP 503](https://peps.python.org/pep-0503/)\n//!   (`Flask` = `flask` = `FLASK`, `typing_extensions` = `typing-extensions`)\n//! - **Project vs release metadata**: Some fields are project-level, others per-release\n//! - **Classifiers**: Used for deprecation status, Python version support, etc.\n//! - **requires_python**: Version constraint for Python interpreter (not exposed)\n//! - **Yanked releases**: Still downloadable but with warning\n//! - **Version ordering**: Uses PEP 440 ordering, not simple semver\n//!\n//! ## Error Handling\n//!\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: 404 for not found\n//! - **Timeouts**: 10 second default timeout\n//!\n//! ## External References\n//!\n//! - [PyPI JSON API](https://docs.pypi.org/api/json/)\n//! - [PEP 503 - Simple Repository API](https://peps.python.org/pep-0503/)\n//! - [PEP 440 - Version Identification](https://peps.python.org/pep-0440/)\n//! - [Trove Classifiers](https://pypi.org/classifiers/)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, NaiveDateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\n\nuse super::http_client::create_shared_client;\nuse super::version_utils::is_prerelease_python;\nuse super::{Registry, VersionInfo};\n\n/// Client for the PyPI registry\npub struct PyPiRegistry {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl PyPiRegistry {\n    /// Constructs a PyPiRegistry using the provided shared HTTP client.\n    ///\n    /// The returned registry is configured with the default PyPI API base URL (`https://pypi.org/pypi`).\n    ///\n    /// # Parameters\n    ///\n    /// - `client` — shared HTTP client used for performing requests to the PyPI API.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::pypi::PyPiRegistry;\n    /// use dependi_lsp::registries::http_client::create_shared_client;\n    ///\n    /// let client = create_shared_client().expect(\"failed to create client\");\n    /// let registry = PyPiRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            base_url: \"https://pypi.org/pypi\".to_string(),\n        }\n    }\n}\n\nimpl Default for PyPiRegistry {\n    /// Creates a PyPiRegistry configured with a shared HTTP client and the default PyPI base URL.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::pypi::PyPiRegistry;\n    ///\n    /// let _registry = PyPiRegistry::default();\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n// PyPI API response structures\n#[derive(Debug, Deserialize)]\nstruct PyPiResponse {\n    info: PackageInfo,\n    releases: HashMap<String, Vec<ReleaseFile>>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct PackageInfo {\n    /// Latest version\n    version: String,\n    /// Package description\n    summary: Option<String>,\n    /// Homepage URL\n    home_page: Option<String>,\n    /// License string\n    license: Option<String>,\n    /// Project URLs (may contain Repository, Homepage, etc.)\n    project_urls: Option<HashMap<String, String>>,\n    /// Classifiers (can be used to detect deprecated packages)\n    classifiers: Option<Vec<String>>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct ReleaseFile {\n    /// Whether this file has been yanked\n    yanked: Option<bool>,\n    /// Upload time for this file (ISO 8601 format without timezone)\n    upload_time: Option<String>,\n}\n\nimpl Registry for PyPiRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo> {\n        // Normalize package name (PyPI is case-insensitive, uses lowercase)\n        let normalized_name = normalize_package_name(package_name);\n\n        let url = format!(\"{}/{}/json\", self.base_url, normalized_name);\n\n        let response = self.client.get(&url).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch package info for {}: {}\",\n                package_name,\n                response.status()\n            );\n        }\n\n        let pypi_response: PyPiResponse = response.json().await?;\n\n        // Get all versions sorted by semver (newest first)\n        let mut versions: Vec<String> = pypi_response\n            .releases\n            .iter()\n            .filter(|(_, files)| {\n                // Filter out yanked versions\n                !files.iter().any(|f| f.yanked.unwrap_or(false))\n            })\n            .map(|(version, _)| version.clone())\n            .collect();\n\n        // Sort versions in descending order\n        versions.sort_by(|a, b| compare_python_versions(b, a));\n\n        // Find latest stable version (non-prerelease)\n        let latest_stable = versions\n            .iter()\n            .find(|v| !is_prerelease_python(v))\n            .cloned()\n            .or_else(|| Some(pypi_response.info.version.clone()));\n\n        // Find latest prerelease\n        let latest_prerelease = versions.iter().find(|v| is_prerelease_python(v)).cloned();\n\n        // Extract repository URL from project_urls\n        let repository = pypi_response.info.project_urls.as_ref().and_then(|urls| {\n            urls.get(\"Repository\")\n                .or_else(|| urls.get(\"Source\"))\n                .or_else(|| urls.get(\"Source Code\"))\n                .or_else(|| urls.get(\"GitHub\"))\n                .cloned()\n        });\n\n        // Extract homepage\n        let homepage = pypi_response.info.home_page.clone().or_else(|| {\n            pypi_response\n                .info\n                .project_urls\n                .as_ref()\n                .and_then(|urls| urls.get(\"Homepage\").cloned())\n        });\n\n        // Check if deprecated (via classifiers)\n        let deprecated = pypi_response\n            .info\n            .classifiers\n            .as_ref()\n            .is_some_and(|classifiers| {\n                classifiers\n                    .iter()\n                    .any(|c| c.contains(\"Development Status :: 7 - Inactive\"))\n            });\n\n        // Extract release dates from releases (use the first file's upload_time for each version)\n        let release_dates: HashMap<String, DateTime<Utc>> = pypi_response\n            .releases\n            .iter()\n            .filter_map(|(version, files)| {\n                files\n                    .first()\n                    .and_then(|f| f.upload_time.as_ref())\n                    .and_then(|time_str| parse_pypi_datetime(time_str))\n                    .map(|dt| (version.clone(), dt))\n            })\n            .collect();\n\n        Ok(VersionInfo {\n            latest: latest_stable,\n            latest_prerelease,\n            versions,\n            description: pypi_response.info.summary,\n            homepage,\n            repository,\n            license: pypi_response.info.license,\n            vulnerabilities: vec![], // TODO: Integrate Safety/OSV\n            deprecated,\n            yanked: false,\n            yanked_versions: vec![], // Not applicable to PyPI\n            release_dates,\n        })\n    }\n}\n\n/// Parse PyPI datetime format (ISO 8601 without timezone, assumed UTC)\nfn parse_pypi_datetime(s: &str) -> Option<DateTime<Utc>> {\n    NaiveDateTime::parse_from_str(s, \"%Y-%m-%dT%H:%M:%S\")\n        .or_else(|_| NaiveDateTime::parse_from_str(s, \"%Y-%m-%d %H:%M:%S\"))\n        .ok()\n        .map(|naive| naive.and_utc())\n}\n\n/// Normalize Python package name according to PEP 503\n/// - Lowercase\n/// - Replace underscores and dots with hyphens\nfn normalize_package_name(name: &str) -> String {\n    name.to_lowercase().replace(['_', '.'], \"-\")\n}\n\n/// Compare Python versions for sorting\n/// Returns Ordering for descending sort (newer versions first)\nfn compare_python_versions(a: &str, b: &str) -> std::cmp::Ordering {\n    // Try parsing as semver first\n    match (semver::Version::parse(a), semver::Version::parse(b)) {\n        (Ok(va), Ok(vb)) => va.cmp(&vb),\n        _ => {\n            // Fallback to simple string comparison with version-aware logic\n            compare_version_strings(a, b)\n        }\n    }\n}\n\n/// Simple version string comparison\nfn compare_version_strings(a: &str, b: &str) -> std::cmp::Ordering {\n    let parse_parts = |s: &str| -> Vec<u64> {\n        s.split(|c: char| !c.is_ascii_digit())\n            .filter_map(|p| p.parse().ok())\n            .collect()\n    };\n\n    let parts_a = parse_parts(a);\n    let parts_b = parse_parts(b);\n\n    for (pa, pb) in parts_a.iter().zip(parts_b.iter()) {\n        match pa.cmp(pb) {\n            std::cmp::Ordering::Equal => continue,\n            other => return other,\n        }\n    }\n\n    parts_a.len().cmp(&parts_b.len())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_normalize_package_name() {\n        assert_eq!(normalize_package_name(\"Flask\"), \"flask\");\n        assert_eq!(normalize_package_name(\"ruamel.yaml\"), \"ruamel-yaml\");\n        assert_eq!(\n            normalize_package_name(\"typing_extensions\"),\n            \"typing-extensions\"\n        );\n        assert_eq!(normalize_package_name(\"Pillow\"), \"pillow\");\n    }\n\n    #[test]\n    fn test_is_prerelease() {\n        assert!(is_prerelease_python(\"1.0.0a1\"));\n        assert!(is_prerelease_python(\"1.0.0b2\"));\n        assert!(is_prerelease_python(\"1.0.0rc1\"));\n        assert!(is_prerelease_python(\"1.0.0.dev1\"));\n        assert!(is_prerelease_python(\"2.0.0alpha\"));\n        assert!(is_prerelease_python(\"2.0.0beta\"));\n        assert!(!is_prerelease_python(\"1.0.0\"));\n        assert!(!is_prerelease_python(\"2.3.4\"));\n    }\n\n    #[test]\n    fn test_compare_python_versions() {\n        use std::cmp::Ordering;\n\n        assert_eq!(compare_python_versions(\"1.0.0\", \"2.0.0\"), Ordering::Less);\n        assert_eq!(compare_python_versions(\"2.0.0\", \"1.0.0\"), Ordering::Greater);\n        assert_eq!(compare_python_versions(\"1.0.0\", \"1.0.0\"), Ordering::Equal);\n        assert_eq!(\n            compare_python_versions(\"1.10.0\", \"1.9.0\"),\n            Ordering::Greater\n        );\n    }\n}\n","traces":[{"line":104,"address":[17099856,17099984,17099990],"length":1,"stats":{"Line":2}},{"line":107,"address":[12941511],"length":1,"stats":{"Line":2}},{"line":122,"address":[13011248],"length":1,"stats":{"Line":0}},{"line":123,"address":[13011262],"length":1,"stats":{"Line":0}},{"line":159,"address":[12944816],"length":1,"stats":{"Line":2}},{"line":160,"address":[13040261],"length":1,"stats":{"Line":2}},{"line":163,"address":[17104722,17104704],"length":1,"stats":{"Line":0}},{"line":165,"address":[12997595],"length":1,"stats":{"Line":0}},{"line":167,"address":[12969671,12969568],"length":1,"stats":{"Line":0}},{"line":169,"address":[12490975],"length":1,"stats":{"Line":0}},{"line":171,"address":[12970592,12970524],"length":1,"stats":{"Line":0}},{"line":172,"address":[12970643,12970754],"length":1,"stats":{"Line":0}},{"line":179,"address":[12748658],"length":1,"stats":{"Line":0}},{"line":182,"address":[12971648],"length":1,"stats":{"Line":0}},{"line":185,"address":[12975054,12975040,12971727],"length":1,"stats":{"Line":0}},{"line":187,"address":[12975344,12975361,12975066],"length":1,"stats":{"Line":0}},{"line":189,"address":[13067096,13064146,13067056],"length":1,"stats":{"Line":0}},{"line":193,"address":[12971816,12974853,12974816,12971896],"length":1,"stats":{"Line":0}},{"line":196,"address":[13000083,13000185],"length":1,"stats":{"Line":0}},{"line":198,"address":[13002944,13000201,13002958],"length":1,"stats":{"Line":0}},{"line":200,"address":[14530816,14530835,14528069],"length":1,"stats":{"Line":0}},{"line":203,"address":[14530576,14530590,14528084,14528172],"length":1,"stats":{"Line":0}},{"line":206,"address":[13002768,13000483,13000561],"length":1,"stats":{"Line":0}},{"line":207,"address":[13067150],"length":1,"stats":{"Line":0}},{"line":208,"address":[13067829,13067174,13067824],"length":1,"stats":{"Line":0}},{"line":209,"address":[13003776,13003781,13002836],"length":1,"stats":{"Line":0}},{"line":210,"address":[13003573,13002849,13003568],"length":1,"stats":{"Line":0}},{"line":211,"address":[13002863],"length":1,"stats":{"Line":0}},{"line":215,"address":[12972412,12974528,12972488],"length":1,"stats":{"Line":0}},{"line":219,"address":[12974560],"length":1,"stats":{"Line":0}},{"line":220,"address":[13066909,13067648,13067678],"length":1,"stats":{"Line":0}},{"line":224,"address":[13000707,13000796],"length":1,"stats":{"Line":0}},{"line":228,"address":[14528543,14530896],"length":1,"stats":{"Line":0}},{"line":229,"address":[12974473],"length":1,"stats":{"Line":0}},{"line":230,"address":[13067253],"length":1,"stats":{"Line":0}},{"line":231,"address":[13067269,13067545,13067520],"length":1,"stats":{"Line":0}},{"line":235,"address":[13000805],"length":1,"stats":{"Line":0}},{"line":238,"address":[13000832,13003296,13003341],"length":1,"stats":{"Line":0}},{"line":239,"address":[13066983],"length":1,"stats":{"Line":0}},{"line":240,"address":[14530754],"length":1,"stats":{"Line":0}},{"line":241,"address":[14530762,14531344,14531353],"length":1,"stats":{"Line":0}},{"line":242,"address":[14531582,14531552,14530770],"length":1,"stats":{"Line":0}},{"line":243,"address":[12975271,12975226,12975248],"length":1,"stats":{"Line":0}},{"line":247,"address":[13001341],"length":1,"stats":{"Line":0}},{"line":248,"address":[13000886],"length":1,"stats":{"Line":0}},{"line":249,"address":[13000926],"length":1,"stats":{"Line":0}},{"line":250,"address":[13000966],"length":1,"stats":{"Line":0}},{"line":251,"address":[13001006],"length":1,"stats":{"Line":0}},{"line":252,"address":[12972870],"length":1,"stats":{"Line":0}},{"line":253,"address":[13001086],"length":1,"stats":{"Line":0}},{"line":254,"address":[13065260],"length":1,"stats":{"Line":0}},{"line":255,"address":[13001166],"length":1,"stats":{"Line":0}},{"line":258,"address":[12973053],"length":1,"stats":{"Line":0}},{"line":259,"address":[14529035],"length":1,"stats":{"Line":0}},{"line":265,"address":[12941632],"length":1,"stats":{"Line":0}},{"line":266,"address":[12941665],"length":1,"stats":{"Line":0}},{"line":267,"address":[12950748,12950720],"length":1,"stats":{"Line":0}},{"line":269,"address":[14507308,14507296],"length":1,"stats":{"Line":0}},{"line":275,"address":[12941948,12941954,12941760],"length":1,"stats":{"Line":2}},{"line":276,"address":[13037192],"length":1,"stats":{"Line":2}},{"line":281,"address":[17101004,17100336,17101139],"length":1,"stats":{"Line":2}},{"line":283,"address":[13008753,13008516],"length":1,"stats":{"Line":4}},{"line":284,"address":[13008781],"length":1,"stats":{"Line":2}},{"line":287,"address":[13038058,13037667],"length":1,"stats":{"Line":0}},{"line":293,"address":[13039196,13039190,13038368],"length":1,"stats":{"Line":0}},{"line":294,"address":[14507600],"length":1,"stats":{"Line":0}},{"line":295,"address":[12979360,12979297,12979373],"length":1,"stats":{"Line":0}},{"line":296,"address":[12979411,12979308,12979392],"length":1,"stats":{"Line":0}},{"line":300,"address":[13038472],"length":1,"stats":{"Line":0}},{"line":301,"address":[13038509],"length":1,"stats":{"Line":0}},{"line":303,"address":[12943216,12943136],"length":1,"stats":{"Line":0}},{"line":304,"address":[12943515,12943693],"length":1,"stats":{"Line":0}},{"line":306,"address":[13010220],"length":1,"stats":{"Line":0}},{"line":310,"address":[13010037],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":74},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","rubygems.rs"],"content":"//! # RubyGems Registry Client\n//!\n//! This module implements a client for [RubyGems.org](https://rubygems.org),\n//! the Ruby community's gem hosting service.\n//!\n//! ## API Details\n//!\n//! - **Base URL**: `https://rubygems.org/api/v1`\n//! - **API Version**: v1 (stable)\n//! - **Authentication**: API key for publishing (not needed for reading)\n//! - **CORS**: Enabled for browser-based access\n//!\n//! ## Rate Limiting\n//!\n//! RubyGems enforces rate limits:\n//!\n//! - **Standard limit**: ~10 requests per second per IP\n//! - **Blocking**: Aggressive crawlers may be blocked\n//! - **Best practice**: Use `If-Modified-Since` headers\n//!\n//! ## API Endpoints Used\n//!\n//! ### Fetch Gem Info\n//!\n//! - **Endpoint**: `GET /api/v1/gems/{gem-name}.json`\n//! - **Response**: JSON with gem metadata (latest version)\n//! - **Fields**:\n//!   - `version`: Latest version string\n//!   - `info`: Gem description\n//!   - `licenses[]`: Array of license identifiers\n//!   - `homepage_uri`: Homepage URL\n//!   - `source_code_uri`: Repository URL\n//!   - `project_uri`: RubyGems project page\n//!   - `version_created_at`: RFC 3339 release timestamp\n//!\n//! ### Fetch All Versions\n//!\n//! - **Endpoint**: `GET /api/v1/versions/{gem-name}.json`\n//! - **Response**: JSON array of version entries\n//! - **Fields**:\n//!   - `number`: Version string\n//!   - `created_at`: RFC 3339 publish timestamp\n//!\n//! ## Response Parsing\n//!\n//! - **Version format**: RubyGems versioning (`1.0.0`, `2.0.0.pre.1`)\n//! - **Date format**: RFC 3339 (`2024-01-15T10:30:00.000Z`)\n//! - **Prerelease**: Versions containing `.pre`, `.alpha`, `.beta`, `.rc`\n//!\n//! ## Edge Cases and Quirks\n//!\n//! - **Version ordering**: RubyGems uses its own ordering (not strictly semver)\n//! - **Yanked gems**: Available via separate endpoint (not implemented)\n//! - **Platform gems**: May have platform suffix (`-java`, `-x86_64-linux`)\n//! - **Prerelease format**: Uses `.pre.1` format (not `-pre.1`)\n//! - **No deprecation flag**: RubyGems API doesn't expose deprecation status\n//!\n//! ## Error Handling\n//!\n//! - **Network errors**: Returned as `anyhow::Error`\n//! - **API errors**: 404 for not found\n//! - **Timeouts**: 10 second default timeout\n//!\n//! ## External References\n//!\n//! - [RubyGems API](https://guides.rubygems.org/rubygems-org-api/)\n//! - [Gem Specification](https://guides.rubygems.org/specification-reference/)\n//! - [Version Format](https://guides.rubygems.org/patterns/#semantic-versioning)\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse chrono::{DateTime, Utc};\nuse reqwest::Client;\nuse serde::Deserialize;\n\nuse super::http_client::create_shared_client;\nuse super::{Registry, VersionInfo};\n\n/// Client for the RubyGems.org registry\npub struct RubyGemsRegistry {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl RubyGemsRegistry {\n    /// Creates a RubyGemsRegistry that uses the provided shared HTTP client.\n    ///\n    /// The provided `client` will be used for all HTTP requests to the RubyGems API. The registry's\n    /// base API URL is set to `https://rubygems.org/api/v1`.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use std::sync::Arc;\n    /// use dependi_lsp::registries::rubygems::RubyGemsRegistry;\n    ///\n    /// let client = Arc::new(reqwest::Client::new());\n    /// let _registry = RubyGemsRegistry::with_client(client);\n    /// ```\n    pub fn with_client(client: Arc<Client>) -> Self {\n        Self {\n            client,\n            base_url: \"https://rubygems.org/api/v1\".to_string(),\n        }\n    }\n}\n\nimpl Default for RubyGemsRegistry {\n    /// Creates a `RubyGemsRegistry` configured with the shared HTTP client used by the module.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// use dependi_lsp::registries::rubygems::RubyGemsRegistry;\n    ///\n    /// let registry = RubyGemsRegistry::default();\n    /// // `registry` is ready to query the RubyGems API.\n    /// ```\n    fn default() -> Self {\n        Self::with_client(create_shared_client().expect(\"Failed to create HTTP client\"))\n    }\n}\n\n/// RubyGems API response for a gem\n#[derive(Debug, Deserialize)]\nstruct GemResponse {\n    #[serde(rename = \"name\")]\n    _name: String,\n    version: String,\n    info: Option<String>,\n    licenses: Option<Vec<String>>,\n    homepage_uri: Option<String>,\n    source_code_uri: Option<String>,\n    project_uri: Option<String>,\n    version_created_at: Option<String>,\n}\n\n/// RubyGems API response for version list\n#[derive(Debug, Deserialize)]\nstruct VersionResponse {\n    number: String,\n    created_at: Option<String>,\n}\n\nimpl Registry for RubyGemsRegistry {\n    fn http_client(&self) -> Arc<Client> {\n        Arc::clone(&self.client)\n    }\n\n    async fn get_version_info(&self, package_name: &str) -> anyhow::Result<VersionInfo> {\n        // Fetch gem info (contains latest version)\n        let gem_url = format!(\"{}/gems/{}.json\", self.base_url, package_name);\n        let gem_response = self.client.get(&gem_url).send().await?;\n\n        if !gem_response.status().is_success() {\n            anyhow::bail!(\n                \"Failed to fetch gem info for {}: {}\",\n                package_name,\n                gem_response.status()\n            );\n        }\n\n        let gem: GemResponse = gem_response.json().await?;\n\n        // Fetch all versions with dates\n        let versions_url = format!(\"{}/versions/{}.json\", self.base_url, package_name);\n        let (versions, release_dates) = match self.client.get(&versions_url).send().await {\n            Ok(response) if response.status().is_success() => {\n                let version_list: Vec<VersionResponse> = response.json().await.unwrap_or_default();\n                let versions: Vec<String> = version_list.iter().map(|v| v.number.clone()).collect();\n                let dates: HashMap<String, DateTime<Utc>> = version_list\n                    .into_iter()\n                    .filter_map(|v| {\n                        v.created_at.as_ref().and_then(|time_str| {\n                            DateTime::parse_from_rfc3339(time_str)\n                                .ok()\n                                .map(|dt| (v.number.clone(), dt.with_timezone(&Utc)))\n                        })\n                    })\n                    .collect();\n                (versions, dates)\n            }\n            _ => {\n                // Fallback to just latest version with its date\n                let mut dates = HashMap::new();\n                if let Some(time_str) = &gem.version_created_at\n                    && let Ok(dt) = DateTime::parse_from_rfc3339(time_str)\n                {\n                    dates.insert(gem.version.clone(), dt.with_timezone(&Utc));\n                }\n                (vec![gem.version.clone()], dates)\n            }\n        };\n\n        // Use the latest version from gem info\n        let latest_stable = Some(gem.version.clone());\n\n        // Get license (first one if multiple)\n        let license = gem.licenses.and_then(|l| l.into_iter().next());\n\n        // Get repository URL (prefer source_code_uri, fallback to homepage)\n        let repository = gem.source_code_uri.or_else(|| gem.homepage_uri.clone());\n\n        Ok(VersionInfo {\n            latest: latest_stable,\n            latest_prerelease: None,\n            versions,\n            description: gem.info,\n            homepage: gem.homepage_uri.or(gem.project_uri),\n            repository,\n            license,\n            vulnerabilities: vec![], // Will be filled by OSV\n            deprecated: false,       // RubyGems doesn't have a deprecation flag in API\n            yanked: false,\n            yanked_versions: vec![], // Not applicable to RubyGems\n            release_dates,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_rubygems_url_format() {\n        let base_url = \"https://rubygems.org/api/v1\";\n        let name = \"rails\";\n        let url = format!(\"{}/gems/{}.json\", base_url, name);\n        assert_eq!(url, \"https://rubygems.org/api/v1/gems/rails.json\");\n    }\n}\n","traces":[{"line":101,"address":[13129584,13129718,13129712],"length":1,"stats":{"Line":2}},{"line":104,"address":[13129607],"length":1,"stats":{"Line":2}},{"line":120,"address":[14210880],"length":1,"stats":{"Line":0}},{"line":121,"address":[14210894],"length":1,"stats":{"Line":0}},{"line":147,"address":[13129040],"length":1,"stats":{"Line":2}},{"line":148,"address":[14209893],"length":1,"stats":{"Line":2}},{"line":151,"address":[14202674,14200622,14200957,14200986,14200915,14200872,14200560,14201466,14200936],"length":1,"stats":{"Line":0}},{"line":153,"address":[14201036,14200827],"length":1,"stats":{"Line":0}},{"line":154,"address":[13822310,13822892,13822694,13822594,13824004],"length":1,"stats":{"Line":0}},{"line":156,"address":[18269771,18269700],"length":1,"stats":{"Line":0}},{"line":157,"address":[14183766,14183911],"length":1,"stats":{"Line":0}},{"line":164,"address":[14182635,14184400,14183813,14184254],"length":1,"stats":{"Line":0}},{"line":167,"address":[18270991,18270883],"length":1,"stats":{"Line":0}},{"line":168,"address":[15259553],"length":1,"stats":{"Line":0}},{"line":169,"address":[13825581,13825485],"length":1,"stats":{"Line":0}},{"line":170,"address":[14200965,14205436,14204401,14204347],"length":1,"stats":{"Line":0}},{"line":171,"address":[13830067,13827053,13826985,13830032],"length":1,"stats":{"Line":0}},{"line":172,"address":[14205852],"length":1,"stats":{"Line":0}},{"line":174,"address":[13830005,13827243,13829888],"length":1,"stats":{"Line":0}},{"line":175,"address":[14190494,14190559,14190608],"length":1,"stats":{"Line":0}},{"line":176,"address":[18276538],"length":1,"stats":{"Line":0}},{"line":177,"address":[14190669],"length":1,"stats":{"Line":0}},{"line":178,"address":[13830208,13830182,13830231],"length":1,"stats":{"Line":0}},{"line":182,"address":[14187729],"length":1,"stats":{"Line":0}},{"line":186,"address":[14204127],"length":1,"stats":{"Line":0}},{"line":187,"address":[14204503,14204923],"length":1,"stats":{"Line":0}},{"line":188,"address":[14204566,14204662],"length":1,"stats":{"Line":0}},{"line":190,"address":[18272620,18272451,18272526,18272428],"length":1,"stats":{"Line":0}},{"line":192,"address":[13826281,13825909,13826723],"length":1,"stats":{"Line":0}},{"line":197,"address":[14206348,14206214],"length":1,"stats":{"Line":0}},{"line":200,"address":[14190350,14188100,14190336,14188215],"length":1,"stats":{"Line":0}},{"line":203,"address":[13829840,13829857,13827759,13827877],"length":1,"stats":{"Line":0}},{"line":205,"address":[14207168],"length":1,"stats":{"Line":0}},{"line":206,"address":[13827885],"length":1,"stats":{"Line":0}},{"line":207,"address":[14188403],"length":1,"stats":{"Line":0}},{"line":208,"address":[14188411],"length":1,"stats":{"Line":0}},{"line":209,"address":[14188451],"length":1,"stats":{"Line":0}},{"line":210,"address":[18274406],"length":1,"stats":{"Line":0}},{"line":211,"address":[14206917],"length":1,"stats":{"Line":0}},{"line":212,"address":[14188669],"length":1,"stats":{"Line":0}},{"line":213,"address":[14188709],"length":1,"stats":{"Line":0}},{"line":216,"address":[14188772],"length":1,"stats":{"Line":0}},{"line":217,"address":[14188832],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":43},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","registries","version_utils.rs"],"content":"//! Version parsing and comparison utilities for registry clients.\n//!\n//! This module provides common version-related functions used across\n//! different package registries, with support for registry-specific\n//! behavior where needed.\n\n/// Checks if a Rust crate version is a prerelease.\n///\n/// Uses semver-compatible prerelease detection. A version is considered\n/// a prerelease if it contains a hyphen (prerelease separator) or common\n/// prerelease identifiers.\npub fn is_prerelease_rust(version: &str) -> bool {\n    let v = version.to_lowercase();\n    v.contains('-') || v.contains(\"alpha\") || v.contains(\"beta\") || v.contains(\"rc\")\n}\n\n/// Checks if an npm package version is a prerelease.\n///\n/// npm-specific prerelease identifiers include `canary` and `next` tags\n/// in addition to common patterns.\npub fn is_prerelease_npm(version: &str) -> bool {\n    let v = version.to_lowercase();\n    v.contains('-')\n        || v.contains(\"alpha\")\n        || v.contains(\"beta\")\n        || v.contains(\"rc\")\n        || v.contains(\"canary\")\n        || v.contains(\"next\")\n}\n\n/// Checks if a PyPI package version is a prerelease.\n///\n/// Python-specific prerelease identifiers per PEP 440, including\n/// shorthand notation like `a1` for alpha and `b2` for beta.\n/// Note: Post-releases (`.postN`) are stable releases per PEP 440.\npub fn is_prerelease_python(version: &str) -> bool {\n    let v = version.to_lowercase();\n    v.contains(\"dev\")\n        || v.contains(\"alpha\")\n        || v.contains(\"beta\")\n        || v.contains(\"rc\")\n        || (v.contains('a') && v.chars().last().is_some_and(|c| c.is_ascii_digit()))\n        || (v.contains('b') && v.chars().last().is_some_and(|c| c.is_ascii_digit()))\n        || v.contains(\".dev\")\n}\n\n/// Checks if a Go module version is a prerelease.\n///\n/// Go uses semver-like versions with hyphenated prerelease suffixes.\npub fn is_prerelease_go(version: &str) -> bool {\n    let v = version.to_lowercase();\n    v.contains(\"-rc\") || v.contains(\"-alpha\") || v.contains(\"-beta\") || v.contains(\"-pre\")\n}\n\n/// Checks if a PHP Composer package version is a prerelease.\n///\n/// Composer-specific stability flags including `dev` and common\n/// prerelease identifiers.\npub fn is_prerelease_php(version: &str) -> bool {\n    let v = version.to_lowercase();\n    v.contains(\"alpha\")\n        || v.contains(\"beta\")\n        || v.contains(\"rc\")\n        || v.contains(\"-rc\")\n        || v.contains(\"dev\")\n}\n\n/// Checks if a Dart/Flutter package version is a prerelease.\n///\n/// Dart uses semver with hyphenated prerelease suffixes and common\n/// prerelease identifiers.\npub fn is_prerelease_dart(version: &str) -> bool {\n    let v = version.to_lowercase();\n    v.contains('-')\n        || v.contains(\"dev\")\n        || v.contains(\"alpha\")\n        || v.contains(\"beta\")\n        || v.contains(\"rc\")\n}\n\n/// Checks if a NuGet package version is a prerelease.\n///\n/// NuGet-specific prerelease identifiers include `preview` in addition\n/// to common patterns.\npub fn is_prerelease_nuget(version: &str) -> bool {\n    let v = version.to_lowercase();\n    v.contains('-')\n        || v.contains(\"alpha\")\n        || v.contains(\"beta\")\n        || v.contains(\"preview\")\n        || v.contains(\"rc\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_prerelease_rust() {\n        assert!(is_prerelease_rust(\"1.0.0-alpha\"));\n        assert!(is_prerelease_rust(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_rust(\"1.0.0-rc1\"));\n        assert!(is_prerelease_rust(\"1.0.0-ALPHA\"));\n        assert!(!is_prerelease_rust(\"1.0.0\"));\n        assert!(!is_prerelease_rust(\"2.3.4\"));\n    }\n\n    #[test]\n    fn test_is_prerelease_npm() {\n        assert!(is_prerelease_npm(\"1.0.0-alpha\"));\n        assert!(is_prerelease_npm(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_npm(\"1.0.0-rc.1\"));\n        assert!(is_prerelease_npm(\"18.3.0-canary\"));\n        assert!(is_prerelease_npm(\"1.0.0-next.0\"));\n        assert!(!is_prerelease_npm(\"1.0.0\"));\n        assert!(!is_prerelease_npm(\"2.3.4\"));\n    }\n\n    #[test]\n    fn test_is_prerelease_python() {\n        assert!(is_prerelease_python(\"1.0.0a1\"));\n        assert!(is_prerelease_python(\"1.0.0b2\"));\n        assert!(is_prerelease_python(\"1.0.0rc1\"));\n        assert!(is_prerelease_python(\"1.0.0.dev1\"));\n        assert!(is_prerelease_python(\"2.0.0alpha\"));\n        assert!(is_prerelease_python(\"2.0.0beta\"));\n        assert!(!is_prerelease_python(\"1.0.0.post1\")); // post-releases are stable per PEP 440\n        assert!(!is_prerelease_python(\"1.0.0\"));\n        assert!(!is_prerelease_python(\"2.3.4\"));\n    }\n\n    #[test]\n    fn test_is_prerelease_go() {\n        assert!(is_prerelease_go(\"v1.0.0-rc1\"));\n        assert!(is_prerelease_go(\"v2.0.0-beta.1\"));\n        assert!(is_prerelease_go(\"v3.0.0-alpha\"));\n        assert!(is_prerelease_go(\"v1.0.0-pre.1\"));\n        assert!(!is_prerelease_go(\"v1.0.0\"));\n        assert!(!is_prerelease_go(\"v2.3.4\"));\n    }\n\n    #[test]\n    fn test_is_prerelease_php() {\n        assert!(is_prerelease_php(\"1.0.0-alpha\"));\n        assert!(is_prerelease_php(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_php(\"1.0.0-RC1\"));\n        assert!(is_prerelease_php(\"dev-master\"));\n        assert!(!is_prerelease_php(\"1.0.0\"));\n        assert!(!is_prerelease_php(\"v2.3.4\"));\n    }\n\n    #[test]\n    fn test_is_prerelease_dart() {\n        assert!(is_prerelease_dart(\"1.0.0-dev.1\"));\n        assert!(is_prerelease_dart(\"1.0.0-alpha\"));\n        assert!(is_prerelease_dart(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_dart(\"1.0.0-rc.1\"));\n        assert!(!is_prerelease_dart(\"1.0.0\"));\n        assert!(!is_prerelease_dart(\"2.0.0\"));\n    }\n\n    #[test]\n    fn test_is_prerelease_nuget() {\n        assert!(is_prerelease_nuget(\"1.0.0-alpha\"));\n        assert!(is_prerelease_nuget(\"1.0.0-beta.1\"));\n        assert!(is_prerelease_nuget(\"1.0.0-preview\"));\n        assert!(is_prerelease_nuget(\"1.0.0-rc.1\"));\n        assert!(is_prerelease_nuget(\"1.0.0-Alpha\"));\n        assert!(!is_prerelease_nuget(\"1.0.0\"));\n        assert!(!is_prerelease_nuget(\"2.0.0\"));\n    }\n}\n","traces":[{"line":12,"address":[14444943,14444544,14444937],"length":1,"stats":{"Line":2}},{"line":13,"address":[14444573],"length":1,"stats":{"Line":2}},{"line":14,"address":[13006153,13006085],"length":1,"stats":{"Line":4}},{"line":21,"address":[12977712,12978312,12978306],"length":1,"stats":{"Line":2}},{"line":22,"address":[12977741],"length":1,"stats":{"Line":2}},{"line":23,"address":[12977857,12977912,12977774],"length":1,"stats":{"Line":6}},{"line":24,"address":[14711031,14711071],"length":1,"stats":{"Line":4}},{"line":25,"address":[12977980],"length":1,"stats":{"Line":2}},{"line":26,"address":[12978056],"length":1,"stats":{"Line":2}},{"line":27,"address":[14443268],"length":1,"stats":{"Line":2}},{"line":28,"address":[14443344],"length":1,"stats":{"Line":2}},{"line":36,"address":[14446419,14446425,14445488],"length":1,"stats":{"Line":2}},{"line":37,"address":[14713517],"length":1,"stats":{"Line":2}},{"line":38,"address":[13007038,13007121,13007195],"length":1,"stats":{"Line":8}},{"line":39,"address":[12980548,12980600],"length":1,"stats":{"Line":4}},{"line":40,"address":[14445787],"length":1,"stats":{"Line":4}},{"line":41,"address":[13007369],"length":1,"stats":{"Line":3}},{"line":42,"address":[12863136,12863140],"length":1,"stats":{"Line":10}},{"line":43,"address":[14446052,14446181,14446244],"length":1,"stats":{"Line":15}},{"line":44,"address":[14446219,14446348],"length":1,"stats":{"Line":6}},{"line":50,"address":[12977686,12977280,12977680],"length":1,"stats":{"Line":2}},{"line":51,"address":[14442445],"length":1,"stats":{"Line":2}},{"line":52,"address":[12977401,12977333],"length":1,"stats":{"Line":4}},{"line":59,"address":[14711985,14711991,14711472],"length":1,"stats":{"Line":2}},{"line":60,"address":[14711501],"length":1,"stats":{"Line":2}},{"line":61,"address":[14443667,14443528,14443605],"length":1,"stats":{"Line":6}},{"line":62,"address":[14443690,14443650],"length":1,"stats":{"Line":4}},{"line":63,"address":[13005223],"length":1,"stats":{"Line":2}},{"line":64,"address":[14443811],"length":1,"stats":{"Line":2}},{"line":65,"address":[13005375],"length":1,"stats":{"Line":2}},{"line":72,"address":[13005504,13006010,13006016],"length":1,"stats":{"Line":2}},{"line":73,"address":[13005533],"length":1,"stats":{"Line":2}},{"line":74,"address":[12978936,12979068,12979013],"length":1,"stats":{"Line":6}},{"line":75,"address":[13005675,13005715],"length":1,"stats":{"Line":5}},{"line":76,"address":[12979136],"length":1,"stats":{"Line":4}},{"line":77,"address":[14444348],"length":1,"stats":{"Line":2}},{"line":78,"address":[13005912],"length":1,"stats":{"Line":3}},{"line":85,"address":[14445472,14444960,14445466],"length":1,"stats":{"Line":2}},{"line":86,"address":[14712989],"length":1,"stats":{"Line":2}},{"line":87,"address":[14445016,14445093,14445148],"length":1,"stats":{"Line":6}},{"line":88,"address":[14445171,14445131],"length":1,"stats":{"Line":4}},{"line":89,"address":[14445216],"length":1,"stats":{"Line":2}},{"line":90,"address":[13006780],"length":1,"stats":{"Line":2}},{"line":91,"address":[13006856],"length":1,"stats":{"Line":3}}],"covered":44,"coverable":44},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","reports.rs"],"content":"//! Vulnerability report generation\n//!\n//! This module handles the generation of vulnerability reports\n//! in various formats (JSON, Markdown).\n\nuse serde::{Deserialize, Serialize};\nuse tower_lsp::lsp_types::Url;\n\n/// Summary of vulnerabilities grouped by severity level.\n///\n/// Used to provide an overview of the vulnerability scan results.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct VulnerabilitySummary {\n    /// Total number of vulnerabilities found.\n    pub total: u32,\n    /// Number of critical severity vulnerabilities.\n    pub critical: u32,\n    /// Number of high severity vulnerabilities.\n    pub high: u32,\n    /// Number of medium severity vulnerabilities.\n    pub medium: u32,\n    /// Number of low severity vulnerabilities.\n    pub low: u32,\n}\n\n/// A single vulnerability entry in a report.\n///\n/// Contains all relevant information about a vulnerability affecting a package.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct VulnerabilityReportEntry {\n    /// Name of the affected package.\n    pub package: String,\n    /// Version of the affected package.\n    pub version: String,\n    /// Vulnerability identifier (e.g., CVE-2021-1234, GHSA-xxxx).\n    pub id: String,\n    /// Severity level (critical, high, medium, low).\n    pub severity: String,\n    /// Human-readable description of the vulnerability.\n    pub description: String,\n    /// URL for more information about the vulnerability.\n    pub url: Option<String>,\n}\n\n/// Generate a Markdown-formatted vulnerability report.\n///\n/// Creates a human-readable report with a summary table and detailed\n/// vulnerability entries grouped by package.\npub fn generate_markdown_report(\n    uri: &Url,\n    summary: &VulnerabilitySummary,\n    vulnerabilities: &[VulnerabilityReportEntry],\n) -> String {\n    let mut lines = vec![\n        \"# Vulnerability Report\".to_string(),\n        String::new(),\n        format!(\"**File**: {}\", uri.path()),\n        format!(\"**Date**: {}\", chrono::Local::now().format(\"%Y-%m-%d\")),\n        String::new(),\n        \"## Summary\".to_string(),\n        \"| Severity | Count |\".to_string(),\n        \"|----------|-------|\".to_string(),\n        format!(\"| ⚠ Critical | {} |\", summary.critical),\n        format!(\"| ▲ High | {} |\", summary.high),\n        format!(\"| ● Medium | {} |\", summary.medium),\n        format!(\"| ○ Low | {} |\", summary.low),\n        format!(\"| **Total** | **{}** |\", summary.total),\n        String::new(),\n    ];\n\n    if !vulnerabilities.is_empty() {\n        lines.push(\"## Vulnerabilities\".to_string());\n        lines.push(String::new());\n\n        let mut current_package = String::new();\n        let mut current_version = String::new();\n        for vuln in vulnerabilities {\n            if vuln.package != current_package || vuln.version != current_version {\n                current_package = vuln.package.clone();\n                current_version = vuln.version.clone();\n                lines.push(format!(\"### {}@{}\", vuln.package, vuln.version));\n                lines.push(String::new());\n            }\n\n            let severity_icon = match vuln.severity.as_str() {\n                \"critical\" => \"⚠\",\n                \"high\" => \"▲\",\n                \"medium\" => \"●\",\n                _ => \"○\",\n            };\n\n            if let Some(url) = &vuln.url {\n                lines.push(format!(\n                    \"- **[{}]({})** ({} {}): {}\",\n                    vuln.id,\n                    url,\n                    severity_icon,\n                    vuln.severity.to_uppercase(),\n                    vuln.description\n                ));\n            } else {\n                lines.push(format!(\n                    \"- **{}** ({} {}): {}\",\n                    vuln.id,\n                    severity_icon,\n                    vuln.severity.to_uppercase(),\n                    vuln.description\n                ));\n            }\n        }\n    } else {\n        lines.push(\"## No vulnerabilities found\".to_string());\n        lines.push(String::new());\n        lines.push(\"✅ All dependencies are free of known security vulnerabilities.\".to_string());\n    }\n\n    lines.join(\"\\n\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generate_markdown_report_with_vulnerabilities() {\n        let uri = Url::parse(\"file:///project/Cargo.toml\").unwrap();\n        let summary = VulnerabilitySummary {\n            total: 2,\n            critical: 1,\n            high: 1,\n            medium: 0,\n            low: 0,\n        };\n        let vulnerabilities = vec![\n            VulnerabilityReportEntry {\n                package: \"serde\".to_string(),\n                version: \"1.0.0\".to_string(),\n                id: \"CVE-2021-1234\".to_string(),\n                severity: \"critical\".to_string(),\n                description: \"Critical vulnerability\".to_string(),\n                url: Some(\"https://example.com/cve\".to_string()),\n            },\n            VulnerabilityReportEntry {\n                package: \"tokio\".to_string(),\n                version: \"1.0.0\".to_string(),\n                id: \"CVE-2021-5678\".to_string(),\n                severity: \"high\".to_string(),\n                description: \"High vulnerability\".to_string(),\n                url: None,\n            },\n        ];\n\n        let report = generate_markdown_report(&uri, &summary, &vulnerabilities);\n\n        assert!(report.contains(\"# Vulnerability Report\"));\n        assert!(report.contains(\"**File**: /project/Cargo.toml\"));\n        assert!(report.contains(\"| ⚠ Critical | 1 |\"));\n        assert!(report.contains(\"| ▲ High | 1 |\"));\n        assert!(report.contains(\"### serde@1.0.0\"));\n        assert!(report.contains(\"### tokio@1.0.0\"));\n        assert!(report.contains(\"CVE-2021-1234\"));\n        assert!(report.contains(\"CVE-2021-5678\"));\n    }\n\n    #[test]\n    fn test_generate_markdown_report_same_package_different_versions() {\n        let uri = Url::parse(\"file:///project/Cargo.toml\").unwrap();\n        let summary = VulnerabilitySummary {\n            total: 2,\n            critical: 1,\n            high: 1,\n            medium: 0,\n            low: 0,\n        };\n        let vulnerabilities = vec![\n            VulnerabilityReportEntry {\n                package: \"serde\".to_string(),\n                version: \"1.0.0\".to_string(),\n                id: \"CVE-2021-1111\".to_string(),\n                severity: \"critical\".to_string(),\n                description: \"Old version vulnerability\".to_string(),\n                url: None,\n            },\n            VulnerabilityReportEntry {\n                package: \"serde\".to_string(),\n                version: \"2.0.0\".to_string(),\n                id: \"CVE-2021-2222\".to_string(),\n                severity: \"high\".to_string(),\n                description: \"New version vulnerability\".to_string(),\n                url: None,\n            },\n        ];\n\n        let report = generate_markdown_report(&uri, &summary, &vulnerabilities);\n\n        assert!(report.contains(\"### serde@1.0.0\"));\n        assert!(report.contains(\"### serde@2.0.0\"));\n        assert!(report.contains(\"CVE-2021-1111\"));\n        assert!(report.contains(\"CVE-2021-2222\"));\n    }\n\n    #[test]\n    fn test_generate_markdown_report_no_vulnerabilities() {\n        let uri = Url::parse(\"file:///project/Cargo.toml\").unwrap();\n        let summary = VulnerabilitySummary::default();\n        let vulnerabilities = vec![];\n\n        let report = generate_markdown_report(&uri, &summary, &vulnerabilities);\n\n        assert!(report.contains(\"# Vulnerability Report\"));\n        assert!(report.contains(\"## No vulnerabilities found\"));\n        assert!(report.contains(\"✅ All dependencies are free of known security vulnerabilities.\"));\n    }\n}\n","traces":[{"line":49,"address":[17152352,17157057,17157714],"length":1,"stats":{"Line":2}},{"line":54,"address":[13928314,13928757,13927393,13929119,13927799,13928574,13929278,13932706,13928394,13927496,13928095,13927572,13928940,13929860,13927437,13928170,13929322,13928242],"length":1,"stats":{"Line":8}},{"line":55,"address":[13927406],"length":1,"stats":{"Line":5}},{"line":56,"address":[14596797],"length":1,"stats":{"Line":4}},{"line":57,"address":[14596853,14596937],"length":1,"stats":{"Line":9}},{"line":58,"address":[13946068,13946131],"length":1,"stats":{"Line":9}},{"line":59,"address":[14597377],"length":1,"stats":{"Line":5}},{"line":60,"address":[13946427],"length":1,"stats":{"Line":4}},{"line":61,"address":[13928211],"length":1,"stats":{"Line":4}},{"line":62,"address":[13946571],"length":1,"stats":{"Line":5}},{"line":63,"address":[13928435,13928363],"length":1,"stats":{"Line":9}},{"line":64,"address":[17153576,17153651],"length":1,"stats":{"Line":9}},{"line":65,"address":[14598015,14598090],"length":1,"stats":{"Line":9}},{"line":66,"address":[13947272,13947197],"length":1,"stats":{"Line":9}},{"line":67,"address":[14598381,14598452],"length":1,"stats":{"Line":9}},{"line":68,"address":[13929271],"length":1,"stats":{"Line":4}},{"line":71,"address":[14599127,14599205],"length":1,"stats":{"Line":9}},{"line":72,"address":[13929995,13929930],"length":1,"stats":{"Line":8}},{"line":73,"address":[13930030],"length":1,"stats":{"Line":4}},{"line":75,"address":[13948360],"length":1,"stats":{"Line":3}},{"line":76,"address":[13930087],"length":1,"stats":{"Line":3}},{"line":77,"address":[13930238,13930154],"length":1,"stats":{"Line":6}},{"line":78,"address":[17155479,17155551,17155373],"length":1,"stats":{"Line":6}},{"line":79,"address":[13930507,13930568,13930587],"length":1,"stats":{"Line":4}},{"line":80,"address":[13948990,13949032],"length":1,"stats":{"Line":3}},{"line":81,"address":[13930859],"length":1,"stats":{"Line":3}},{"line":82,"address":[14600354],"length":1,"stats":{"Line":3}},{"line":85,"address":[13931130,13930544],"length":1,"stats":{"Line":6}},{"line":86,"address":[14600485,14600419],"length":1,"stats":{"Line":6}},{"line":87,"address":[14600462,14600560,14600521],"length":1,"stats":{"Line":8}},{"line":88,"address":[13931355,13931264,13931320],"length":1,"stats":{"Line":0}},{"line":89,"address":[13931326],"length":1,"stats":{"Line":0}},{"line":92,"address":[17156411],"length":1,"stats":{"Line":3}},{"line":93,"address":[13949862,13949744],"length":1,"stats":{"Line":4}},{"line":98,"address":[13931542,13931468],"length":1,"stats":{"Line":4}},{"line":102,"address":[13950371,13949785],"length":1,"stats":{"Line":4}},{"line":106,"address":[13931508,13932052],"length":1,"stats":{"Line":4}},{"line":112,"address":[14601755,14599242],"length":1,"stats":{"Line":4}},{"line":113,"address":[13950809],"length":1,"stats":{"Line":2}},{"line":114,"address":[13932555],"length":1,"stats":{"Line":2}},{"line":117,"address":[13932639,13930416],"length":1,"stats":{"Line":4}}],"covered":39,"coverable":41},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","utils.rs"],"content":"//! Common utility functions used across the LSP implementation.\n\n/// Truncates a string to a maximum character count with ellipsis.\n///\n/// This function properly handles UTF-8 strings by counting characters,\n/// not bytes. If the string needs truncation, an ellipsis (\"...\") is\n/// appended and counted toward the maximum length.\n///\n/// # Arguments\n///\n/// * `s` - The string to truncate\n/// * `max_chars` - Maximum number of characters to display (including ellipsis)\n///\n/// # Returns\n///\n/// The truncated string, or the original string if it fits within `max_chars`.\npub fn truncate_string(s: &str, max_chars: usize) -> String {\n    let char_count = s.chars().count();\n    if char_count <= max_chars {\n        return s.to_string();\n    }\n\n    let keep_chars = max_chars.saturating_sub(3);\n    let truncated: String = s.chars().take(keep_chars).collect();\n    format!(\"{}...\", truncated)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_no_truncation_needed() {\n        assert_eq!(truncate_string(\"hello\", 10), \"hello\");\n        assert_eq!(truncate_string(\"\", 10), \"\");\n        assert_eq!(truncate_string(\"hello\", 5), \"hello\");\n    }\n\n    #[test]\n    fn test_ascii_truncation() {\n        assert_eq!(truncate_string(\"hello world\", 8), \"hello...\");\n        assert_eq!(truncate_string(\"abcdefghij\", 7), \"abcd...\");\n    }\n\n    #[test]\n    fn test_edge_cases() {\n        assert_eq!(truncate_string(\"hello\", 3), \"...\");\n        assert_eq!(truncate_string(\"hello\", 4), \"h...\");\n        assert_eq!(truncate_string(\"ab\", 1), \"...\");\n        assert_eq!(truncate_string(\"a\", 0), \"...\");\n    }\n\n    #[test]\n    fn test_utf8_japanese() {\n        // \"日本語\" = 3 characters, 9 bytes\n        assert_eq!(truncate_string(\"日本語\", 10), \"日本語\");\n        assert_eq!(truncate_string(\"日本語\", 3), \"日本語\");\n        // \"日本語test\" = 7 characters\n        // truncate to 6 means keep 3 + \"...\" = 6 total\n        assert_eq!(truncate_string(\"日本語test\", 6), \"日本語...\");\n        // 7 chars <= 8, so no truncation needed\n        assert_eq!(truncate_string(\"日本語test\", 8), \"日本語test\");\n        // 7 chars <= 7, so no truncation needed\n        assert_eq!(truncate_string(\"日本語test\", 7), \"日本語test\");\n        // truncate to 5 means keep 2 + \"...\" = 5\n        assert_eq!(truncate_string(\"日本語test\", 5), \"日本...\");\n    }\n\n    #[test]\n    fn test_utf8_emoji() {\n        // \"hello\" = 5 characters, fits in 8\n        assert_eq!(truncate_string(\"hello\", 8), \"hello\");\n        // \"hello world\" = 11 characters, truncate to 8 means keep 5 + \"...\"\n        let emoji_str = \"hello world\";\n        assert_eq!(truncate_string(emoji_str, 8), \"hello...\");\n    }\n\n    #[test]\n    fn test_mixed_content() {\n        assert_eq!(truncate_string(\"Hello 日本\", 10), \"Hello 日本\");\n        assert_eq!(truncate_string(\"Hello 日本語 world\", 12), \"Hello 日本語...\");\n    }\n}\n","traces":[{"line":17,"address":[13690054,13690060,13689648],"length":1,"stats":{"Line":2}},{"line":18,"address":[13840856],"length":1,"stats":{"Line":2}},{"line":19,"address":[13840885],"length":1,"stats":{"Line":2}},{"line":20,"address":[13859319],"length":1,"stats":{"Line":2}},{"line":23,"address":[13840900],"length":1,"stats":{"Line":2}},{"line":24,"address":[13840928],"length":1,"stats":{"Line":4}},{"line":25,"address":[13841083,13840989],"length":1,"stats":{"Line":9}}],"covered":7,"coverable":7},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","vulnerabilities","cache.rs"],"content":"//! Vulnerability cache for tracking queried packages\n//!\n//! Tracks which packages have been queried for vulnerabilities to avoid\n//! redundant API calls. The actual vulnerability data is stored in the\n//! version cache alongside version information.\n\nuse std::fmt::Display;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse dashmap::DashMap;\n\nuse super::Ecosystem;\n\n/// Default TTL for vulnerability cache (6 hours)\nconst DEFAULT_VULN_CACHE_TTL: Duration = Duration::from_secs(6 * 3600);\n\n/// Cache key for vulnerability lookups\n#[derive(Debug, Clone, Hash, PartialEq, Eq)]\npub struct VulnCacheKey {\n    /// Target ecosystem\n    pub ecosystem: Ecosystem,\n    /// Package name\n    pub package_name: String,\n    /// Package version\n    pub version: String,\n}\n\nimpl VulnCacheKey {\n    /// Create a new cache key\n    pub fn new(ecosystem: Ecosystem, package_name: &str, version: &str) -> Self {\n        Self {\n            ecosystem,\n            package_name: package_name.to_string(),\n            version: version.to_string(),\n        }\n    }\n}\n\n/// Tracks when a package was queried for vulnerabilities\nstruct VulnCacheEntry {\n    /// When the entry was inserted\n    inserted_at: Instant,\n}\n\n/// Cleanup interval for background task (30 minutes)\nconst CLEANUP_INTERVAL: Duration = Duration::from_secs(30 * 60);\n\n/// Tracks which packages have been queried for vulnerabilities\n///\n/// This is a \"seen set\" with TTL - it prevents redundant API calls to OSV.dev\n/// by tracking which package@version combinations have already been queried.\n/// The actual vulnerability data is stored in the version cache.\n#[derive(Clone)]\npub struct VulnerabilityCache {\n    /// Cache entries (package key -> query timestamp)\n    entries: Arc<DashMap<VulnCacheKey, VulnCacheEntry>>,\n    /// Cache TTL\n    ttl: Duration,\n}\n\nimpl VulnerabilityCache {\n    /// Create a new cache with default TTL (6 hours) and spawn background cleanup\n    pub fn new() -> Self {\n        let cache = Self {\n            entries: Arc::new(DashMap::new()),\n            ttl: DEFAULT_VULN_CACHE_TTL,\n        };\n        Self::spawn_cleanup_task(cache.clone());\n        cache\n    }\n\n    fn spawn_cleanup_task(cache: VulnerabilityCache) {\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(CLEANUP_INTERVAL);\n            interval.tick().await; // Skip immediate first tick\n\n            loop {\n                interval.tick().await;\n\n                let stats = cache.stats();\n                let removed = cache.cleanup_expired();\n                if removed > 0 {\n                    tracing::info!(\n                        \"Background cleanup: removed {} expired entries from vulnerability cache (was: {})\",\n                        removed,\n                        stats\n                    );\n                }\n            }\n        });\n    }\n\n    /// Create a cache with custom TTL in seconds (no background cleanup for tests)\n    #[cfg(test)]\n    pub fn with_ttl(ttl_secs: u64) -> Self {\n        Self {\n            entries: Arc::new(DashMap::new()),\n            ttl: Duration::from_secs(ttl_secs),\n        }\n    }\n\n    /// Mark a package as having been queried for vulnerabilities\n    pub fn insert(&self, key: VulnCacheKey) {\n        self.entries.insert(\n            key,\n            VulnCacheEntry {\n                inserted_at: Instant::now(),\n            },\n        );\n    }\n\n    /// Check if a package has been queried (and the query hasn't expired)\n    pub fn contains(&self, key: &VulnCacheKey) -> bool {\n        self.entries\n            .get(key)\n            .is_some_and(|entry| entry.inserted_at.elapsed() < self.ttl)\n    }\n\n    /// Clear all entries from cache\n    #[cfg(test)]\n    pub fn clear(&self) {\n        self.entries.clear();\n    }\n\n    /// Get the number of entries in the cache\n    #[cfg(test)]\n    pub fn len(&self) -> usize {\n        self.entries.len()\n    }\n\n    /// Check if the cache is empty\n    #[cfg(test)]\n    pub fn is_empty(&self) -> bool {\n        self.entries.is_empty()\n    }\n\n    pub fn cleanup_expired(&self) -> usize {\n        let before = self.entries.len();\n        self.entries\n            .retain(|_, entry| entry.inserted_at.elapsed() < self.ttl);\n        let removed = before - self.entries.len();\n        if removed > 0 {\n            tracing::debug!(\n                \"Cleaned up {} expired vulnerability cache entries ({} remaining)\",\n                removed,\n                self.entries.len()\n            );\n        }\n        removed\n    }\n\n    pub fn stats(&self) -> VulnCacheStats {\n        let total = self.entries.len();\n        let expired = self\n            .entries\n            .iter()\n            .filter(|e| e.inserted_at.elapsed() >= self.ttl)\n            .count();\n        VulnCacheStats {\n            total_entries: total,\n            expired_entries: expired,\n            valid_entries: total.saturating_sub(expired),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct VulnCacheStats {\n    pub total_entries: usize,\n    pub expired_entries: usize,\n    pub valid_entries: usize,\n}\n\nimpl Display for VulnCacheStats {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"VulnCacheStats {{ total: {}, expired: {}, valid: {} }}\",\n            self.total_entries, self.expired_entries, self.valid_entries\n        )\n    }\n}\n\nimpl Default for VulnerabilityCache {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cache_insert_and_contains() {\n        let cache = VulnerabilityCache::with_ttl(3600);\n        let key = VulnCacheKey::new(Ecosystem::Npm, \"lodash\", \"4.17.0\");\n\n        assert!(!cache.contains(&key));\n        cache.insert(key.clone());\n        assert!(cache.contains(&key));\n    }\n\n    #[test]\n    fn test_cache_clear() {\n        let cache = VulnerabilityCache::with_ttl(3600);\n        let key = VulnCacheKey::new(Ecosystem::PyPI, \"requests\", \"2.28.0\");\n\n        cache.insert(key.clone());\n        assert_eq!(cache.len(), 1);\n\n        cache.clear();\n        assert!(cache.is_empty());\n    }\n\n    #[test]\n    fn test_cache_with_custom_ttl() {\n        let cache = VulnerabilityCache::with_ttl(3600);\n        assert_eq!(cache.ttl, Duration::from_secs(3600));\n    }\n\n    #[test]\n    fn test_vuln_cache_cleanup_expired() {\n        // Use 10ms TTL for fast test\n        let cache = VulnerabilityCache::with_ttl(0); // 0 seconds = immediate expiry\n        let key1 = VulnCacheKey::new(Ecosystem::Npm, \"pkg1\", \"1.0.0\");\n        let key2 = VulnCacheKey::new(Ecosystem::Npm, \"pkg2\", \"1.0.0\");\n\n        cache.insert(key1);\n        cache.insert(key2);\n\n        assert_eq!(cache.len(), 2);\n\n        // Wait for expiration\n        std::thread::sleep(Duration::from_millis(10));\n\n        let removed = cache.cleanup_expired();\n        assert_eq!(removed, 2);\n        assert_eq!(cache.len(), 0);\n    }\n\n    #[test]\n    fn test_vuln_cache_stats() {\n        let cache = VulnerabilityCache::with_ttl(0); // Immediate expiry\n        let key1 = VulnCacheKey::new(Ecosystem::Npm, \"pkg1\", \"1.0.0\");\n        let key2 = VulnCacheKey::new(Ecosystem::Npm, \"pkg2\", \"1.0.0\");\n\n        cache.insert(key1);\n        cache.insert(key2);\n\n        // Wait for expiration\n        std::thread::sleep(Duration::from_millis(10));\n\n        let stats = cache.stats();\n        assert_eq!(stats.total_entries, 2);\n        assert_eq!(stats.expired_entries, 2);\n        assert_eq!(stats.valid_entries, 0);\n    }\n\n    #[test]\n    fn test_vuln_cache_stats_display() {\n        let stats = VulnCacheStats {\n            total_entries: 5,\n            expired_entries: 2,\n            valid_entries: 3,\n        };\n        let display = format!(\"{}\", stats);\n        assert!(display.contains(\"total: 5\"));\n        assert!(display.contains(\"expired: 2\"));\n        assert!(display.contains(\"valid: 3\"));\n    }\n}\n","traces":[{"line":31,"address":[16268102,16267856,16268108],"length":1,"stats":{"Line":8}},{"line":34,"address":[14401735],"length":1,"stats":{"Line":4}},{"line":35,"address":[16267982],"length":1,"stats":{"Line":8}},{"line":64,"address":[13080432,13080612,13080618],"length":1,"stats":{"Line":0}},{"line":66,"address":[13109377],"length":1,"stats":{"Line":0}},{"line":69,"address":[16268954,16268997],"length":1,"stats":{"Line":0}},{"line":70,"address":[13080578],"length":1,"stats":{"Line":0}},{"line":73,"address":[14402560],"length":1,"stats":{"Line":0}},{"line":74,"address":[13109284],"length":1,"stats":{"Line":0}},{"line":75,"address":[12991473],"length":1,"stats":{"Line":0}},{"line":76,"address":[12991670,12991757,12991517,12991597],"length":1,"stats":{"Line":0}},{"line":79,"address":[12991981,12991538,12992002,12991948,12992827],"length":1,"stats":{"Line":0}},{"line":81,"address":[13956753],"length":1,"stats":{"Line":0}},{"line":82,"address":[13975069],"length":1,"stats":{"Line":0}},{"line":83,"address":[13975102],"length":1,"stats":{"Line":0}},{"line":84,"address":[13956829],"length":1,"stats":{"Line":0}},{"line":96,"address":[14403456,14403602,14403596],"length":1,"stats":{"Line":8}},{"line":98,"address":[14403489],"length":1,"stats":{"Line":9}},{"line":99,"address":[14403514],"length":1,"stats":{"Line":10}},{"line":104,"address":[13109760,13109996],"length":1,"stats":{"Line":6}},{"line":105,"address":[13109946,13109774],"length":1,"stats":{"Line":14}},{"line":106,"address":[13109842],"length":1,"stats":{"Line":6}},{"line":108,"address":[13080959],"length":1,"stats":{"Line":6}},{"line":114,"address":[16269552],"length":1,"stats":{"Line":2}},{"line":115,"address":[13081127],"length":1,"stats":{"Line":2}},{"line":116,"address":[16269587],"length":1,"stats":{"Line":2}},{"line":117,"address":[13975920,13975952],"length":1,"stats":{"Line":6}},{"line":122,"address":[14402864],"length":1,"stats":{"Line":2}},{"line":123,"address":[14402869],"length":1,"stats":{"Line":2}},{"line":128,"address":[14402640],"length":1,"stats":{"Line":4}},{"line":129,"address":[14402645],"length":1,"stats":{"Line":4}},{"line":134,"address":[16269632],"length":1,"stats":{"Line":2}},{"line":135,"address":[14403429],"length":1,"stats":{"Line":2}},{"line":138,"address":[13108624],"length":1,"stats":{"Line":2}},{"line":139,"address":[14401940],"length":1,"stats":{"Line":2}},{"line":140,"address":[13108677],"length":1,"stats":{"Line":2}},{"line":141,"address":[13079763],"length":1,"stats":{"Line":6}},{"line":142,"address":[14402051,14401994],"length":1,"stats":{"Line":2}},{"line":143,"address":[16268249],"length":1,"stats":{"Line":2}},{"line":144,"address":[13108984,13108787],"length":1,"stats":{"Line":1}},{"line":153,"address":[13080640],"length":1,"stats":{"Line":2}},{"line":154,"address":[13080676],"length":1,"stats":{"Line":2}},{"line":155,"address":[13080708],"length":1,"stats":{"Line":2}},{"line":158,"address":[13109660],"length":1,"stats":{"Line":6}},{"line":163,"address":[13080780],"length":1,"stats":{"Line":2}},{"line":176,"address":[13081968],"length":1,"stats":{"Line":2}},{"line":177,"address":[13081999],"length":1,"stats":{"Line":2}},{"line":186,"address":[13082384],"length":1,"stats":{"Line":0}},{"line":187,"address":[13082392],"length":1,"stats":{"Line":0}}],"covered":34,"coverable":49},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","vulnerabilities","mod.rs"],"content":"//! Vulnerability scanning for dependencies\n//!\n//! This module provides vulnerability detection using OSV.dev API\n//! as the primary source for all ecosystems.\n\npub mod cache;\npub mod osv;\n\n/// Ecosystem identifiers for vulnerability sources\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Ecosystem {\n    /// Rust crates (crates.io)\n    CratesIo,\n    /// JavaScript/Node packages (npm)\n    Npm,\n    /// Python packages (PyPI)\n    PyPI,\n    /// Go modules\n    Go,\n    /// PHP packages (Packagist)\n    Packagist,\n    /// Dart/Flutter packages (pub.dev)\n    Pub,\n    /// .NET packages (NuGet)\n    NuGet,\n    /// Ruby gems (RubyGems.org)\n    RubyGems,\n}\n\nimpl Ecosystem {\n    /// Convert to OSV.dev ecosystem string\n    pub fn as_osv_str(&self) -> &'static str {\n        match self {\n            Ecosystem::CratesIo => \"crates.io\",\n            Ecosystem::Npm => \"npm\",\n            Ecosystem::PyPI => \"PyPI\",\n            Ecosystem::Go => \"Go\",\n            Ecosystem::Packagist => \"Packagist\",\n            Ecosystem::Pub => \"Pub\",\n            Ecosystem::NuGet => \"NuGet\",\n            Ecosystem::RubyGems => \"RubyGems\",\n        }\n    }\n}\n\n/// Query for vulnerability lookup\n#[derive(Debug, Clone)]\npub struct VulnerabilityQuery {\n    /// Package name\n    pub package_name: String,\n    /// Package version (normalized, without ^ or ~ prefixes)\n    pub version: String,\n    /// Target ecosystem\n    pub ecosystem: Ecosystem,\n}\n","traces":[{"line":32,"address":[13034880],"length":1,"stats":{"Line":2}},{"line":33,"address":[12976725],"length":1,"stats":{"Line":2}},{"line":34,"address":[13367268],"length":1,"stats":{"Line":2}},{"line":35,"address":[13034942],"length":1,"stats":{"Line":2}},{"line":36,"address":[13034968],"length":1,"stats":{"Line":2}},{"line":37,"address":[12976831],"length":1,"stats":{"Line":2}},{"line":38,"address":[12976854],"length":1,"stats":{"Line":2}},{"line":39,"address":[12976877],"length":1,"stats":{"Line":2}},{"line":40,"address":[12976900],"length":1,"stats":{"Line":2}},{"line":41,"address":[12976923],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":10},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","src","vulnerabilities","osv.rs"],"content":"//! OSV.dev API client for vulnerability data\n//!\n//! OSV (Open Source Vulnerabilities) provides a unified API for querying\n//! vulnerability data across multiple ecosystems.\n\nuse std::sync::Arc;\nuse std::time::Duration;\n\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\n\nuse super::VulnerabilityQuery;\nuse crate::registries::{Vulnerability, VulnerabilitySeverity};\n\nconst OSV_API_BASE: &str = \"https://api.osv.dev/v1\";\n\n/// Result of a vulnerability query\n#[derive(Debug, Clone, Default)]\npub struct QueryResult {\n    pub vulnerabilities: Vec<Vulnerability>,\n    pub deprecated: bool,\n}\n\n/// OSV.dev API client\npub struct OsvClient {\n    client: Arc<Client>,\n    base_url: String,\n}\n\nimpl OsvClient {\n    pub fn new() -> anyhow::Result<Self> {\n        let client = Client::builder()\n            .user_agent(\"dependi-lsp (https://github.com/mathieu/zed-dependi)\")\n            .timeout(Duration::from_secs(30))\n            .build()?;\n\n        Ok(Self {\n            client: Arc::new(client),\n            base_url: OSV_API_BASE.to_string(),\n        })\n    }\n\n    fn convert_vulnerability(osv: &OsvVulnerability) -> Vulnerability {\n        let id = osv\n            .aliases\n            .as_ref()\n            .and_then(|a| a.iter().find(|id| id.starts_with(\"CVE-\")))\n            .cloned()\n            .unwrap_or_else(|| osv.id.clone());\n\n        let severity = osv\n            .severity\n            .as_ref()\n            .and_then(|s| s.first())\n            .map(|s| parse_cvss_severity(&s.score))\n            .unwrap_or(VulnerabilitySeverity::Medium);\n\n        let description = osv\n            .summary\n            .clone()\n            .or_else(|| osv.details.clone())\n            .unwrap_or_else(|| format!(\"Vulnerability {}\", osv.id));\n\n        let url = osv.references.as_ref().and_then(|refs| {\n            refs.iter()\n                .find(|r| r._ref_type == \"ADVISORY\" || r._ref_type == \"WEB\")\n                .map(|r| r.url.clone())\n        });\n\n        Vulnerability {\n            id,\n            severity,\n            description,\n            url,\n        }\n    }\n}\n\nimpl Default for OsvClient {\n    fn default() -> Self {\n        Self::new().expect(\"Failed to create OsvClient\")\n    }\n}\n\nfn parse_cvss_severity(score: &str) -> VulnerabilitySeverity {\n    if let Ok(score) = score.parse::<f64>() {\n        return match score {\n            s if s >= 9.0 => VulnerabilitySeverity::Critical,\n            s if s >= 7.0 => VulnerabilitySeverity::High,\n            s if s >= 4.0 => VulnerabilitySeverity::Medium,\n            _ => VulnerabilitySeverity::Low,\n        };\n    }\n\n    if score.starts_with(\"CVSS:\") {\n        return VulnerabilitySeverity::Medium;\n    }\n\n    VulnerabilitySeverity::Medium\n}\n\nimpl OsvClient {\n    pub async fn query_batch(\n        &self,\n        queries: &[VulnerabilityQuery],\n    ) -> anyhow::Result<Vec<QueryResult>> {\n        if queries.is_empty() {\n            return Ok(vec![]);\n        }\n\n        let request = OsvBatchRequest {\n            queries: queries\n                .iter()\n                .map(|q| OsvQueryRequest {\n                    package: OsvPackage {\n                        name: q.package_name.clone(),\n                        ecosystem: q.ecosystem.as_osv_str().to_string(),\n                    },\n                    version: Some(q.version.clone()),\n                })\n                .collect(),\n        };\n\n        let url = format!(\"{}/querybatch\", self.base_url);\n        let response = self.client.post(&url).json(&request).send().await?;\n\n        if !response.status().is_success() {\n            anyhow::bail!(\"OSV API batch error: {}\", response.status());\n        }\n\n        let batch_response: OsvBatchResponse = response.json().await?;\n\n        let mut results = Vec::new();\n\n        for r in &batch_response.results {\n            let vulnerabilities = r\n                .vulns\n                .as_ref()\n                .unwrap_or(&vec![])\n                .iter()\n                .map(Self::convert_vulnerability)\n                .collect();\n\n            let rustsec_ids: Vec<String> = r\n                .vulns\n                .as_ref()\n                .unwrap_or(&vec![])\n                .iter()\n                .filter(|v| v.id.starts_with(\"RUSTSEC-\"))\n                .map(|v| v.id.clone())\n                .collect();\n\n            let has_unmaintained = self.check_rustsec_unmaintained(&rustsec_ids).await;\n\n            results.push(QueryResult {\n                vulnerabilities,\n                deprecated: has_unmaintained,\n            });\n        }\n\n        Ok(results)\n    }\n\n    async fn check_rustsec_unmaintained(&self, ids: &[String]) -> bool {\n        if ids.is_empty() {\n            return false;\n        }\n\n        tracing::debug!(\n            \"Checking {} RUSTSEC advisories for unmaintained status\",\n            ids.len()\n        );\n\n        // Spawn all tasks in parallel\n        let tasks: Vec<_> = ids\n            .iter()\n            .map(|id| {\n                let url = format!(\"{}/vulns/{}\", self.base_url, id);\n                let client = Arc::clone(&self.client);\n                let id_clone = id.clone();\n\n                tokio::spawn(async move {\n                    let response = match client.get(&url).send().await {\n                        Ok(r) => r,\n                        Err(e) => {\n                            tracing::warn!(\"Failed to fetch advisory {}: {}\", id_clone, e);\n                            return false;\n                        }\n                    };\n\n                    let details: Option<OsvVulnerabilityDetails> = match response.json().await {\n                        Ok(d) => d,\n                        Err(e) => {\n                            tracing::warn!(\"Failed to parse advisory {}: {}\", id_clone, e);\n                            return false;\n                        }\n                    };\n\n                    let is_unmaintained = details.as_ref().is_some_and(|v| {\n                        // Check summary for \"maintained\" or \"deprecated\" keywords\n                        let summary_match = v.summary.as_ref().is_some_and(|s| {\n                            let lower = s.to_lowercase();\n                            lower.contains(\"maintained\") || lower.contains(\"deprecated\")\n                        });\n\n                        // Check database_specific.informational for \"unmaintained\"\n                        let informational_match = v.affected.as_ref().is_some_and(|affected| {\n                            affected.iter().any(|a| {\n                                a.database_specific.as_ref().is_some_and(|db| {\n                                    db.informational\n                                        .as_ref()\n                                        .is_some_and(|i| i == \"unmaintained\")\n                                })\n                            })\n                        });\n\n                        summary_match || informational_match\n                    });\n\n                    if is_unmaintained {\n                        tracing::info!(\n                            \"Advisory {} indicates unmaintained package: {}\",\n                            id_clone,\n                            details\n                                .as_ref()\n                                .and_then(|v| v.summary.as_ref())\n                                .unwrap_or(&String::new())\n                        );\n                    }\n\n                    is_unmaintained\n                })\n            })\n            .collect();\n\n        // Wait for ALL tasks to complete in parallel using join_all\n        let results = futures::future::join_all(tasks).await;\n\n        // Check if any task returned true (found unmaintained package)\n        results.into_iter().any(|r| r.unwrap_or(false))\n    }\n}\n\n#[derive(Debug, Serialize)]\nstruct OsvQueryRequest {\n    package: OsvPackage,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    version: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\nstruct OsvPackage {\n    name: String,\n    ecosystem: String,\n}\n\n#[derive(Debug, Serialize)]\nstruct OsvBatchRequest {\n    queries: Vec<OsvQueryRequest>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvQueryResponse {\n    vulns: Option<Vec<OsvVulnerability>>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvBatchResponse {\n    results: Vec<OsvQueryResponse>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvVulnerability {\n    id: String,\n    summary: Option<String>,\n    details: Option<String>,\n    severity: Option<Vec<OsvSeverity>>,\n    references: Option<Vec<OsvReference>>,\n    aliases: Option<Vec<String>>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvSeverity {\n    #[serde(rename = \"type\")]\n    _type: String,\n    score: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvReference {\n    #[serde(rename = \"type\")]\n    _ref_type: String,\n    url: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvVulnerabilityDetails {\n    summary: Option<String>,\n    affected: Option<Vec<OsvAffected>>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvAffected {\n    database_specific: Option<OsvDatabaseSpecific>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OsvDatabaseSpecific {\n    informational: Option<String>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::vulnerabilities::Ecosystem;\n\n    #[test]\n    fn test_parse_cvss_severity() {\n        assert_eq!(parse_cvss_severity(\"9.8\"), VulnerabilitySeverity::Critical);\n        assert_eq!(parse_cvss_severity(\"9.0\"), VulnerabilitySeverity::Critical);\n        assert_eq!(parse_cvss_severity(\"7.5\"), VulnerabilitySeverity::High);\n        assert_eq!(parse_cvss_severity(\"5.0\"), VulnerabilitySeverity::Medium);\n        assert_eq!(parse_cvss_severity(\"3.0\"), VulnerabilitySeverity::Low);\n        assert_eq!(parse_cvss_severity(\"0.0\"), VulnerabilitySeverity::Low);\n        assert_eq!(\n            parse_cvss_severity(\"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H\"),\n            VulnerabilitySeverity::Medium\n        );\n    }\n\n    #[test]\n    fn test_ecosystem_osv_str() {\n        assert_eq!(Ecosystem::CratesIo.as_osv_str(), \"crates.io\");\n        assert_eq!(Ecosystem::Npm.as_osv_str(), \"npm\");\n        assert_eq!(Ecosystem::PyPI.as_osv_str(), \"PyPI\");\n        assert_eq!(Ecosystem::Go.as_osv_str(), \"Go\");\n        assert_eq!(Ecosystem::Packagist.as_osv_str(), \"Packagist\");\n        assert_eq!(Ecosystem::Pub.as_osv_str(), \"Pub\");\n        assert_eq!(Ecosystem::NuGet.as_osv_str(), \"NuGet\");\n    }\n\n    #[test]\n    fn test_convert_vulnerability() {\n        let osv = OsvVulnerability {\n            id: \"GHSA-xxxx-xxxx-xxxx\".to_string(),\n            summary: Some(\"Test vulnerability\".to_string()),\n            details: None,\n            severity: Some(vec![OsvSeverity {\n                _type: \"CVSS_V3\".to_string(),\n                score: \"7.5\".to_string(),\n            }]),\n            references: Some(vec![OsvReference {\n                _ref_type: \"ADVISORY\".to_string(),\n                url: \"https://example.com/advisory\".to_string(),\n            }]),\n            aliases: Some(vec![\"CVE-2021-12345\".to_string()]),\n        };\n\n        let vuln = OsvClient::convert_vulnerability(&osv);\n\n        assert_eq!(vuln.id, \"CVE-2021-12345\");\n        assert_eq!(vuln.severity, VulnerabilitySeverity::High);\n        assert_eq!(vuln.description, \"Test vulnerability\");\n        assert_eq!(vuln.url, Some(\"https://example.com/advisory\".to_string()));\n    }\n\n    #[test]\n    fn test_unmaintained_detection() {\n        let rustsec_vuln = OsvVulnerability {\n            id: \"RUSTSEC-2025-0057\".to_string(),\n            summary: Some(\"fxhash - no longer maintained\".to_string()),\n            details: None,\n            severity: None,\n            references: None,\n            aliases: None,\n        };\n\n        let is_unmaintained = rustsec_vuln.id.starts_with(\"RUSTSEC\")\n            && rustsec_vuln.summary.as_ref().is_some_and(|s| {\n                s.to_lowercase().contains(\"maintained\") || s.to_lowercase().contains(\"deprecated\")\n            });\n\n        assert!(is_unmaintained);\n\n        let normal_vuln = OsvVulnerability {\n            id: \"CVE-2024-1234\".to_string(),\n            summary: Some(\"Buffer overflow vulnerability\".to_string()),\n            details: None,\n            severity: None,\n            references: None,\n            aliases: None,\n        };\n\n        let is_not_unmaintained = normal_vuln.id.starts_with(\"RUSTSEC\")\n            && normal_vuln.summary.as_ref().is_some_and(|s| {\n                s.to_lowercase().contains(\"maintained\") || s.to_lowercase().contains(\"deprecated\")\n            });\n\n        assert!(!is_not_unmaintained);\n    }\n\n    #[tokio::test]\n    async fn test_fxhash_deprecated_detection() {\n        let client = OsvClient::new().unwrap();\n\n        let query = VulnerabilityQuery {\n            ecosystem: crate::vulnerabilities::Ecosystem::CratesIo,\n            package_name: \"fxhash\".to_string(),\n            version: \"0.2.1\".to_string(),\n        };\n\n        let results = client.query_batch(&[query]).await.unwrap();\n\n        assert!(!results.is_empty());\n\n        let result = &results[0];\n        assert!(!result.vulnerabilities.is_empty());\n        assert!(result.deprecated, \"fxhash should be marked as deprecated\");\n\n        let vuln = &result.vulnerabilities[0];\n        assert!(vuln.id.starts_with(\"RUSTSEC\"));\n    }\n}\n","traces":[{"line":31,"address":[13001184,13001788,13001782],"length":1,"stats":{"Line":2}},{"line":32,"address":[14605320,14605377,14605169,14605422,14605448],"length":1,"stats":{"Line":8}},{"line":34,"address":[14605254,14605799,14605270,14605328],"length":1,"stats":{"Line":4}},{"line":37,"address":[13001650],"length":1,"stats":{"Line":2}},{"line":38,"address":[14706193,14706124],"length":1,"stats":{"Line":4}},{"line":39,"address":[14605555],"length":1,"stats":{"Line":2}},{"line":43,"address":[14705745,14705120,14705739],"length":1,"stats":{"Line":2}},{"line":44,"address":[14705158],"length":1,"stats":{"Line":2}},{"line":47,"address":[14633398],"length":1,"stats":{"Line":10}},{"line":49,"address":[14604511],"length":1,"stats":{"Line":6}},{"line":51,"address":[14633465,14633603],"length":1,"stats":{"Line":4}},{"line":54,"address":[15756096,15756105],"length":1,"stats":{"Line":6}},{"line":55,"address":[15755936,15755945],"length":1,"stats":{"Line":6}},{"line":56,"address":[14633571],"length":1,"stats":{"Line":2}},{"line":58,"address":[14604682],"length":1,"stats":{"Line":2}},{"line":61,"address":[15756273,15756256],"length":1,"stats":{"Line":6}},{"line":62,"address":[15756149,15756128],"length":1,"stats":{"Line":6}},{"line":64,"address":[12933040],"length":1,"stats":{"Line":6}},{"line":65,"address":[15755870],"length":1,"stats":{"Line":2}},{"line":66,"address":[12992992,12992810,12993011],"length":1,"stats":{"Line":6}},{"line":67,"address":[12779664,12779648,12779530],"length":1,"stats":{"Line":6}},{"line":80,"address":[13003728],"length":1,"stats":{"Line":0}},{"line":81,"address":[14708862],"length":1,"stats":{"Line":0}},{"line":85,"address":[14633056],"length":1,"stats":{"Line":2}},{"line":86,"address":[14604157,14604222],"length":1,"stats":{"Line":4}},{"line":88,"address":[13000376,13000314],"length":1,"stats":{"Line":4}},{"line":89,"address":[13000344,13000415],"length":1,"stats":{"Line":4}},{"line":90,"address":[14705053,14705007],"length":1,"stats":{"Line":4}},{"line":91,"address":[14705046],"length":1,"stats":{"Line":2}},{"line":95,"address":[14604194],"length":1,"stats":{"Line":2}},{"line":103,"address":[14633296],"length":1,"stats":{"Line":2}},{"line":107,"address":[12774560,12774719],"length":1,"stats":{"Line":4}},{"line":108,"address":[12775364,12774772],"length":1,"stats":{"Line":0}},{"line":124,"address":[12987991,12987912],"length":1,"stats":{"Line":4}},{"line":125,"address":[12927907,12928860,12928489,12929838,12928391],"length":1,"stats":{"Line":6}},{"line":127,"address":[12929289,12929360],"length":1,"stats":{"Line":4}},{"line":128,"address":[12929517,12929411],"length":1,"stats":{"Line":0}},{"line":131,"address":[12723176],"length":1,"stats":{"Line":4}},{"line":133,"address":[12990003],"length":1,"stats":{"Line":2}},{"line":135,"address":[12931103,12930368,12930474],"length":1,"stats":{"Line":6}},{"line":136,"address":[12778038,12778151],"length":1,"stats":{"Line":4}},{"line":139,"address":[12777955],"length":1,"stats":{"Line":2}},{"line":141,"address":[12991288],"length":1,"stats":{"Line":2}},{"line":144,"address":[12931788,12931920],"length":1,"stats":{"Line":4}},{"line":147,"address":[12991403],"length":1,"stats":{"Line":2}},{"line":149,"address":[12778640,12778654,12778354],"length":1,"stats":{"Line":6}},{"line":150,"address":[12992387,12991593,12992352],"length":1,"stats":{"Line":6}},{"line":153,"address":[12931965,12927949,12930590,12930624],"length":1,"stats":{"Line":6}},{"line":155,"address":[12990666,12990619],"length":1,"stats":{"Line":4}},{"line":156,"address":[12777493],"length":1,"stats":{"Line":2}},{"line":161,"address":[12777777],"length":1,"stats":{"Line":2}},{"line":164,"address":[12993088,12993281,12994109,12993230,12993119,12994471],"length":1,"stats":{"Line":8}},{"line":165,"address":[12933503,12933612],"length":1,"stats":{"Line":4}},{"line":166,"address":[12780119],"length":1,"stats":{"Line":0}},{"line":169,"address":[12933974,12933660,12933917,12933618],"length":1,"stats":{"Line":4}},{"line":177,"address":[12780675,12781748,12781200,12781742],"length":1,"stats":{"Line":4}},{"line":178,"address":[12994505],"length":1,"stats":{"Line":2}},{"line":179,"address":[12994776,12994707],"length":1,"stats":{"Line":4}},{"line":180,"address":[12994792],"length":1,"stats":{"Line":2}},{"line":182,"address":[12781919,12783566,12781888,12782264,12781570,12782031,12784994,12781988],"length":1,"stats":{"Line":8}},{"line":183,"address":[12995598,12995245,12995302,12995404],"length":1,"stats":{"Line":6}},{"line":184,"address":[12782616],"length":1,"stats":{"Line":2}},{"line":185,"address":[12995817],"length":1,"stats":{"Line":0}},{"line":186,"address":[12936121,12936823,12936528],"length":1,"stats":{"Line":0}},{"line":187,"address":[12783193],"length":1,"stats":{"Line":0}},{"line":191,"address":[12782039,12782810,12783580,12782704],"length":1,"stats":{"Line":6}},{"line":192,"address":[12997206],"length":1,"stats":{"Line":2}},{"line":193,"address":[12937447],"length":1,"stats":{"Line":0}},{"line":194,"address":[12998753,12997175,12998500],"length":1,"stats":{"Line":0}},{"line":195,"address":[12785351],"length":1,"stats":{"Line":0}},{"line":199,"address":[12937669,12939696,12937590],"length":1,"stats":{"Line":6}},{"line":201,"address":[12939920,12940158,12940164,12939710],"length":1,"stats":{"Line":4}},{"line":202,"address":[12939929],"length":1,"stats":{"Line":2}},{"line":203,"address":[12940023,12939961],"length":1,"stats":{"Line":4}},{"line":207,"address":[12939856,12939740],"length":1,"stats":{"Line":4}},{"line":208,"address":[12940176,12939865],"length":1,"stats":{"Line":4}},{"line":209,"address":[12940224,12940201],"length":1,"stats":{"Line":4}},{"line":211,"address":[12999945],"length":1,"stats":{"Line":2}},{"line":212,"address":[12940256,12940265,12940242],"length":1,"stats":{"Line":6}},{"line":217,"address":[12999488],"length":1,"stats":{"Line":2}},{"line":220,"address":[12937706],"length":1,"stats":{"Line":2}},{"line":221,"address":[12997859,12997921,12997460],"length":1,"stats":{"Line":2}},{"line":224,"address":[12938201],"length":1,"stats":{"Line":0}},{"line":225,"address":[12997770],"length":1,"stats":{"Line":0}},{"line":226,"address":[15762809,15762800,15761099],"length":1,"stats":{"Line":0}},{"line":227,"address":[12997823],"length":1,"stats":{"Line":0}},{"line":231,"address":[12937717],"length":1,"stats":{"Line":2}},{"line":237,"address":[12780883,12780024,12780721],"length":1,"stats":{"Line":4}},{"line":240,"address":[12935360,12935382,12934630],"length":1,"stats":{"Line":6}}],"covered":74,"coverable":89},{"path":["/","home","matvei","projets","zed-dependi","dependi-lsp","tests","integration_test.rs"],"content":"//! Integration tests for dependi-lsp\n\nuse dependi_lsp::cache::{MemoryCache, ReadCache, WriteCache};\nuse dependi_lsp::parsers::Parser;\nuse dependi_lsp::parsers::cargo::CargoParser;\nuse dependi_lsp::parsers::npm::NpmParser;\nuse dependi_lsp::providers::inlay_hints::create_inlay_hint;\nuse dependi_lsp::registries::VersionInfo;\n\n/// Test parsing a realistic Cargo.toml file\n#[test]\nfn test_parse_realistic_cargo_toml() {\n    let content = r#\"\n[package]\nname = \"my-awesome-app\"\nversion = \"0.1.0\"\nedition = \"2024\"\nlicense = \"MIT\"\n\n[dependencies]\ntokio = { version = \"1.35\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nreqwest = { version = \"0.12\", features = [\"json\", \"rustls-tls\"], default-features = false }\nanyhow = \"1\"\nthiserror = \"2\"\ntracing = \"0.1\"\n\n[dev-dependencies]\ntokio-test = \"0.4\"\ncriterion = { version = \"0.5\", features = [\"html_reports\"] }\n\n[build-dependencies]\ncc = \"1.0\"\n\"#;\n\n    let parser = CargoParser::new();\n    let deps = parser.parse(content);\n\n    // Should find all dependencies\n    assert_eq!(deps.len(), 10);\n\n    // Check regular dependencies\n    let tokio = deps.iter().find(|d| d.name == \"tokio\").unwrap();\n    assert_eq!(tokio.version, \"1.35\");\n    assert!(!tokio.dev);\n\n    let serde_json = deps.iter().find(|d| d.name == \"serde_json\").unwrap();\n    assert_eq!(serde_json.version, \"1.0\");\n\n    // Check dev dependencies\n    let tokio_test = deps.iter().find(|d| d.name == \"tokio-test\").unwrap();\n    assert!(tokio_test.dev);\n\n    let criterion = deps.iter().find(|d| d.name == \"criterion\").unwrap();\n    assert!(criterion.dev);\n    assert_eq!(criterion.version, \"0.5\");\n\n    // Check build dependencies (treated as regular for now)\n    let cc = deps.iter().find(|d| d.name == \"cc\").unwrap();\n    assert_eq!(cc.version, \"1.0\");\n}\n\n/// Test parsing a realistic package.json file\n#[test]\nfn test_parse_realistic_package_json() {\n    let content = r#\"{\n  \"name\": \"my-react-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A sample React application\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"axios\": \"^1.6.0\",\n    \"@tanstack/react-query\": \"^5.0.0\",\n    \"lodash\": \"^4.17.21\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-dom\": \"^18.2.0\",\n    \"typescript\": \"^5.3.0\",\n    \"@testing-library/react\": \"^14.0.0\",\n    \"prettier\": \"^3.1.0\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\"\n  }\n}\"#;\n\n    let parser = NpmParser::new();\n    let deps = parser.parse(content);\n\n    // Should find all dependencies\n    assert_eq!(deps.len(), 11);\n\n    // Check regular dependencies\n    let react = deps\n        .iter()\n        .find(|d| d.name == \"react\" && !d.optional)\n        .unwrap();\n    assert_eq!(react.version, \"^18.2.0\");\n    assert!(!react.dev);\n\n    // Check scoped packages\n    let react_query = deps\n        .iter()\n        .find(|d| d.name == \"@tanstack/react-query\")\n        .unwrap();\n    assert_eq!(react_query.version, \"^5.0.0\");\n\n    // Check dev dependencies\n    let typescript = deps.iter().find(|d| d.name == \"typescript\").unwrap();\n    assert!(typescript.dev);\n    assert_eq!(typescript.version, \"^5.3.0\");\n\n    // Check peer dependencies (marked as optional)\n    let peer_react = deps\n        .iter()\n        .find(|d| d.name == \"react\" && d.optional)\n        .unwrap();\n    assert_eq!(peer_react.version, \">=16.8.0\");\n}\n\n/// Test cache integration\n#[test]\nfn test_cache_integration() {\n    let cache = MemoryCache::new();\n\n    // Insert some version info\n    let serde_info = VersionInfo {\n        latest: Some(\"1.0.200\".to_string()),\n        latest_prerelease: None,\n        versions: vec![\"1.0.200\".to_string(), \"1.0.199\".to_string()],\n        description: Some(\"A serialization framework\".to_string()),\n        homepage: None,\n        repository: Some(\"https://github.com/serde-rs/serde\".to_string()),\n        license: Some(\"MIT OR Apache-2.0\".to_string()),\n        vulnerabilities: vec![],\n        deprecated: false,\n        yanked: false,\n        yanked_versions: vec![],\n        release_dates: Default::default(),\n    };\n\n    cache.insert(\"crates:serde\".to_string(), serde_info.clone());\n\n    // Retrieve and verify\n    let retrieved = cache.get(\"crates:serde\").unwrap();\n    assert_eq!(retrieved.latest, Some(\"1.0.200\".to_string()));\n    assert_eq!(retrieved.license, Some(\"MIT OR Apache-2.0\".to_string()));\n\n    // Test cache miss\n    assert!(cache.get(\"crates:nonexistent\").is_none());\n}\n\n/// Test inlay hint generation with various scenarios\n#[test]\nfn test_inlay_hint_generation() {\n    use dependi_lsp::parsers::Dependency;\n\n    // Up-to-date dependency\n    let dep_up_to_date = Dependency {\n        name: \"serde\".to_string(),\n        version: \"1.0.200\".to_string(),\n        line: 5,\n        name_start: 0,\n        name_end: 5,\n        version_start: 9,\n        version_end: 18,\n        dev: false,\n        optional: false,\n    };\n\n    let info_up_to_date = VersionInfo {\n        latest: Some(\"1.0.200\".to_string()),\n        ..Default::default()\n    };\n\n    let hint = create_inlay_hint(&dep_up_to_date, Some(&info_up_to_date));\n    match hint.label {\n        tower_lsp::lsp_types::InlayHintLabel::String(s) => {\n            assert!(s.contains(\"✓\"), \"Expected checkmark for up-to-date dep\");\n        }\n        _ => panic!(\"Expected string label\"),\n    }\n\n    // Outdated dependency\n    let dep_outdated = Dependency {\n        name: \"tokio\".to_string(),\n        version: \"1.0.0\".to_string(),\n        line: 6,\n        name_start: 0,\n        name_end: 5,\n        version_start: 9,\n        version_end: 16,\n        dev: false,\n        optional: false,\n    };\n\n    let info_outdated = VersionInfo {\n        latest: Some(\"1.35.0\".to_string()),\n        ..Default::default()\n    };\n\n    let hint = create_inlay_hint(&dep_outdated, Some(&info_outdated));\n    match hint.label {\n        tower_lsp::lsp_types::InlayHintLabel::String(s) => {\n            assert!(s.contains(\"->\"), \"Expected arrow for outdated dep\");\n            assert!(s.contains(\"1.35.0\"), \"Expected latest version in hint\");\n        }\n        _ => panic!(\"Expected string label\"),\n    }\n\n    // Unknown version (no info) - shows ? Unknown with troubleshooting tooltip\n    let hint = create_inlay_hint(&dep_outdated, None);\n    match hint.label {\n        tower_lsp::lsp_types::InlayHintLabel::String(s) => {\n            assert!(\n                s.contains(\"? Unknown\"),\n                \"Expected question mark for unknown/error status\"\n            );\n        }\n        _ => panic!(\"Expected string label\"),\n    }\n}\n\n/// Test parsing dependencies with various version specifiers\n#[test]\nfn test_version_specifier_parsing() {\n    let cargo_content = r#\"\n[dependencies]\ncaret = \"^1.0\"\ntilde = \"~1.0.0\"\nexact = \"=1.0.0\"\nrange = \">=1.0, <2.0\"\nwildcard = \"1.*\"\n\"#;\n\n    let parser = CargoParser::new();\n    let deps = parser.parse(cargo_content);\n\n    assert_eq!(deps.len(), 5);\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"caret\").unwrap().version,\n        \"^1.0\"\n    );\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"tilde\").unwrap().version,\n        \"~1.0.0\"\n    );\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"exact\").unwrap().version,\n        \"=1.0.0\"\n    );\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"range\").unwrap().version,\n        \">=1.0, <2.0\"\n    );\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"wildcard\").unwrap().version,\n        \"1.*\"\n    );\n}\n\n/// Test parsing npm packages with various version formats\n#[test]\nfn test_npm_version_formats() {\n    let content = r#\"{\n  \"dependencies\": {\n    \"caret\": \"^1.0.0\",\n    \"tilde\": \"~1.0.0\",\n    \"range\": \">=1.0.0 <2.0.0\",\n    \"hyphen\": \"1.0.0 - 2.0.0\",\n    \"exact\": \"1.0.0\",\n    \"latest\": \"*\",\n    \"tag\": \"latest\"\n  }\n}\"#;\n\n    let parser = NpmParser::new();\n    let deps = parser.parse(content);\n\n    assert_eq!(deps.len(), 7);\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"caret\").unwrap().version,\n        \"^1.0.0\"\n    );\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"range\").unwrap().version,\n        \">=1.0.0 <2.0.0\"\n    );\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"latest\").unwrap().version,\n        \"*\"\n    );\n    assert_eq!(\n        deps.iter().find(|d| d.name == \"tag\").unwrap().version,\n        \"latest\"\n    );\n}\n\n/// Test that positions are correctly tracked\n#[test]\nfn test_dependency_positions() {\n    let content = r#\"[dependencies]\nserde = \"1.0.0\"\ntokio = { version = \"1.35\" }\n\"#;\n\n    let parser = CargoParser::new();\n    let deps = parser.parse(content);\n\n    // serde should be on line 1 (0-indexed)\n    let serde = deps.iter().find(|d| d.name == \"serde\").unwrap();\n    assert_eq!(serde.line, 1);\n\n    // tokio should be on line 2\n    let tokio = deps.iter().find(|d| d.name == \"tokio\").unwrap();\n    assert_eq!(tokio.line, 2);\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":55.81144296509536,"covered":1551,"coverable":2779}